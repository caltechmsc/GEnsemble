####################################################################################
#                                                                                  #
# ShortRangeList generates lists of short range interactions:                      #
#                                                                                  #
# BondList             : an array of bond pairs (i, j)                             #
# AngleList            : an array of angles (i, j, k)                              #
# TorsionList          : an array of torsions (i, j, k, l)                         #
# InversionList3Coord  : an array of inversions (i, j, k, l) with only             #
#                        3-coordinated center atoms                                #
# InversionListAll     : an array of all possible inversions (i, j, k, l)          #
#                                                                                  #
# These lists are mainly used to compute valence bond energy and forces.           #
# Note that exclusion list may be different from short range list when constraints #
# exist. e.g. a fixed bond is NOT in bond list for energy calculation but still in # 
# exclusion list.                                                                  #
#                                                                                  #
# Created on 08/02/06, last revision on 08/04/06. yi                               #
#                                                                                  #
####################################################################################

import numpy

class ShortRangeList:

    def __init__(self):

        return

    def calcSRlist(self):

        return

class BondList(ShortRangeList):

    def __init__(self):

        return

    def calcSRlist(self, moveList, conList):
        """
        Generate bond list:
        bonList[numBond][0] : atom number of first atom(I) in numBond bond  
        bonList[numBond][1] : atom number of second atom(J) in numBond bond  
        Note: I < J
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0

        for i in range(numAtoms):  # Loop over all atoms (both movable and fixed atoms).
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms (both movable and fixed atoms).
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])

                numBonds +=  1

        print 'Number of Bonds = ', numBonds

        return bondList

class AngleList(ShortRangeList):

    def __init__(self):

        return

    def calcSRlist(self, moveList, conList):
        """
        Generate angle list:
        angleList[numAng][0] : atom number of first atom(I) in numBond bond  
        angleList[numAng][1] : atom number of second atom(J) in numBond bond  
        angleList[numAng][3] : atom number of third atom(K) in numBond bond  
        Note: J is a center atom and I < K.
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0

        # Generate bond lists first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of Bonds = ', numBonds

        # Generate angle list based on bond lists.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                if moveList[iOne] != 0 and moveList[iTwo] != 0 and moveList[jOne] != 0 and moveList[jTwo] != 0:
                    continue  # If all atoms are fixed or ignored, go to next.
                if iOne == jOne and iTwo < jTwo:
                    angleList.append([iTwo, iOne, jTwo])    
                    numAngles += 1 
                    continue
                elif iOne == jTwo and iTwo < jOne: 
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1 
                    continue
                elif iTwo == jOne and iOne < jTwo: 
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1 
                    continue
                elif iTwo == jTwo and iOne < jOne: 
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1 
                    continue
                else:
                    continue

        print 'Number of Angles = ', numAngles

        return angleList

class TorsionList(ShortRangeList):

    def __init__(self):

        return 

    def calcSRlist(self, moveList, conList):
        """
        Generate torsion list:
        torsionList[numAng][0] : atom number of first atom(I) in numBond bond  
        torsionList[numAng][1] : atom number of second atom(J) in numBond bond  
        torsionList[numAng][3] : atom number of third atom(K) in numBond bond  
        torsionList[numAng][4] : atom number of fourth atom(L) in numBond bond  
        Note: J and K are center atoms and J < K.
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0
        torsionList = []
        numTorsions = 0

        # Generate bond list first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of Bonds = ', numBonds

        # Generate angle list based on bond list.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                # Note that the following angles lists could contain fixed angles. This is allowed because
                # the fourth atom in torsion can be movable.
                if iOne == jOne and iTwo < jTwo: 
                    angleList.append([iTwo, iOne, jTwo])    
                    numAngles += 1 
                    continue
                elif iOne == jTwo and iTwo < jOne: 
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1 
                    continue
                elif iTwo == jOne and iOne < jTwo: 
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1 
                    continue
                elif iTwo == jTwo and iOne < jOne: 
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1 
                    continue
                else:
                    continue

        #print 'Number of Angles = ', numAngles

        # Generate torsion list based on angle list.        
        for i in range(numAngles):
            iOne = angleList[i][0]
            iTwo = angleList[i][1]
            iThree = angleList[i][2]
            for j in range(numAngles):
                if i == j: continue
                jOne = angleList[j][0]
                jTwo = angleList[j][1]
                jThree = angleList[j][2]
                if moveList[iOne] != 0 and moveList[iTwo] != 0 and moveList[iThree] != 0 and  \
                    moveList[jOne] != 0 and moveList[jTwo] != 0 and moveList[jThree] != 0:
                    continue  # If all atoms are fixed or ignored, go to next.
                if iOne == jTwo and iTwo == jOne and iTwo < iOne:
                    torsionList.append([iThree, iTwo, iOne, jThree])
                    numTorsions += 1
                    continue
                elif iTwo == jOne and iThree == jTwo and iTwo < iThree:
                    torsionList.append([iOne, iTwo, iThree, jThree])
                    numTorsions += 1
                    continue
                elif iTwo == jThree and iOne == jTwo and iTwo < iOne:
                    torsionList.append([iThree, iTwo, iOne, jOne])
                    numTorsions += 1
                    continue
                elif iTwo == jThree and iThree == jTwo and iTwo < iThree:
                    torsionList.append([iOne, iTwo, iThree, jOne])
                    numTorsions += 1
                    continue
                else:
                    continue

        print 'Number of Torsions = ', numTorsions

        return torsionList

class InversionList3Coord(ShortRangeList):

    def __init__(self):

        return

    def calcSRlist(self, moveList, conList):
        """
        Inversion terms are defined when a center atom has ONLY three bonds.
        Generate inversion list:
        inversionList[numAng][0] : atom number of first atom(I) in numBond bond  
        inversionList[numAng][1] : atom number of second atom(J) in numBond bond  
        inversionList[numAng][3] : atom number of third atom(K) in numBond bond  
        inversionList[numAng][4] : atom number of fourth atom(L) in numBond bond  
        Note: I is a center atom. Inversion angle is defined as one between 
        the IL bond and the JIK plane. Three choices of IL bonds are slightly 
        different and are all calculated followed by normalization (divided by 3).  
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        inversionList = []
        numInversions = 0

        # Count central atoms with only three bonds.
        inversionList = []
        numInversions = 0
        for i in range(numAtoms):
            iBonds = 0
            iOne = i
            iCon = i * maxCon 
            for j in range(maxCon):
                iTwo = conList[iCon+j] - 1
                iBonds += 1 
                if iTwo == -1:
                    iBonds -= 1
                    if iBonds == 3:
                        # Note that we choose three different L atoms to make IL bonds. 
                        # This is required by Dreiding FF. 
                        inversionList.append([iOne, conList[iCon]-1, conList[iCon+1]-1, conList[iCon+2]-1])
                        inversionList.append([iOne, conList[iCon]-1, conList[iCon+2]-1, conList[iCon+1]-1])
                        inversionList.append([iOne, conList[iCon+1]-1, conList[iCon+2]-1, conList[iCon]-1])
                        numInversions += 3
                    break

        print 'Number of Inversion (3-coordinate) = ', numInversions

        return inversionList

class InversionListAll(ShortRangeList):

    def __init__(self):

        return

    def calcSRlist(self, moveList, conList):
        """
        Note: this full inversion list is NOT used in Dreiding FF. It can be used 
        in exclusion after slight modification.  
        Generate inversion list for ALL possible inversions:
        inversionList[numAng][0] : atom number of first atom(I) in numBond bond  
        inversionList[numAng][1] : atom number of second atom(J) in numBond bond  
        inversionList[numAng][3] : atom number of third atom(K) in numBond bond  
        inversionList[numAng][4] : atom number of fourth atom(L) in numBond bond  
        Note: I is a center atom and J < K < L.
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0
        inversionList = []
        numInversions = 0

        # Generate bond list first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of Bonds = ', numBonds

        # Generate angle list based on bond list.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                # Note that the following angles lists could contain fixed angles. This is allowed because
                # the fourth atom in torsion can be movable.
                if iOne == jOne and iTwo < jTwo: 
                    angleList.append([iTwo, iOne, jTwo])    
                    numAngles += 1 
                    continue
                elif iOne == jTwo and iTwo < jOne: 
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1 
                    continue
                elif iTwo == jOne and iOne < jTwo: 
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1 
                    continue
                elif iTwo == jTwo and iOne < jOne: 
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1 
                    continue
                else:
                    continue

        #print 'Number of Angles = ', numAngles

        # Generate inversion list based on angle list.        
        for i in range(numAngles):
            iOne = angleList[i][0]
            iTwo = angleList[i][1]
            iThree = angleList[i][2]
            for j in range(numAngles):
                if i == j: continue
                jOne = angleList[j][0]
                jTwo = angleList[j][1]
                jThree = angleList[j][2]
                if moveList[iOne] != 0 and moveList[iTwo] != 0 and moveList[iThree] != 0 and  \
                    moveList[jOne] != 0 and moveList[jTwo] != 0 and moveList[jThree] != 0:
                    continue  # If all atoms are fixed or ignored, go to next.
                if iTwo == jTwo and iOne == jOne and iOne < iThree and iThree < jThree:
                    inversionList.append([iTwo, iOne, iThree, jThree])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iOne == jThree and iOne < iThree and iThree < jOne:
                    inversionList.append([iTwo, iOne, iThree, jOne])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iThree == jOne and iThree < iOne and iOne < jThree:
                    inversionList.append([iTwo, iThree, iOne, jThree])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iThree == jThree and iThree < iOne and iOne < jOne:
                    inversionList.append([iTwo, iThree, iOne, jOne])
                    numInversions += 1
                    continue
                else:
                    continue

        print 'Number of Inversions (all) = ', numInversions

        return inversionList

