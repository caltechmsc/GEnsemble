C
C  Fortran subroutines used in utility_pf.py
C  To use these methods, import utility_f  
C
C  Last revision: 06/03/06 yi
C
      subroutine calcpositioncm(n, mass, r, rcm) 
        implicit none
        integer n, i, i31, i32, i33
        double precision mass(n), r(3*n), rcm(3)
        double precision totMass
cf2py   integer intent (hide), depend(mass) :: n = len(mass)
cf2py   intent (in) mass, r
cf2py   intent (out) rcm
        totMass = 0.
        rcm(1) = 0.
        rcm(2) = 0.
        rcm(3) = 0.
        do 100 i = 1, n
            i31 = (i - 1) * 3 + 1
            i32 = i31 + 1
            i33 = i31 + 2
            totMass = totMass + mass(i)
            rcm(1) = rcm(1) + r(i31) * mass(i)
            rcm(2) = rcm(2) + r(i32) * mass(i)
            rcm(3) = rcm(3) + r(i33) * mass(i)
100     continue 
        rcm(1) = rcm(1) / totMass
        rcm(2) = rcm(2) / totMass
        rcm(3) = rcm(3) / totMass
     
      end subroutine

      subroutine calcinertia(n, mass, r, inert)  
        implicit none
        integer n, i, i31, i32, i33
        double precision mass(n), r(3*n), rcm(3), inert(3,3)
        double precision totMass
        double precision mxx, myy, mzz, mxy, myz, mzx
        double precision xrel, yrel, zrel
cf2py   integer intent (hide), depend(mass) :: n = len(mass)
cf2py   intent (in) mass, r
cf2py   intent (out) inert
C compute position CM
        totMass = 0.
        rcm(1) = 0.
        rcm(2) = 0.
        rcm(3) = 0.
        do 100 i = 1, n
            i31 = (i - 1) * 3 + 1
            i32 = i31 + 1
            i33 = i31 + 2
            totMass = totMass + mass(i)
            rcm(1) = rcm(1) + r(i31) * mass(i)
            rcm(2) = rcm(2) + r(i32) * mass(i)
            rcm(3) = rcm(3) + r(i33) * mass(i)
100     continue
        rcm(1) = rcm(1) / totMass
        rcm(2) = rcm(2) / totMass
        rcm(3) = rcm(3) / totMass

C compute inertia tensor I 
        mxx = 0.
        myy = 0.
        mzz = 0.
        mxy = 0.
        myz = 0.
        mzx = 0.
        do 200 i = 1, n
            i31 = (i - 1) * 3 + 1
            i32 = i31 + 1
            i33 = i31 + 2
            xrel = r(i31) - rcm(1)
            yrel = r(i32) - rcm(2)
            zrel = r(i33) - rcm(3)
            
            mxx = mxx + mass(i) * xrel * xrel
            myy = myy + mass(i) * yrel * yrel
            mzz = mzz + mass(i) * zrel * zrel
            mxy = mxy + mass(i) * xrel * yrel
            myz = myz + mass(i) * yrel * zrel
            mzx = mzx + mass(i) * zrel * xrel
200     continue
        inert(1,1) =  myy + mzz
        inert(1,2) = -mxy      
        inert(1,3) = -mzx
        inert(2,1) = -mxy
        inert(2,2) =  mxx + mzz
        inert(2,3) = -myz 
        inert(3,1) = -mzx 
        inert(3,2) = -myz 
        inert(3,3) =  mxx + myy

      end subroutine

      subroutine calcangularmomentum(n, mass, r, v, angm)
        implicit none
        integer n, i, i31, i32, i33
        double precision mass(n), r(3*n), v(3*n), angm(3) 
        double precision rcm(3), vcm(3)
        double precision totMass
cf2py   integer intent (hide), depend(mass) :: n = len(mass)
cf2py   intent (in) mass, r, v
cf2py   intent (out) angm
        totMass = 0.
        do 50 i = 1, 3
            rcm(i) = 0.
            vcm(i) = 0.
            angm(i) = 0.
50      continue
        do 100 i = 1, n
            i31 = (i - 1) * 3 + 1
            i32 = i31 + 1
            i33 = i31 + 2
            totMass = totMass + mass(i)
            rcm(1) = rcm(1) + r(i31) * mass(i)
            rcm(2) = rcm(2) + r(i32) * mass(i)
            rcm(3) = rcm(3) + r(i33) * mass(i)

            vcm(1) = vcm(1) + v(i31) * mass(i)
            vcm(2) = vcm(2) + v(i32) * mass(i)
            vcm(3) = vcm(3) + v(i33) * mass(i)

            angm(1) = angm(1) + mass(i)*(r(i32)*v(i33) - r(i33)*v(i32))
            angm(2) = angm(2) + mass(i)*(r(i33)*v(i31) - r(i31)*v(i33))
            angm(3) = angm(3) + mass(i)*(r(i31)*v(i32) - r(i32)*v(i31))
100     continue
        angm(1) = angm(1) - (rcm(2) * vcm(3) - rcm(3) * vcm(2))/totMass
        angm(2) = angm(2) - (rcm(3) * vcm(1) - rcm(1) * vcm(3))/totMass
        angm(3) = angm(3) - (rcm(1) * vcm(2) - rcm(2) * vcm(1))/totMass

      end subroutine

      subroutine translatecm(n, mass, r, ref)
c Translate system coordinates(r) to ref.
        implicit none
        integer n, i, i31, i32, i33
        double precision mass(n), r(3*n), ref(3)
        double precision cmx, cmy, cmz, totMass 
        double precision deltax, deltay, deltaz
cf2py   integer intent (hide), depend(mass) :: n = len(mass)        
cf2py   intent (in) mass, ref
cf2py   intent (in, out) r
        totMass = 0.
        cmx = 0.
        cmy = 0.
        cmz = 0.
        do 100 i = 1, n
            i31 = 3 * (i - 1) + 1
            i32 = i31 + 1
            i33 = i31 + 2
            totMass = totMass + mass(i)
            cmx = cmx + r(i31) * mass(i)
            cmy = cmy + r(i32) * mass(i)
            cmz = cmz + r(i33) * mass(i)
100     continue 
        cmx = cmx / totMass
        cmy = cmy / totMass
        cmz = cmz / totMass

        deltax = cmx - ref(1)
        deltay = cmy - ref(2)
        deltaz = cmz - ref(3)

        do 200 i = 1, n
            i31 = 3 * (i - 1) + 1
            i32 = i31 + 1
            i33 = i31 + 2
            r(i31) = r(i31) - deltax
            r(i32) = r(i32) - deltay
            r(i33) = r(i33) - deltaz
200     continue

      end subroutine

      subroutine calcvelocitycm(n, mass, v, vcm, tke) 
        implicit none
        integer n, i, i31, i32, i33
        double precision mass(n), v(3*n), vcm(3)
        double precision totMass, tke
cf2py   integer intent (hide), depend(mass) :: n = len(mass)
cf2py   intent (in) mass, v
cf2py   intent (out) vcm, tke
        totMass = 0.
        vcm(1) = 0.
        vcm(2) = 0.
        vcm(3) = 0.
        do 100 i = 1, n
            i31 = (i - 1) * 3 + 1
            i32 = i31 + 1
            i33 = i31 + 2
            totMass = totMass + mass(i)
            vcm(1) = vcm(1) + v(i31) * mass(i)
            vcm(2) = vcm(2) + v(i32) * mass(i)
            vcm(3) = vcm(3) + v(i33) * mass(i)
100     continue 
        vcm(1) = vcm(1) / totMass
        vcm(2) = vcm(2) / totMass
        vcm(3) = vcm(3) / totMass

        tke = 0.5 * totMass * (vcm(1) ** 2 + vcm(2) ** 2 + vcm(3) ** 2)
     
      end subroutine

       subroutine calcstresstensor(n, mass, r, v, f, stress)
            implicit none
            integer i, j, k, i3
            integer n
            double precision mass(n), r(3*n), v(3*n) 
            double precision f(3*n), stress(3,3) 
cf2py       integer intent (hide), depend(mass) :: n = len(mass)
cf2py       intent (in) mass, r, v, f
cf2py       intent (out) stress
            do 60 j = 1, 3
                do 50 k = 1, 3
                    stress(j, k) = 0.
50              continue
60          continue
            do 300 i = 1, n
                i3 = 3 * (i - 1)
                do 200 j = 1, 3 
                    do 100 k = 1, 3 
                        stress(j, k) = stress(j, k) + mass(i) * 
     &v(i3 + j) * v(i3 + k) + f(i3 + j) * r(i3 + k) 
100                 continue
200             continue
300         continue
       end subroutine    

       subroutine symstresstensor(stress)
            implicit none
            integer i, j
            double precision stress(3, 3)
            double precision symelem 
cf2py       intent (in, out) stress
            do 200 i = 1, 3
                do 100 j = i+1, 3
                    symelem = 0.5 * (stress(i, j) + stress(j, i))
                    stress(i, j) = symelem 
                    stress(j, i) = symelem 
100             continue
200         continue
       end subroutine

       subroutine calckinenergysum(n, mass, v, kinEnergySum)
            implicit none
            integer n
            double precision mass(n), v(3*n)
            double precision kinEnergySum 
            integer i, i3
cf2py       integer intent (hide), depend(mass) :: n = len(mass)
cf2py       intent (in) mass, v
cf2py       intent (out) kinEnergySum 
            kinEnergySum = 0.
            do 100 i = 1 , n
                i3 = (i - 1) * 3
                kinEnergySum = kinEnergySum + mass(i) * 
     &(v(i3 + 1) ** 2 + v(i3 + 2) ** 2 + v(i3 + 3) ** 2)
100         continue
       end subroutine

       subroutine totforce(n, imove, elements, r, f, totf, minz, maxz)
            implicit none
            integer i, i3
            integer n, imove(n)
            double precision r(3*n), f(3*n)
            character elements(n)
            double precision totf(3)
            real minz, maxz
cf2py       integer intent (hide), depend(imove) :: n = len(imove)
cf2py       intent (in) imove, element, r, f, minz, maxz
cf2py       intent (out) totf          
            totf(1) = 0.
            totf(2) = 0.
            totf(3) = 0.
            do 100 i = 1, n 
                i3 = 3 * (i - 1)
                if (imove(i) .eq. 0 .and. elements(i) .ne. 'H' 
     &.and. r(i3+3) > minz .and. r(i3+3) < maxz) then 
                    totf(1) = totf(1) + f(i3 + 1)
                    totf(2) = totf(2) + f(i3 + 2)
                    totf(3) = totf(3) + f(i3 + 3)
                end if
100         continue
       end subroutine

