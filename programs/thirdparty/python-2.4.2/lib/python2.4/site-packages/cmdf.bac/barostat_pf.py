#!/usr/bin/env python
################################################################################
#                                                                              #
#  Barostat class: Barostat used to control pressure in MD simulations         #
#                                                                              #
#  BerendsenP :            Berendsen barostat                                  #
#  AndersenHoover:         Andersen barostat & Nose-Hoover thermostat          #
#  ParrinelloRahmanHoover: Parrinello-Rahman barostat & Nose-Hoover thermostat #
#                                                                              #
#  Created on 02/07/06, last revision on 06/04/06. yi                          #
#                                                                              #
################################################################################

import numpy
from unit import *
from lapy import *   
from utility_pf import *
from control import *          

class Barostat:

    def __init__(self, targetPress=1.0):
        self.targetPress = targetPress

        return

    def initialize(self):

        return

    def run(self, cellDim, r, v, f, integrator):

        return

class BerendsenBarostat(Barostat):

    def __init__(self, targetPress=1.0, timeStep=0.1, tauPress=10., compress=4.6e-5, mass=numpy.ones(1, numpy.Float)): 
        Barostat.__init__(self, targetPress)
        self.timeStep = timeStep
        self.tauPress = tauPress
        self.compress = compress
        self.mass = mass

        return

    def initialize(self):

        return

    def run(self, cellDim, r, v, f, integrator):
    #
    #  Berendsen barostat:
    #  r = scale * rold       
    #  where scalp is a scaling factor:
    #  scalp = [1 + ((compress*dt)/taup)*(Pinst - Ptarget)]^(1/3)    
    #  where compress is the isothermal compressibility, 
    #  Pinst is the instantaneous pressure, Ptarget is the target pressure. 
    #  Stress tensor stress(3*3):
    #  stress = (1/V)*[m * v x v + r x f], V is the volume of box.  
    #  Pinst = (1/3.)*(pxx+pyy+pzz) in isotropic case.     
    #      
        from utility_pf import Utility
        util = Utility()

        targetPress = self.targetPress
        compress = self.compress
        dt = self.timeStep
        tauPress = self.tauPress
        mass = self.mass

        # Compute instantenuous pressure
        currentPress = util.calcPress(cellDim, mass, r, v, f, integrator)

        # Compute scaling factor
        scale = (1. + (compress * dt / tauPress) * (currentPress - targetPress)) ** (1./3.)

        # Scale positions
        r = r * scale

        # Scale cell sizes 
        cellDim[0] = cellDim[0] * scale
        cellDim[1] = cellDim[1] * scale
        cellDim[2] = cellDim[2] * scale

        return cellDim, r
    
class AndersenHoover(Barostat):
# Andersen barostat combined with Nose-Hoover thermostat.

    def __init__(self, targetPress=1.0, targetTemp=300., timeStep=0.1, numNose=4, freqNose=0.1, numSuz=3, dim=3, mass=numpy.ones(1, numpy.Float)):
        Barostat.__init__(self, targetPress)
        self.targetTemp = targetTemp
        self.timeStep = timeStep
        self.dim = dim
        self.mass = mass

        # Set parameters for Nose-Hoover thermostat chains
        self.numNose = numNose    # Maximum length of Nose-Hoover chain
        self.freqNose = freqNose  # Frequency of NH thermostats
        self.numSuz = numSuz      # The number of multiple time steps in Suzuki iteration

        # Set parameters for Nose-Hoover thermostat chains
        self.xnh = [0.0] * self.numNose  # Positions of NH thermostat.
        self.vnh = [0.0] * self.numNose  # Velocites of NH thermostat.
        self.qnh = [0.1] * self.numNose  # Masses of NH thermostat.
        self.gnh = [0.0] * self.numNose  # Forces of NH thermostat.
        #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
        #self.qnh[0] = self.degFree * massNose
        #for i in range(1,self.numNose):
        #    self.qnh[i] = massNose

        # Set parameters for Andersen barostat
        #self.dim = 3.
        ### Replace the following by calcVolume(system)
        #vol = self.system.getA() * self.system.getB() * self.system.getC()
        #self.xah = log(vol) / self.dim
        self.xah = 0.
        self.vah = 0.
        self.wah = 0.1
        #self.wah = (self.degFree + self.dim) * massNose
        self.gah = 0.
        self.count = 0

        return

    def initialize(self):

        return


    # Set parameters for Nose-Hoover thermostat chains
    #UNIT = Unit()
    ##xnh = [0.0] * 10  # Positions of NH thermostat.
    ##vnh = [0.0] * 10  # Velocites of NH thermostat.
    ##qnh = [0.1] * 10  # Masses of NH thermostat.
    ##gnh = [0.0] * 10  # Forces of NH thermostat.
    #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
    #qnh[0] = UNIT.degFree * massNose
    #for i in range(1, 10):
    #    qnh[i] = massNose

    # Set parameters for Andersen barostat
    ### Replace the following by calcVolume(system)
    #vol = self.system.getA() * self.system.getB() * self.system.getC()
    #xah = log(vol) / UNIT.dim
    ##xah = 0.
    ##vah = 0.
    ##wah = 0.1
    #wah = (UNIT.degFree + UNIT.dim) * massNose
    ##gah = 0.
    ##count = 0

    def run(self, degFree, cellDim, energy, r, v, f, integrator):
    # This function combines the Andersen-Hoover barostat 
    # and the Nose-Hoover thermostat. Integrate from t=0 to t=dt/2.
    # It updates the particle velocities, dlog(V)/dt,
    # thermostat velocities and thermostat positions.
        from math import exp, log
        from utility_pf import Utility
        unit = Unit()
        util = Utility()

        xah = self.xah
        vah = self.vah
        wah = self.wah
        gah = self.gah

        xnh = self.xnh
        vnh = self.vnh
        qnh = self.qnh
        gnh = self.gnh
        
        dim = self.dim
        mass = self.mass
        numAtoms = int(len(mass))
        massNose = unit.KB * self.targetTemp / (self.freqNose ** 2.)
        qnh[0] = degFree * massNose
        for i in range(1, self.numNose):
            qnh[i] = massNose
        wah = (degFree + dim) * massNose

        #print 'xnh=', xnh[0], xnh[1], xnh[2], xnh[3]
        #print 'vnh=', vnh[0], vnh[1], vnh[2], vnh[3]
        #print 'qnh=', qnh[0], qnh[1], qnh[2], qnh[3]
        #print 'gnh=', gnh[0], gnh[1], gnh[2], gnh[3]

        #print 'xah=', xah
        #print 'vah=', vah
        #print 'wah=', wah
        #print 'gah=', gah

        dt = self.timeStep
        nnose = self.numNose
        nnose1 = nnose - 1
        nc = self.numSuz

        odnf = 1. + dim / degFree
        gkt = unit.KB * self.targetTemp
        gn1kt = (degFree + 1) * gkt
        # xah = log(V) / dim
        vol = 2.71828 ** (dim * xah) 
        pext = self.targetPress

        # Set Yoshida-Suzuki weights. 
        nys = 3  # Order of Yoshida-Suzuki iteration 
        #nys = 5
        w = [1.] * nys
        if (nys == 3):
            #w[0] = 1. / (2. - 2. ** (1. / 3.))
            #w[1] = 1. - 2. * w[0]
            #w[2] = w[0] 
            w[0] = 1.351207192
            w[1] = -1.702414384
            w[2] = w[0]
        elif (nys == 5):
            #w[0] = 1. / (4. - 4. ** (1. / 3.))
            #w[1] = w[3] = w[4] = w[0]
            #w[2] = 1. - 4. * w[0]
            w[0] = 0.414490772
            w[1] = w[3] = w[4] = w[0]
            w[2] = -0.657963087
        else:
            nys = 1
            w = [1.] * nys

        wdti2 = [0.] * nys
        wdti4 = [0.] * nys
        wdti8 = [0.] * nys
        for i in range(nys):
            wdti = w[i] * dt / nc
            wdti2[i] = wdti / 2.
            wdti4[i] = wdti / 4.
            wdti8[i] = wdti / 8.

        scale = 1.0

        # Compute kinetic energy
        kinEnergy = util.calcKinEnergy(mass, v)
        kinEnergy2 = 2. * kinEnergy

        vir = 0.
        for i in range(numAtoms):
            i3  = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            vir += r[i3]  * f[i3]  +  \
                   r[i31] * f[i31] +  \
                   r[i32] * f[i32] 

        # Update the forces
        gnh[0] = (kinEnergy2 + wah * vah * vah - gn1kt) / qnh[0]
        # Here assume potential energy is independent of volume, dphi(r,V)/dV = 0.
        # Otherwise, (- dim * vol * dphi(r, V)/dV) should be added into the parenthesis. 
        # Explicit dependence of PE on volume occurs when long range ineractions are present.
        gah = (odnf * kinEnergy2 + vir - dim * pext * vol) / wah  
        # Start the multiple time step procedure
        for i in range(nc):
            for j in range(nys):
                # Update the thermostat velocities.
                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j]
                for k in range(1, nnose):
                    aa = exp(-wdti8[j] * vnh[nnose - k])
                    vnh[nnose1 - k] = vnh[nnose1 - k] * aa * aa  \
                         + wdti4[j] * gnh[nnose1 - k] * aa

                # Update dlog(V)/dt.
                aa = exp(-wdti8[j] * vnh[0])
                vah = vah * aa * aa + wdti4[j] * gah * aa
                # Update the particle velocities
                aa = exp(-wdti2[j] * (vnh[0] + odnf * vah))
                scale = scale * aa
                kinEnergy = kinEnergy * aa * aa
                gah = (odnf * kinEnergy2 + vir - dim * pext * vol) / wah
                # Update the thermostat positions
                for m in range(nnose):
                    xnh[m] = xnh[m] + vnh[m] * wdti2[j]

                # Update dlog(V)/dt
                aa = exp(-wdti8[j] * vnh[0])
                vah = vah * aa * aa + wdti4[j] * gah * aa
                # Update the forces
                gnh[0] = (kinEnergy2 + wah * vah * vah - gn1kt) / qnh[0]
                # Update the thermostat velocities
                for n in range(nnose1):
                    aa = exp(-wdti8[j] * vnh[n+1])
                    vnh[n] = vnh[n] * aa * aa + wdti4[j] * gnh[n] * aa
                    gnh[n+1] = (qnh[n] * vnh[n] * vnh[n] - gkt) / qnh[n+1]

                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j] 
        
        # Update the particle velocities.
        v = v * scale

        # Upload the thermostat and the barostat parameters
        self.xnh = xnh
        self.vnh = vnh
        self.qnh = qnh
        self.gnh = gnh

        self.xah = xah
        self.vah = vah
        self.wah = wah
        self.gah = gah

        # Compute the conserved quantity in Andersen-Hoover NPT dynamics.
        kepart = util.calcKinEnergy(mass, v)
        kenh = 0.
        for i in range(nnose):
            kenh += qnh[i] * vnh[i] * vnh[i]

        kenh = 0.5 * kenh
        keah = 0.5 * wah * vah * vah  

        pepart = energy
        penh0 = gn1kt * xnh[0]
        penhi = 0.
        for i in range(1, nnose):
            penhi += xnh[i]

        penhi = gkt * penhi
        penh = penh0 + penhi
        peah = pext * vol 

        hah = kepart + kenh + keah + pepart + penh + peah

        count = self.count
        count += 1
        if (count % 2 == 0.):
            out = open('hah.dat', 'a')
            out.write(str(count/2)+'  '+str(hah)+'\n')
            out.close()
        self.count = count

        return v

class ParrinelloRahmanHoover(Barostat):
    # This function combines the Parrinello-Rahman-Hoover barostat 
    # and the Nose-Hoover thermostat. Integrate from t=0 to t=dt/2.
    # It updates the particle velocities, box velocities,
    # thermostat velocities and thermostat positions.

    def __init__(self, targetPress=1.0, targetTemp=300., timeStep=0.1, numNose=4, freqNose=0.1, numSuz=3, dim=3, imove=numpy.zeros(1, numpy.Float), mass=numpy.ones(1, numpy.Float)):
        Barostat.__init__(self, targetPress)
        self.targetTemp = targetTemp
        self.timeStep = timeStep
        self.dim = dim
        self.imove = imove
        self.mass = mass

        # Set parameters for Nose-Hoover thermostat chains
        self.numNose = numNose    # Maximum length of Nose-Hoover chain
        self.freqNose = freqNose  # Frequency of NH thermostats
        self.numSuz = numSuz      # The number of multiple time steps in Suzuki iteration

        self.xnh = [0.0] * self.numNose  # Positions of NH thermostat.
        self.vnh = [0.0] * self.numNose  # Velocites of NH thermostat.
        self.qnh = [0.1] * self.numNose  # Masses of NH thermostat.
        self.gnh = [0.0] * self.numNose  # Forces of NH thermostat.
        #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
        #self.qnh[0] = self.degFree * massNose
        #for i in range(1,self.numNose):
        #    self.qnh[i] = massNose

        # Set parameters for Parrinello-Rahman barostat
        #self.dim = 3.
        self.vtemp = {}
        self.box = {}
        self.vbox = {}
        self.gbox = {}
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                self.vtemp[(i, j)] = 0.
                self.box[(i, j)] = 0.
                self.vbox[(i, j)] = 0.
                self.gbox[(i, j)] = 0.
            self.vtemp[(i, i)] = 1.
            self.box[(i, i)] = 1.
            self.vbox[(i, i)] = 0.
            self.gbox[(i, i)] = 1.
        #self.box[(1, 1)] = self.system.getA()
        #self.box[(2, 2)] = self.system.getB()
        #self.box[(3, 3)] = self.system.getC()
        #self.bmass = (self.degFree + self.dim) * massNose / self.dim
        self.bmass = 0.1
        self.count = 0

        return

    def initialize(self):

        return

    #UNIT = Unit()
    ##xnh = [0.0] * 10  # Positions of NH thermostat.
    ##vnh = [0.0] * 10  # Velocites of NH thermostat.
    ##qnh = [0.1] * 10  # Masses of NH thermostat.
    ##gnh = [0.0] * 10  # Forces of NH thermostat.
    #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
    #qnh[0] = Control.degFree * massNose
    #for i in range(1, self.numNose):
    #    qnh[i] = massNose

    # Set parameters for Parrinello-Rahman barostat
    #vtemp = {}
    #box = {}
    #vbox = {}
    #gbox = {}
    #for i in [1, 2, 3]:
    #    for j in [1, 2, 3]:
    #        vtemp[(i, j)] = 0.
    #        box[(i, j)] = 0.
    #        vbox[(i, j)] = 0.
    #        gbox[(i, j)] = 0.
    #    vtemp[(i, i)] = 1.
    #    box[(i, i)] = 1.
    #    vbox[(i, i)] = 0.
    #    gbox[(i, i)] = 1.
    #box[(1, 1)] = self.system.getA()
    #box[(2, 2)] = self.system.getB()
    #box[(3, 3)] = self.system.getC()
    #bmass = 0.1    
    #bmass = (Control.degFree + UNIT.dim) * massNose / UNIT.dim
    #count = 0

    def run(self, degFree, cellDim, energy, r, v, f, integrator):
        from math import exp, log
        from utility_pf import Utility
        unit = Unit()
        lapy = LAPy()
        util  = Utility()

        # Parrinello-Rahman barostat parameters
        vtemp = self.vtemp
        box   = self.box
        vbox  = self.vbox
        gbox  = self.gbox
        bmass = self.bmass

        # Nose-Hoover thermostat parameters 
        xnh = self.xnh
        vnh = self.vnh
        qnh = self.qnh
        gnh = self.gnh

        dim = self.dim
        imove = self.imove
        mass = self.mass
        numAtoms = int(len(mass))
        massNose = unit.KB * self.targetTemp / (self.freqNose ** 2.)
        qnh[0] = degFree * massNose
        for i in range(1, self.numNose):
            qnh[i] = massNose
        bmass = (degFree + dim) * massNose / dim
        """
        print 'xnh=', xnh[0], xnh[1], xnh[2], xnh[3]
        print 'vnh=', vnh[0], vnh[1], vnh[2], vnh[3]
        print 'qnh=', qnh[0], qnh[1], qnh[2], qnh[3]
        print 'gnh=', gnh[0], gnh[1], gnh[2], gnh[3]

        for i in range(1,self.numNose):
            for j in range(1,self.numNose):
                print 'box[',i,',',j,']=', box[(i, j)]
        for i in range(1,self.numNose):
            for j in range(1,self.numNose):
                print 'vbox[',i,',',j,']=', vbox[(i, j)]
        for i in range(1,self.numNose):
            for j in range(1,self.numNose):
                print 'gbox[',i,',',j,']=', gbox[(i, j)]
        print 'bmass=', bmass
        """

        dt = self.timeStep
        nnose = self.numNose
        nnose1 = nnose - 1
        nc = self.numSuz
        #xah = self.xah
        #vah = self.vah
        #wah = self.wah
        #gah = self.gah
        #veig = self.veig
        #veigv = self.veigv

        #odnf = 1. + dim / degFree
        onf = 1. / degFree
        pext = self.targetPress
        # onfm = onf * I (identity matrix)
        # pextm = pext * I
        onfm = {}
        pextm = {}
        for i in [1, 2, 3]:
            for j in [1, 2, 3]: 
                onfm[(i, j)] = 0.
                pextm[(i, j)] = 0.
            onfm[(i, i)] = onf
            pextm[(i, i)] = pext 

        gkt = unit.KB * self.targetTemp
        #gn1kt = (degFree + 1) * gkt
        gnd2kt = (degFree + dim ** 2) * gkt
        # V = det(box)
        vol = lapy.matDet(box)

        # Set Yoshida-Suzuki weights. 
        nys = 3  # Order of Yoshida-Suzuki iteration 
        #nys = 5
        w = [1.] * nys
        if (nys == 3):
            #w[0] = 1. / (2. - 2. ** (1. / 3.))
            #w[1] = 1. - 2. * w[0]
            #w[2] = w[0] 
            w[0] = 1.351207192
            w[1] = -1.702414384
            w[2] = w[0]
        elif (nys == 5):
            #w[0] = 1. / (4. - 4. ** (1. / 3.))
            #w[1] = w[3] = w[4] = w[0]
            #w[2] = 1. - 4. * w[0]
            w[0] = 0.414490772
            w[1] = w[3] = w[4] = w[0]
            w[2] = -0.657963087
        else:
            nys = 1
            w = [1.] * nys

        wdti2 = [0.] * nys
        wdti4 = [0.] * nys
        wdti8 = [0.] * nys
        for i in range(nys):
            wdti = w[i] * dt / nc
            wdti2[i] = wdti / 2.
            wdti4[i] = wdti / 4.
            wdti8[i] = wdti / 8.

        # Compute total kinetic energy for particles.
        kinEnergy = util.calcKinEnergy(mass, v)
        kinEnergy2 = 2. * kinEnergy

        # Compute total kinetic energy for box.
        kinEnergyBox = util.calcKinEnergyBox(bmass, vbox)
        kinEnergyBox2 = 2. * kinEnergyBox

        # Compute stress tensor multiplied by V (P*V).
        stress = util.calcStress(cellDim, mass, r, v, f, integator)
        #print 'stress=', stress

        # Update the forces
        gnh[0] = (kinEnergy2 + kinEnergyBox2 - gnd2kt) / qnh[0]
        # Here assume potential energy is independent of cell variables, dphi(r,V)/dh = 0.
        # Otherwise, (- h * dphi(r, V)/dh) should be added into the parenthesis. 
        # Explicit dependence of PE on volume occurs when long range ineractions are present.
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                gbox[(i, j)] = (onfm[(i, j)] * kinEnergy2 + stress[(i, j)]  \
                                - pextm[(i, j)] * vol) / bmass

        # Start the multiple time step procedure
        for i in range(nc):
            for j in range(nys):
                # Update the thermostat velocities.
                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j]
                for k in range(1, nnose):
                    aa = exp(-wdti8[j] * vnh[nnose - k])
                    vnh[nnose1 - k] = vnh[nnose1 - k] * aa * aa  \
                         + wdti4[j] * gnh[nnose1 - k] * aa

                # Update the box velocities.
                aa = exp(-wdti8[j] * vnh[0])
                for p in [1, 2, 3]:   
                    for q in [1, 2, 3]:   
                        vbox[(p, q)] = vbox[(p, q)] * aa * aa + wdti4[j] * gbox[(p, q)] * aa

                # Update the thermostat positions
                for m in range(nnose):
                    xnh[m] = xnh[m] + vnh[m] * wdti2[j]

                # Update the particle velocities
                trvg = onf * (vbox[(1, 1)] + vbox[(2, 2)] + vbox[(3, 3)]) 
                for p in [1, 2, 3]:   
                    for q in [1, 2, 3]:   
                        vtemp[(p, q)] = vbox[(p, q)] + trvg + vnh[0] 

                veig = {}
                veigv = {}
                nrot = 0
                # Compute eigenvalues and eigen vectors of vtemp. 
                lapy.jacobi(vtemp, 3, 3, veig, veigv, nrot)

                sc1 = exp(-veig[1] * wdti2[j])
                sc2 = exp(-veig[2] * wdti2[j])
                sc3 = exp(-veig[3] * wdti2[j])
                for ia in range(numAtoms):
                    if imove[ia] != 0:
                        continue

                    i3 = ia * 3
                    i31 = i3 + 1    
                    i32 = i3 + 2
                    uv1 = v[i3] * veigv[(1, 1)] + v[i31] * veigv[(2, 1)] + v[i32] * veigv[(3, 1)]
                    uv2 = v[i3] * veigv[(1, 2)] + v[i31] * veigv[(2, 2)] + v[i32] * veigv[(3, 2)]
                    uv3 = v[i3] * veigv[(1, 3)] + v[i31] * veigv[(2, 3)] + v[i32] * veigv[(3, 3)]

                    uv1 = uv1 * sc1
                    uv2 = uv2 * sc2
                    uv3 = uv3 * sc3

                    v[i3]  = uv1 * veigv[(1, 1)] + uv2 * veigv[(1, 2)] + uv3 * veigv[(1, 3)]
                    v[i31] = uv1 * veigv[(2, 1)] + uv2 * veigv[(2, 2)] + uv3 * veigv[(2, 3)]
                    v[i32] = uv1 * veigv[(3, 1)] + uv2 * veigv[(3, 2)] + uv3 * veigv[(3, 3)]

                # Compute the total kinetic energy.
                kinEnergy = util.calcKinEnergy(mass, v)
                kinEnergy2 = 2. * kinEnergy

                # Update the forces.
                # Compute stress tensor multiplied by V (P*V).
                stress = util.calcStress(cellDim, mass, r, v, f, integrator)

                for p in [1, 2, 3]:
                    for q in [1, 2, 3]:
                        gbox[(p, q)] = (onfm[(p, q)] * kinEnergy2 + stress[(p, q)]  \
                                        - pextm[(p, q)] * vol) / bmass

                # Update the box velocities.
                aa = exp(-wdti8[j] * vnh[0])
                for p in [1, 2, 3]:   
                    for q in [1, 2, 3]:   
                        vbox[(p, q)] = vbox[(p, q)] * aa * aa + wdti4[j] * gbox[(p, q)] * aa

                # Compute total kinetic energy for box.
                kinEnergyBox = util.calcKinEnergyBox(bmass, vbox)
                kinEnergyBox2 = 2. * kinEnergyBox

                # Update the forces
                gnh[0] = (kinEnergy2 + kinEnergyBox2 - gnd2kt) / qnh[0]

                # Update the thermostat velocities
                for n in range(nnose1):
                    aa = exp(-wdti8[j] * vnh[n+1])
                    vnh[n] = vnh[n] * aa * aa + wdti4[j] * gnh[n] * aa
                    gnh[n+1] = (qnh[n] * vnh[n] * vnh[n] - gkt) / qnh[n+1]

                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j] 
        
        # Upload the thermostat and the barostat parameters
        self.xnh = xnh
        self.vnh = vnh
        self.qnh = qnh
        self.gnh = gnh

        #self.veig = veig
        #self.veigv = veigv

        self.vtemp = vtemp
        self.box = box
        self.vbox = vbox
        self.gbox = gbox
        self.bmass = bmass

        # Compute the conserved quantity in Parrinello-Rahman-Hoover NPT dynamics.
        kepart = util.calcKinEnergy(mass, v)
        kenh = 0.
        for i in range(nnose):
            kenh += qnh[i] * vnh[i] * vnh[i]

        kenh = 0.5 * kenh
        kebox = util.calcKinEnergyBox(bmass, vbox)

        pepart = energy
        penh0 = gnd2kt * xnh[0]
        penhi = 0.
        for i in range(1, nnose):
            penhi += xnh[i]

        penhi = gkt * penhi
        penh = penh0 + penhi
        # V = det(box)
        vol = lapy.matDet(box)
        pebox = pext * vol 

        hprh = kepart + kenh + kebox + pepart + penh + pebox

        count = self.count
        count += 1
        if (count % 2 == 0.):
            out = open('hprh.dat', 'a')
            out.write(str(count/2)+'  '+str(hprh)+'\n')
            out.close()
        self.count = count

        return v

