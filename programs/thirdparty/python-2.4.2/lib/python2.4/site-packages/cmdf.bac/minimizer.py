#!usr/bin/env python
#########################################################################################################
# minimizer.py   : minimization drivers include Conjugate Gradient and Simulated Annealing methods.     # 
#                                                                                                       # 
# ConjugateGradient: Conjugate gradient (CG) method (FLETCHER-REEVES) for energy minimization.          # 
# This is a modified python version of WAG's CG subroutine in Lingraph (and MEE). The program switchs   # 
# to Steppest Descent (SD) method when CG does not work well. This code does not include the            #
# optimization of fixed (rigid) molecule.                                                               #
#                                                                                                       # 
# SimulatedAnnealing: Simulated annealing minimization via MD, including different cooling schedules:   # 
#                     Linear, Exponent, and Sigmoid.                                                    # 
#                                                                                                       # 
# Created on 01/19/06, last revision on 04/13/06. yi                                                    #
#                                                                                                       # 
#########################################################################################################

import modMulti
from utility import *
from integrator import * 
from distribution import *
from mdEngine import *
from thermostat import *
from control import *          

class Minimizer:

    def __init__(self, numSteps, threshold, freqOutput):
        self.numSteps = numSteps
        self.threshold = threshold
        self.freqOutput = freqOutput

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        return

class ConjugateGradientMEE(Minimizer):

    def __init__(self, numSteps=100, threshold=1.0e-2, freqOutput=10):
        Minimizer.__init__(self, numSteps, threshold, freqOutput)
        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        #molecule = system.getMolecule(0)
        #numAtoms = molecule.numAtoms()

        #forceEngine.setupEnergyExpression(molecule)
        #forceEngine.getEnergy()
        #forceEngine.uploadCoords(molecule)
        #forceEngine.calcEnergyForce()
        #forceEngine.downloadEnergyForce(molecule)
        forceEngine.minimize(self.numSteps, self.thershold)

        #import MEE

        #MEE.cmdf_mee_init(numAtoms)
        #MEE.cmdf_mee_current_energy()
        #MEE.cmdf_mee_set_minimization_parameters(self.numSteps, self.threshold)
        #MEE.cmdf_mee_minimize_cg()

        return

class ConjugateGradient(Minimizer):

    def __init__(self, numSteps=100, threshold=1.0e-2, freqOutput=10):
        Minimizer.__init__(self, numSteps, threshold, freqOutput)
        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        import datetime
        import random
        from math import sqrt
        from control import Control
        from utility import Utility
        UTI = Utility()

        numSteps = self.numSteps
        threshold = self.threshold
        outFreq = self.freqOutput
    
        molecule = system.getMolecule(0)
        ### Here numatoms should be movable atoms if fixed atoms exist.
        numatoms = molecule.numAtoms()
        molName = molecule.getName()
    
    #     PathXYZ HAS CURRENT CG PATH, PathXYZ[3*numatoms] 
    #     NEWX IS X FOR CURRENT PTHSTP, THIS IS UPDATED INTO X AT END OF
    #       CURRENT PTHNUM
    #
    #     DOLDX IS X COMP OF GRADDIF VECTOR = GRAD(N)-GRAD(N-1) WHERE N
    #       REFERS TO THE FIRST GRADIENT ALONG A PATH
    #
    #     IF STEEPDSSAV = True then always does steepest descents
    #       otherwise, does conjugate gradients (but does sd step when thing
    #       go badly
    
    #yi Maximal gradients beyond which one just does simple displacement rather than CG or SD.
        MAXGRD = 1.0e16
        MAXDERIV = 1.0e16 
    # PTHNUM is number of CG pathways (iterations)
    # PTHSTP is number of energy steps for current CG pathways
    # PTHSTPMX is maximum number of energy steps for one pathway
        STEPDEF = 0.02
        PTHSTPMX = 30  #yi Original is 20.
    
    # use standard multiplier for bracketing
        GOLD = 1.618034
    
    #***********************
    #*** INITIALIZATION
    #**********************
        STPMIN = 0.00001
        STPMAX = 1.0e6  # yi 
        ISTART = 1
        ISTOP = numSteps
        TOLGRD = threshold  
        STEEPDSSAV = False # Logical variable to control whether next step is cg (False) or sd (True).
    
        SQRTMOV3 = sqrt(numatoms * 3)
    
    # FOR OUTPUT, NEED HERE IN CASE NOT CALL TOTFRC
        TSTRS=0.0
    
    #***********************
    #*** START CALCULATIONS
    #***********************
    #     SAVE COORDINATES FOR INITIAL GEOMETRY
    #
    #     INITIAL GEOM WILL REMAIN IN X... CURRENT GEOM WILL BE IN NEWX...
    #@    WAG WOULD LIKE TO CHANGE THIS SO THAT REF GEOM IS OLDX AND X IS
    #       ALWAYS THE CURRENT GEOM (DYN IS DONE THIS WAY)
    #@v250 note that minmiz already use x,y,z as current variables
    #     MOVE ALL ATOMS SINCE USE NEWX... FOR CALC ENERGY
    #     IF KEPT OLDX, THEN WOULD ONLY NEED TO KEEP NMOVATM SET
    
        NEWX= [0.]; NEWY= [0.]; NEWZ= [0.]
        curX= [0.]; curY= [0.]; curZ= [0.]
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            NEWX.append(atom.getX())
            NEWY.append(atom.getY())
            NEWZ.append(atom.getZ())
    
            curX.append(atom.getX())
            curY.append(atom.getY())
            curZ.append(atom.getZ())
    #
    #     START OUTPUT FOR MINIMIZATION
    #
        CGoutput = open(molName+'.min', 'a')
    
        if (STEEPDSSAV):
    #yi    if (miniFlag == 'SD'):
            CGoutput.write("%22s<<< CMDF minimization with Steepest Descents method >>>\n" % (' '))
        else:
    #yi    elif(miniFlag == 'CG'):
            CGoutput.write("%22s<<< CMDF minimization with Conjugate Gradient method >>>\n" % (' '))
    
    #
    #     CONVERGENCE CRITERIA:
    #
    #           CALCULATION IS CONVERGED IF GRDRMS.LE.TOLGRD, WHERE GRDRMS
    #           IS THE SQUARE ROOT OF THE AVERAGE FORCE SQUARED PER DEGREE
    #           OF FREEDOM
    #           REASONING IN CHOOSING TOLGRD:
    #           DELTX=RCURV*FORCE WHERE RCURV=1/(FORCE CONSTANT)
    #           A LOW FORCE CONSTANT IS 100 KCAL/A, HENCE RCURV=.01
    #           THUS A FORCE OF .1 WOULD CHANGE X BY LESS THAN .001
    #           THIS WOULD LEAD TO GRDRMS=0.1*SQRT(3*NATOM)
    #           RECOMMENDED TOLGRD=.1  FOR STRUCTURE OPTIMIZATION
    #           .01 FOR VIBRATIONAL CALCULATIONS
    #
    #     INITIALIZE VARIABLES FOR A SEQUENCE OF CG
    #
    #           RCURV IS RECIPRICAL CURVATURE, X(N+1)=X(N)-RCURV*ENRGRAD
    #
    #           CONJGRAD PATH: PATH(N+1) = -ENRGRAD(AT MIN OF PATH N) +
    #           BETA*PATH(N)
    #
    # First path will be SD not CG
        BETA = 0.
        CNTCG = 0
        STEPAV = 0.
        GRADAV = 0.
    # AFTER THE 1ST ITER, ABM IS THE FULL STEP ALONG LAST PATH
        ABM = STEPDEF
    #
    #     ON SUBSEQUENT PATHS, THE ENERGY AND GRADIENT WILL BE
    #           AVAILABLE FROM THE LAST CALC OF PREVIOUS PATH
    #
    
    # Cal. energy and rms force for molecule
        if Control.printLevel > 1:
            forceStart = datetime.datetime.now()
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)
        if Control.printLevel > 1:
            forceEnd = datetime.datetime.now()
            logFile = open(molName+'.log', 'a')
            logFile.write('CG force timing:\n'); logFile.flush()
            UTI.timer(molName, forceStart, forceEnd)
    
        GRDRMS = UTI.calcRMSforce(molecule)
    #     ESTART USED TO CALC EAVE AT END
        ESTART = molecule.getPotentialEnergy()
    
        PTHNUM = 0 
        PTHSTP = 2  #yi
        DIFE = 0.
        CORDRMS = 0.
    
    #   print "%s %12.6f, %12.6f \n" % ("Initial ESTART, GRDRMS = ", ESTART, GRDRMS)
    
    # Output information: Number of iteration(PTHNUM), number of energy calls(PTHSTP), 
    # potential energy, energy difference between last two steps, RMS force, 
    # and RMS coordinate between last two steps. 
        CGoutput.write("N_Iter.  N_Estep          Pot_E(eV)            Diff_E(eV)           RMS_Grad.            RMS_Coord.\n")  
    
        Ecur = ESTART
    
        def writeCGoutput():
            CGoutput.write("%6i  %6i  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                (PTHNUM-1, PTHSTP-1, Ecur, DIFE, GRDRMS, CORDRMS))
            return
    
        writeCGoutput()
    
        PTHNUM = ISTART 
    
        if (GRDRMS <= TOLGRD): 
            STOPMIN = True
            GRADAV = GRDRMS 
            ABM = 0.
            # go to 21, finish CG and store convergence info.
            NSTP = PTHNUM - ISTART + 1
            if (NSTP > 1):
                STEPAV = STEPAV/NSTP 
                GRADAV = GRADAV/NSTP 
            ISTOP = PTHNUM 
            CGoutput.write("%55s %12.6f %12.6f\n" % ("Minimization is converged (0) ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS))
    
            return 
        
    #yi Do simple displacement if force is too large.
        while (GRDRMS > MAXGRD):
            print "%s %12.6f \n" % ("Do simple displacement because force is too large. \
                                    GRDRMS = ", GRDRMS)
            for i in range(1, numatoms+1):
                atom = molecule.getAtomWithNumber(i)
                if atom.isMovable() != 1:
                    continue
                
                xnew = atom.getX() 
                ynew = atom.getY() 
                znew = atom.getZ() 
    
                fx = atom.getForceX() 
                fy = atom.getForceY() 
                fz = atom.getForceZ() 
    
                if (abs(fx) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fx >= 0.): 
                        xnew += displace 
                    else:
                        xnew -= displace 
                if (abs(fy) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fy >= 0.): 
                        ynew += displace 
                    else:
                        ynew -= displace 
                if (abs(fz) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fz >= 0.): 
                        znew += displace 
                    else:
                        znew -= displace 
    
                atom.setPosition(xnew, ynew, znew) #Update coordinate
    
            # Cal. energy and rms force for molecule
            if Control.printLevel > 1:
                forceStart = datetime.datetime.now()
            forceEngine.downloadCoords(molecule)
            forceEngine.calcEnergyForce()
            forceEngine.uploadEnergyForce(molecule)
            if Control.printLevel > 1:
                forceEnd = datetime.datetime.now()
                logFile = open(molName+'.log', 'a')
                logFile.write('CG force timing:\n'); logFile.flush()
                UTI.timer(molName, forceStart, forceEnd)
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
    #yi  The above loop continues until force is not too large compared to MAXDERIV.
    
        ESTART = molecule.getPotentialEnergy()
    
    #Check convergence again.
        if (GRDRMS <= TOLGRD): 
            STOPMIN = True
            GRADAV = GRDRMS 
            ABM = 0.
            # go to 21, finish CG and store convergence info.
            NSTP = PTHNUM - ISTART + 1
            if (NSTP > 1):
                STEPAV = STEPAV/NSTP 
                GRADAV = GRADAV/NSTP 
            ISTOP = PTHNUM 
            CGoutput.write("%50s %12.6f \n" % ("Minimization is converged (1) ==> GRDRMS = ", GRDRMS))
    
            return 
    
    #******************************
    #    ALL CG or SD PATHS START HERE
    #******************************
    #*** INITIALIZE NEW OPTIMIZATION PATH
        pathXYZ = [0.] * (3 * numatoms + 1)
    
        NCGCYC = 10 # yi added 
        GRDRMS0 = GRDRMS # yi added 
    
        cm0 = UTI.calcPositionCM(molecule)  # get the original CM of the molecule
    
        STOPMIN = False
        FRSTSTP = True
    
        while (PTHNUM <= ISTOP and not STOPMIN):  #80
    
            if ((PTHNUM-1) % outFreq == 0): writeCGoutput()  #yi
    
            PTHSTP = 0  #yi
    
    #     SHIFT CM BACK TO REFERENCE VALUE (CALC BY calCM1)
            UTI.translateCM2(molecule, NEWX, NEWY, NEWZ, cm0) #Translate the system NEWX to original refernce cm0
            # translateCM1(molecule, cm0) #Translate the molecule to original refernce cm0
    
    #     THE COORD FOR THIS INITIAL POINT ARE KEPT IN X..
    #******************************
    #     CACULATE PATH
    #********************************
    #     HAVE ALREADY CALCULATED E,DX..,GRDRMS,DF FOR CURRENT POINT
    #           (0) GET NEW DIRECTION (P) AND DERIVATIVE ALONG THIS
    #           DIRECTION (GRDPRJ0)
    #
    #     NCGCYC=10 IS THE NUMBER OF STEPS BEFORE THE P ARRAY IS DISCARDED A
    #         THE CG IS REINITIALIZED
    #
            PTHNRM = 0.
            GRDPRJ0 = 0.
    
            if (CNTCG % NCGCYC == 0):
    #        if (miniFlag == 'SD'):  #yi
    #
    #    Steepest Descent Path
    #
    #            print "SD path, PTHNUM=", PTHNUM
                STEEPDS = True
                CNTCG = 0
                BETA = 0.
                PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0)
    
            else:
    #        elif (miniFlag == 'CG'): #yi 
    #       CONJ GRAD PATH
    #
    #       ESTIMATE BETA FOR NEXT ITERATION
    #
    #       PATH(N)=-GRAD(N) + BETA(N-1)*PATH(N-1)
    #       X(N+1)-X(N)=LAMBDA*PATH(N) WHERE LAMBDA LEADS TO A MINIMUM
    #         N=1: START WITH X(1), CALC GRAD(1), THEN PATH(1) USING
    #            BETA(0)=0 THEN CALC X(2)
    #         N=2: CALC GRAD(2), THEN BETA(1), THEN PATH(2), THEN LAMBDA,
    #            THEN X(3)...
    #
    #       FLETCHER-REEVES:
    #           BETA(N-1)=GRAD(N)**2/GRAD(N-1)**2
    #
    #       WOLFE:           {GRAD(N) dot (GRAD(N)-GRAD(N-1))}
    #           BETA(N-1)=   ---------------------------------
    #                        {PATH(N-1) dot (GRAD(N)-GRAD(N-1))}
    #
    #         NOT RESET GRDRMS0 UNTIL BELOW
    
    # Fletcher-Reeves CG method
                BETA = GRDRMS * GRDRMS/(GRDRMS0 * GRDRMS0)
    
                if (abs(BETA) > 10.): 
                    # CG beta is too large. Switch back to SD.
                    print "CG BETA is too large==> do SD path. PTHNUM = %i" % (PTHNUM)
                    STEEPDS = True
                    CNTCG = 0
                    BETA = 0.
                    PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # SD path
                else:
    #                print "CG path, PTHNUM = %i" % (PTHNUM)
                    PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # CG path
    
                    if (GRDPRJO > (-0.1*TOLGRD)):
                        # First point has too small slope along CG path, will do SD instead.
                        print "First point has too small slope along CG path==> do SD path. PTHNUM = %i" \
                            % (PTHNUM)
                        STEEPDS = True
                        CNTCG = 0
                        BETA = 0.
                        PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # SD path
    
    #     ENERGY AT START OF PATH
            PTHSTP = 1
            ENR0 = molecule.getPotentialEnergy()
            GRDRMS0 = GRDRMS
    #
    # Start linear search for optimal step along new path
    #
    #     SUBSEQUENT ITERATIONS, DLTSTP IS FROM PREVIOUS ITERATION
    #****************************
    #     INITIALIZE POINT A
    #****************************
            ENRA = ENR0
            GRDRMSA = GRDRMS0
            GRDPRJA = GRDPRJ0
            DSTA = 0.
    #   DSTB=ABM/GOLD IS GOOD ESTIMATE OF NEXT MIN, SET DSTB=ABM SO THAT
    #   IS BRACKETED
            DSTB = ABM
    
    #*********************************
    #     SECOND POINT OF PATH, B
    #*******************************
            if (FRSTSTP):
                if (DSTB > STPMAX): #Step size is too large, reset to STPMAX
                    DSTB = STPMAX
                FRSTSTP = False
    
            if (DSTB < STPMIN):  #Step size is too small, reset to STPMIN
                DSTB = STPMIN
    
    #**********************************
    #     REINTRANT PLACE FOR SUBSEQUENT BRACKETING STEPS
    #**********************************
    #     CALCULATE E AND GRDPRJ AT NEW POINT DSTB ON PATH
    
            bracketMin = False
            while not bracketMin:  # 100
    
                BMA = DSTB-DSTA
    
    #     TEST FOR SIZE OF STEP
                if (BMA < STPMIN):
    #
    #        STEP TOO SMALL, NOT BOTHER WITH POINT B
    #
    #        IF RCURV=.001 THEN dE=(dX)**2/RCURV=1.0E-9
    #              (IN ROUND OFF REGION)
    #              AND dYP=dX/RCURV=1.0E-3 WHICH SHOULD BE CONVERGED
    #              THUS STOP NOW TO AVOID POSSIBLE ROUND OFF PROBLEMS IN
    #              PREDICTING NEW MIN BASED ON A AND DSTB
    #              SINCE POINT B WILL NOT BE CALCULATED, STORE POINT A
    #              INFO IN B
                    ENRB = ENRA
                    DSTB = DSTA
                    ABM = DSTB
                    GRDPRJB = GRDPRJA
                    GRDRMS = GRDRMSA
                    GRDPRJM = GRDPRJB
                    if (DSTA != 0.):
                        ENRA = ENR0
                        DSTA = 0.  
                        GRDRMSA = GRDRMS0
                        GRDPRJA = GRDPRJ0
                    # Go to 198, then 200 in original code
                    # Here we don't follow original flow which is to do SD from the beginning again (80). 
                    # Instead, we exit simply because step is small (< STPMIN). If this is a concern, 
                    # we can either reduce STPMIN or restart minimization using the last geometry.
                    BETA = 0.
                    CNTCG = 0 
                    #     TAKE FINAL POINT CALCULATED IN CG PATH (STORED IN NEWX)
                    #           AND MOVE TO curX
                    GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                    CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    print "%s %i, %12.6f \n" % ("Exit because step BMA is too small \
                        ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS)
    
                    return
    
    #*****************************************************************
    #     NOW DO POINT B, WANT A AND B TO BRACKET THE MINIMUM
    #********************************************************************
                BTERM= DSTB / PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, BTERM) # NEWX(I) are updated
                ELAST = molecule.getPotentialEnergy()
                PTHSTP = PTHSTP + 1
    
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                #Cal. RMS force and coordinate 
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)  #yi
    
                Ecur = molecule.getPotentialEnergy()
                ECHNG = ELAST - Ecur 
    
                # Check for convergence
                if (GRDRMS <= TOLGRD):
                    STOPMIN = True
                    GRDPRJM = -GRDRMS * SQRTMOV3
                    ABM = DSTB
                    # MUST NOW MOVE NEWX INTO X
                    # GO TO 200
                    #
                    #     TAKE FINAL POINT CALCULATED IN CG PATH (STORED IN NEWX)
                    #           AND MOVE TO curX
                    #
                    #Cal. energy difference
                    EDIF = ENR0 - Ecur  #yi
                    DIFE = -EDIF
    
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    CGoutput.write("%s %i, %12.6f \n" % \
                       ("Minimization is converged (2) ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS)) 
    
                    PTHNUM = PTHNUM + 1  #yi
    
                    writeCGoutput() #yi
    
                    return
    
                ENRB = Ecur
                GRDRMSB = GRDRMS
                # Find slope at B
                GRDPRJB = 0. #yi 
                GRDPRJB = self.gradientProjectCG(molecule, GRDPRJB, pathXYZ, PTHNRM)
                
                #
                # DETERMINE WHETHER HAVE BRACKETED MIN
                #
                if (GRDPRJB > 0.):
                    #
                    # HAVE BRACKETED MINIMUM, MIN IS PREDICTED AT ABM
                    # GO TO INTERPOLATION SECTION AT 130 TO GET FINAL VALUE
                    #
                    RCURV= BMA/(GRDPRJB-GRDPRJA)
                    ABM= DSTA - GRDPRJA * RCURV
                    #go to 130
                    bracketMin = True #Jump out of while loop
                    break
                else:
                    #
                    # DID NOT BRACKET MINIMUM, BOTH SLOPES NEGATIVE
                    #
                    NXTSTEP=GOLD*BMA
                    ABM=DSTB+NXTSTEP
                    # OLD B BECOMES NEW A
                    ENRA=ENRB
                    GRDPRJA=GRDPRJB
                    GRDRMSA=GRDRMSB
                    DSTA=DSTB
                    DSTB=ABM
                    if (PTHSTP <= PTHSTPMX):
                        #go to 100
                        bracketMin = False
                        continue
                    else:
                        # DID NOT CONVERGE, START NEW SD PATH
                        ABM=DSTB
                        # GO TO 197
                        ABMTEMP = ABM/PTHNRM
                        self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                        self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                        if Control.printLevel > 1:
                            forceStart = datetime.datetime.now()
                        forceEngine.downloadCoords(molecule)
                        forceEngine.calcEnergyForce()
                        forceEngine.uploadEnergyForce(molecule)
                        if Control.printLevel > 1:
                            forceEnd = datetime.datetime.now()
                            logFile = open(molName+'.log', 'a')
                            logFile.write('CG force timing:\n'); logFile.flush()
                            UTI.timer(molName, forceStart, forceEnd)

    
                        GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                        CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                        #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
                        #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                        GRDPRJM = 0. #yi
                        GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
                        BETA = 0.
                        CNTCG = -1
                        for i in range(1, numatoms+1):
                            curX[i] = NEWX[i]
                            curY[i] = NEWY[i]
                            curZ[i] = NEWZ[i]
                        CNTCG = CNTCG + 1
                        Ecur = molecule.getPotentialEnergy()
                        EDIF = ENR0 - Ecur 
                        DIFE = -EDIF
                        STEPAV = STEPAV + ABM
                        GRADAV = GRADAV + GRDRMS
                        if (STEEPDSSAV):
                            STEEPDS = True
                            CNTCG = 0     
                        else:
                            STEEPDS = False
                        #Exit from here. If it is not good, start it over again by using final geometry.
                        GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                        print "%s %i, %i, %12.6f \n" % \
                          ("Exit because PTHSTP is too large, please restart from SD ==> PTHNUM, PTHSTP, GRDRMS = ", PTHNUM, PTHSTP, GRDRMS) 
    
                        return
    
    # End of 2nd while loop (bracketMin)
    #
    #**************************************
    #     HAVE BRACKETED MINIMUM,
    #           INTERPOLATE TO FIND A BETTER MINIMUM ALONG CURRENT PATH
    #*************************************
            if (PTHSTP > PTHSTPMX): #GO TO 197
                ABMTEMP = ABM/PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
                #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                GRDPRJM = 0.  #yi
                GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
                BETA = 0.
                CNTCG = -1
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                Ecur = molecule.getPotentialEnergy()
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
    
                continue  #go to next CG step 
    
            ABMTEMP=ABM/PTHNRM
            self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
            ELAST = molecule.getPotentialEnergy()
            PTHSTP = PTHSTP + 1
    
            self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
            if Control.printLevel > 1:
                forceStart = datetime.datetime.now()
            forceEngine.downloadCoords(molecule)
            forceEngine.calcEnergyForce()
            forceEngine.uploadEnergyForce(molecule)
            if Control.printLevel > 1:
                forceEnd = datetime.datetime.now()
                logFile = open(molName+'.log', 'a')
                logFile.write('CG force timing:\n'); logFile.flush()
                UTI.timer(molName, forceStart, forceEnd)
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
            CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
            Ecur = molecule.getPotentialEnergy()
            ECHNG = ELAST - Ecur 
            ENRM = Ecur 
    
            if (GRDRMS <= TOLGRD): 
                STOPMIN = True 
                GRDPRJM = -GRDRMS*SQRTMOV3
                # GO TO 200
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                continue
    #
    #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
            GRDPRJM = 0.
            GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
            RCURV=ABM/(GRDPRJM-GRDPRJ0)
    
            if (PTHSTP > PTHSTPMX): #GO TO 198
                BETA = 0.
                CNTCG = -1
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False

                continue #go to next CG step
    
    #     CHECK TO SEE IF ENERGY HAS INCREASED
    #        EABMIN = min(ENRA,ENRB)+MINDLTE
    #        if ( ENRM > ENRA+MINDLTE and ENRM > ENRB+MINDLTE and (not LASYMSTR)):
            if (ENRM > ENRA and ENRM > ENRB):  #yi
                print "Problem: in line search the middle point lies above \
    the two bracketing points, will do SD next." 
                #go to 198
                BETA = 0.
                CNTCG = -1
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                EDIF =ENR0- Ecur
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
    #yi            if (not STOPMIN and (PTHNUM < ISTOP) and (PTHNUM > 1) and (PTHNUM % NCYCLE == 1)):
                if (not STOPMIN and (PTHNUM < ISTOP) and (PTHNUM > 1)):
                    PTHNUM = PTHNUM + 1
                    STEEPDS = True
                    CNTCG = 0
                    # DO ENERGY OVER BECAUSE MOLECULES MAY HAVE MOVED 
                    if Control.printLevel > 1:
                        forceStart = datetime.datetime.now()
                    forceEngine.downloadCoords(molecule)
                    forceEngine.calcEnergyForce()
                    forceEngine.uploadEnergyForce(molecule)
                    if Control.printLevel > 1:
                        forceEnd = datetime.datetime.now()
                        logFile = open(molName+'.log', 'a')
                        logFile.write('CG force timing:\n'); logFile.flush()
                        UTI.timer(molName, forceStart, forceEnd)

                    continue #Jump to the top of the 1st while loop to do SD again 
            else:
    
    #       ENERGY AT ENRM IS LOWER THAN BOTH ENDPOINTS
    #*******************************************************
    #       DO FINAL CUBIC FIT USING SLOPES AT 3 POINTS
    #         (DSTA,ABM,DSTB)
    #         RETURN OPT DISTANCE AS DSTNEW AND NEW RCURV
    #******************************************************
                DSTNEW = 0.  #yi
                RCURV = 0.   #yi
                DSTNEW,RCURV = self.CUBIC03(DSTA,GRDPRJA,ABM,GRDPRJM,DSTB,GRDPRJB,DSTNEW,RCURV)
    
                OLDABM=ABM
                OLDGRDPRJM=GRDPRJM
                ABM=DSTNEW
    #       DO FINAL CALCULATION AT THIS ENERGY
                SECONDTRY=0
                ABMTEMP=ABM/PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                PTHSTP = PTHSTP + 1
    
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
                ENRM = molecule.getPotentialEnergy()
                Ecur = ENRM         #yi
                EDIF = ENR0 - Ecur  #yi
                DIFE = -EDIF        #yi
    
    #       CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                GRDPRJM = 0.
                GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
     
                if (GRDRMS <= TOLGRD): 
                    STOPMIN = True  
                    #GO TO 200
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    CNTCG = CNTCG + 1
                    EDIF = ENRO - molecule.getPotentialEnergy()
                    DIFE = -EDIF
                    CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                    STEPAV = STEPAV + ABM
                    GRADAV = GRADAV + GRDRMS
                    if (STEEPDSSAV):
                        STEEPDS = True
                        CNTCG = 0     
                    else:
                        STEEPDS = False

                    continue
    
    #
    #EXTRA ITERATION SECTION
    #       CHECK SLOPE OF FINAL POINT, IF NOT GOOD ENOUGH DO ONE MORE
    #         ITERATION
    #            ERR=GRDPRJM-TOLGRD
    #       IF GRDPRJM NOT NEARLY ZERO, THEN TRY AGAIN
    #       FIRST TIME SECONDTRY=0, THEN 1, THEN 2. STOP IF 2
    #            if (SECONDTRY >= 2): GO TO 197
    #       GENERALLY TOLGRD=.1 (.2 TO .01), I FIND THAT GRDPRJM OFTEN
    #           LARGER
    #            if (GRDPRJM<TOLGRD): GO TO 199
    #       PICK FINAL POINT BASED ON OLDABM AND ABM WITH GRADIENTS OF
    #       OLDGRDPRJM AND GRDPRJM
    #            if (GRDPRJM == OLDGRDPRJM): GO TO 199
    #                RCURV=(ABM-OLDABM)/(GRDPRJM-OLDGRDPRJM)
    #            if (RCURV <= 0.0): GO TO 199
    #                NXTSTEP=-GRDPRJM*RCURV
    #            if (abs(NXTSTEP)>BMA): GO TO 199
    #                ABM=ABM+NXTSTEP
    #                SECONDTRY=SECONDTRY+1
    #
    
    #**************************************
    #     END OF CONJUGATE GRADIENT SEQUENCE
    #           WILL START NEW PATH AT POINT WITH DST=ABM ON OLD PATH
    #*******************************************
    #     SPECIAL TERMINATION OF PATH OPTIMIZATION, DO STEEPDS NEXT
    #           ITER
    #
    #     NEED E,DX... AT POINT ABM
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
    
            #Cal. RMS coordinate
            CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
    #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
    #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
            GRDPRJM = 0.
            GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
    #
    #     ALREADY HAVE E,DX AT POINT ABM
    #        BETA=0.0
    #        CNTCG=-1
            #GO TO 200
    
    #***************************************
    #   NORMAL TERMINATION OF PATH OPTIMIZATION
    #***************************************
            for i in range(1, numatoms+1):
                curX[i] = NEWX[i]
                curY[i] = NEWY[i]
                curZ[i] = NEWZ[i]
    #***************************************
    #     FINISHED CG PATH
    #*****************************************
            CNTCG=CNTCG+1
            EDIF =  ENR0 - molecule.getPotentialEnergy()
            DIFE = -EDIF  #for print
    
            STEPAV = STEPAV + ABM
            GRADAV = GRADAV + GRDRMS
    #yi        if(not lquenc): 
    #yi            EPERC[PTHNUM] = molecule.getPotentialEnergy()
    #
    #     RESET STEEPDS IN CASE HAS BEEN CHANGED
            if (STEEPDSSAV):
                STEEPDS = True 
                CNTCG = 0
            else:
                STEEPDS = False  
    
    #*******************************************
    #     HAVE NOW FINISHED CURRENT PATH
    #     DECIDE WHETHER TO DO NEW ONE
    #******************************************
    #     CHECK FOR ABORT IN INTERACTIVE MODE ON KEY 12
    #
    #        if( not BTCH ):
    #            CALL CABORT(ABORT)
    #            ABORT = False
    #            if( ABORT ):
    #                ISTOP = PTHNUM
    #                print ' Minimization is aborted (CONJGR)\n'
                    #GO TO 21
    #
    #     CHECK CONVERGENCE AND NUMBER OF ITERATIONS
    #
            if (STOPMIN): 
                CGoutput.write("<<< Minimization is converged  >>> Final RMS force: %20.10e\n" % (GRDRMS)) 
            else:
    #    if ( PTHNUM < ISTOP): 
    #         MORE ITERATIONS TO DO
                PTHNUM=PTHNUM+1
    #         FOR LONG RUNS MAY NEED TO UPDATE NBHBLST (AND CHECK FOR
    #           MOLECULES WITHIN UNIT CELL
    #yi          IF (.NOT.CELOPT) THEN
    #           FOR CELOPT, CELLOPT CONTROLS NBHBLST CALL
    #           NOT DO IF FIRST ITERATION OR NEARLY THE LAST
    #           KEY ON .EQ.1 SO THAT DO NCYCLE BEFORE NEW ONE
    #yi            if (PTHNUM>1 and PTHNUM % NCYCLE == 1): 
    #            if (PTHNUM > 1): #yi 
    #                STEEPDS = True 
    #                CNTCG=0
    #             REINITIALIZE CM
    #             DO ENERGY OVER BECAUSE MOLECULES MAY HAVE MOVED AND
    #               NB LIMITS MAY HAVE CHANGED
    #            forceEngine.calcEnergyForce(molecule)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                Ecur = molecule.getPotentialEnergy()
    #              CALL TOTFRC(GRDRMS,CELLRMS)
    
    #          GO TO 80
    #End of while loop at 80
    #    else:
    #         FINISHED ITERATIONS
    
        writeCGoutput()
    
        CGoutput.write("<<< Minimization not converged >>> Final RMS force: %20.10e\n" % (GRDRMS)) 
    
    #**********************************************
    #     FINISHED CG, STORE CONVERGENCE INFO
    #*********************************************
    #     THESE QUANTITIES ARE USED FOR CONTROLLING BATCH OPTIMIZATIONS
    #
        NSTP = PTHNUM - ISTART + 1
        if ( NSTP >  1 ):
            STEPAV = STEPAV/NSTP
            GRADAV = GRADAV/NSTP
        CONVRG = 0
    #yi    if( EDIF <= TOLENR ): CONVRG = 1 + CONVRG
        if( ABM <= 1.0E-4 ):  CONVRG = 2 + CONVRG
        if(GRDRMS <= TOLGRD): CONVRG = 4 + CONVRG
    #
    #     CHANGE SIGN OF EDIF FOR PRINT OUT
    #
        DIFE=-EDIF
    
    #*********************
    #     PRINT RESULTS FOR INFLVL=0 OPTION (IF NOT CELOPT)
    #*********************
    #    if (not CELOPT):
    #    finaliter=1
    #    newcnte=cnte-oldcnte
    #    call WRTMINITR(inflvl,pthnum,grdrms,cellrms,abm,dstcel, \
    #         newcnte,finaliter)
    #    oldcnte=cnte
    #*************************
    #     FINAL RESTORING
    #**************************
    #12190 CONTINUE
    
        ISTOP = PTHNUM
    
        return
    
    #
    # The following functions are called in above minimizerConjugateGradient function.
    #
    
    def CUBIC03(self,DSTA,GRDA,DSTM,GRDM,DSTB,GRDB,DSTNEW,RCURV):
    # 22/SEP/87 WAG CUBIC FIT USING GRADIENT AT 3 POINTS
    #     RETURNS NEW POINT DSTNEW AND RCURV=1/2ND DERIV AT DSTNEW
    #     THIS ONLY CALLED WHEN ENERGY IS BRACKETED
    #
    #     DSTNEW and RCURV are output at new point. Others are input of three points.
    #
        from math import sqrt
    
        DLTM=DSTM-DSTA
        if (abs(DLTM) < 1.e-6): #GO TO 101  !POINTS 1 AND 2 THE SAME
            # NO SOLUTION, PROGRAM SHOULD NOT GET HERE
            print "SERIOUS PROBLEM IN CUBIC03, WILL USE QUADRATIC."
            # USE POINTS 2 AND 3
            RCURV=(DSTB-DSTM)/(GRDB-GRDM)
            if (RCURV<=0.0): 
                print "NEGATIVE CURVATURE IN CUBIC03, RCURV = %12.6f \n" % (RCURV)
                RCURV=-RCURV
                # SHOULD USE RCURVDEF/100
                if (RCURV<0.001): RCURV=0.001
                DSTNEW=DSTA+3.0*(DSTB-DSTA)
            else:
                DSTNEW=DSTA-GRDA*RCURV
            return (DSTNEW, RCURV)
    
        if (abs(DSTB-DSTM)<1.0e-6):     
    #       POINTS 2 AND 3 THE SAME
            RCURV=(DSTB-DSTA)/(GRDB-GRDA)
            if (RCURV<=0.0): 
                RCURV=-RCURV
    #         SHOULD USE RCURVDEF/100
                if (RCURV<0.001): RCURV=0.001
                DSTNEW=DSTA+3.0*(DSTB-DSTA)
            else:
                DSTNEW=DSTA-GRDA*RCURV
            return (DSTNEW, RCURV)    
    
        DLTB=DSTB-DSTA
        EPDLTM=GRDM-GRDA
        EPDLTB=GRDB-GRDA
        EPM=EPDLTM/DLTM
        EPB=EPDLTB/DLTB
        EPPPA=2.0*(EPB-EPM)/(DLTB-DLTM)
        EPPA=(EPM*DLTB-EPB*DLTM)/(DLTB-DLTM)
        RADICAL=EPPA*EPPA-2.0*EPPPA*GRDA
        if (RADICAL>0.0):     
    #       REAL MINIMUM
            RADICAL=sqrt(RADICAL)
            if (EPPPA==0.0): 
    #         THIS ACTUALLY HAPPENED FOR A NON TRIVIAL CASE
                DSTNEW=DSTM
            else:
                DSTNEW=DSTA+(RADICAL-EPPA)/EPPPA
            RCURV=1./RADICAL
            return (DSTNEW, RCURV)
    
        return (DSTNEW, RCURV)
    
    def gradientProjectCG(self, molecule, GRDPRJ, pathXYZ, PTHNRM):
    # Calc slope along p
    # Called by CG
        IND = 0
        NUMBK = 3
        GRD= {} 
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            #yi Note that CMDF force has opposite direction from MEE gradient, so added negative sign here. 
    
            GRD[1] = -atom.getForceX()
            GRD[2] = -atom.getForceY()
            GRD[3] = -atom.getForceZ()
            for k in range(1, NUMBK+1):
                GRDPRJ += pathXYZ[k+IND] * GRD[k]
            IND += NUMBK
        GRDPRJ = GRDPRJ / PTHNRM
    
        return (GRDPRJ) 
    
    def moveAtomCG(self, molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, tm):
    # This function moves atoms to new positions along p direction during minimization 
    # NEWX(I) = X(I) + TM * PXYZ(I)
        NUMBK = 3
        IND = 0
        numatoms = molecule.numAtoms()
    
        for i in range(1, numatoms+1):
            NEWX[i] = curX[i] + tm * pathXYZ[1+IND]
            NEWY[i] = curY[i] + tm * pathXYZ[2+IND]
            NEWZ[i] = curZ[i] + tm * pathXYZ[3+IND]
            IND += NUMBK
    
        return
    
    def setAtomXYZ(self, molecule, newx, newy, newz):
        numatoms = molecule.numAtoms()
    
        for i in range(1, numatoms+1): 
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            atom.setPosition(newx[i], newy[i], newz[i])
    
        return
    
    def newPath(self, molecule, pathXYZ, BETA, PTHNRM, GRDPRJ):
        from math import sqrt
    
        numatoms = molecule.numAtoms()
    
    # Initialize pathXYZ (NEEDED IN CASE PXYZ HAVE BECOME INDEFINITE) 
    
    #    if (BETA == 0.):
    #        IND = 3 * numatoms
    #        pathXYZ = [0.]*(IND+1)
    #
    #  Construct new path pXYZ using beta and old path
    #  P[i+1] = beta[i]*P[i] - g[i+1]
    #
        PTHNRM = 0.
        GRDPRJ = 0.
        IND = 0
    
        GRD={}
    
        NUMBK = 3
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
    #yi Note that CMDF force has opposite direction from MEE gradient. So a negative sign was added. 
    
            GRD[1] = -atom.getForceX()
            GRD[2] = -atom.getForceY()
            GRD[3] = -atom.getForceZ()
            for k in range(1, NUMBK+1):
                pathXYZ[k+IND] = BETA * pathXYZ[k+IND] - GRD[k]
                PTHNRM += pathXYZ[k+IND]**2 
                GRDPRJ += pathXYZ[k+IND]*GRD[k]
            IND += NUMBK
        PTHNRM = sqrt(PTHNRM)
        GRDPRJ = GRDPRJ/PTHNRM
    
        return (PTHNRM, GRDPRJ)

# Simulated annealing minimization via MD.
class CoolSchedule:

    def __init__(self, numSteps):
        self.numSteps = numSteps

        return            

    def initialization(self):

        return

    def run(self, iStep):

        return

class Linear(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)

        return scaleFactor

class Exponent(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        from math import exp

        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = 1. - exp(-5. * scaleFactor)

        return scaleFactor

class Sigmoid(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = self.sigmoid(5., scaleFactor) 

        return scaleFactor

    def sigmoid(self, beta, x):
    #
    # Compute a normalized sigmoidal function on the interval [0, 1];
    # The curves connect (0, 0) and (1, 1) and have a cooperativity 
    # controlled by beta: they approach a straight line as beta approaches
    # zero, and become more nonlinear as beta increase.
    #
        from math import exp

        if beta == 0.:
            sigm = x
        else:
            expmax = 1. / (exp(-beta) + 1.)
            expmin = 1. / (exp(beta) + 1.)
            expterm = 1. / (exp(beta * (2. * x - 1.)) + 1.)
            sigm = (expmax - expterm) / (expmax - expmin)

        return sigm

class SimulatedAnnealing(Minimizer):
# Simulated annealing minimization via MD.
# Avaliable cooling schedules include Linear, Exponent, and Sigmoid.

    def __init__(self, coolSchedule=Linear, integrator=LeapFrog, thermostat=BerendsenThermostat,  \
                barostat=BerendsenBarostat, gaussian=Gaussian3, initTemp=1000., finalTemp=0.,  \
                numSteps=1000, equSteps=500, timeStep=0.001, threshold=0.01, freqOutputMD=10, freqOutputTrj=10): 
        Minimizer.__init__(self, numSteps, threshold, freqOutputMD)
        self.freqOutputTrj = freqOutputTrj
        self.coolSchedule = coolSchedule
        self.integrator = integrator
        # Note that only BerendsenThermostat is used in SA.
        # Thermostat will be explictly created again in run. 
        self.thermostat = thermostat
        self.barostat = barostat
        self.gaussian = gaussian
        self.timeStep = timeStep
        self.annSteps = numSteps
        self.equSteps = equSteps 
        self.initTemp = initTemp
        self.finalTemp = finalTemp
        self.relaxSteps = 1  
        self.scaleMass = 0. 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        def outputSA(num, file):
            file.write("%6i  %5f  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                        (num, scaleFactor, potEnergy, diffEnergy, RMSforce, RMScoord))
            return

        from utility import Utility
        UTI = Utility()

        # Setup parameters.
        initTemp = self.initTemp  # Initial temperature  
        finalTemp = self.finalTemp  # Final temperature
        coolSchedule = self.coolSchedule  # Cooling schedule 
        dt = self.timeStep   # Time step in MD
        weakTau = 100. * dt  # Coupling time in Berendsen thermostat
        strongTau = 10. * dt
        equSteps = self.equSteps  # Equilibration MD Steps     
        annSteps = self.annSteps  # Annealing MD steps 
        freqOutputMD = self.freqOutput  # Output interval
        freqOutputTrj = self.freqOutputTrj  # Output interval
        relaxSteps = self.relaxSteps  # Relax steps during annealing.
        threshold = self.threshold  # RMS force convergence criterion
        scaleMass = self.scaleMass  # scale mass by a factor of 10^scaleMass
        scaleMass = 10. ** scaleMass 

        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        mass = [0.] * numAtoms
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            mass = atom.getAtomicMass()
            mass *= scaleMass
            atom.setAtomicMass(mass)

        molName = molecule.getName() 
        SAoutput = open(molName+'.min', 'a')
        MDoutput = open(molName+'.dyn', 'a')
        xyzFile = open(molName+'.trj', 'a')
        rstName = molName+'.rst'

        SAoutput.write("%25s<<< CMDF minimization with Simulated Annealing method >>>\n" % (' '))
        SAoutput.write("N_Iter.   Scale             Pot_E                Diff_E               RMS_Grad.            RMS_Coord.\n")  

        #MDoutput.write("%16s <<< CMDF Simulated Annealing via MD integration >>>\n" % (' '))
        MDoutput.write("%12s<< Equilibrium phase at initial temperature %16.7f K >>\n" % (' ', initTemp))
        MDoutput.flush()

        # Equilibration phase at initial temperature. 
        # One can choose different starting configurations via setting different equSteps.
        equilibriumThermostat = BerendsenThermostat(initTemp, dt, weakTau)
        equilibriumMD = MDEngine(self.integrator, equilibriumThermostat, self.barostat,  \
                            self.gaussian, equSteps, freqOutputMD, freqOutputTrj, initTemp)
        equilibriumMD.run(system, forceEngine)

        # Annealing phase according to the cooling schedule.
        MDoutput.write("%12s<< Annealing phase toward final temperature %16.7f K >>\n" % (' ', finalTemp))
        MDoutput.flush()
        # Note that the following instance name has no meaning. I just borrow its output method.
        equilibriumMD.outputMD(system, -1, MDoutput)
        equilibriumMD.outputMD(system, 0, MDoutput)

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            atom.setOldPosition(0., 0., 0.)
        molecule.setOldPotentialEnergy(0.)         
        convergence = False
        # Create cooling schedule.
        coolSchedule = self.coolSchedule(annSteps)
        self.integrator.initialize(system)  # Initialize integrator.
        for iStep in range(1, annSteps+1):

            self.integrator.run(system, forceEngine)  # MD integration.

            if (iStep-1) % relaxSteps == 0: 
                # Compute scaling factor according to cooling schedule.
                scaleFactor = coolSchedule.run(iStep)
                scaleFactor1 = 1. - scaleFactor
                targetTemp = scaleFactor1 * initTemp + scaleFactor * finalTemp
                tauTemp = scaleFactor1 * weakTau + scaleFactor * strongTau
                # Create new thermostat.
                annealThermostat = BerendsenThermostat(targetTemp, dt, tauTemp)
            annealThermostat.run(molecule)  # Thermostat

            if self.barostat:  # Barostat
                self.barostat.run(system, self.integrator)

            RMScoord = UTI.calcRMScoord(molecule)
            RMSforce = UTI.calcRMSforce(molecule)
            potEnergy = molecule.getPotentialEnergy()
            oldPotEnergy = molecule.getOldPotentialEnergy()
            diffEnergy = potEnergy - oldPotEnergy

            if iStep % freqOutputMD == 0: 
                outputSA(iStep, SAoutput)
                equilibriumMD.outputMD(system, iStep, MDoutput)

            if iStep % freqOutputTrj == 0: 
                UTI.outputTrj(molecule, xyzFile, iStep)
                equilibriumMD.writeMDrestart(system, rstName)

            if (RMSforce <= threshold):
                convergence = True
                if iStep % freqOutputMD != 0: 
                    outputSA(iStep, SAoutput)
                SAoutput.write("%52s %20.10e \n" % ("<<< Minimization is converged >>> Final RMS force: ", \
                                 RMSforce))
                break
            else:
                for i in range(1, numAtoms1):
                    atom = molecule.getAtomWithNumber(i)
                    atom.setOldPosition(atom.getX(), atom.getY(), atom.getZ())
                molecule.setOldPotentialEnergy(potEnergy)         
    
        if not convergence:
            SAoutput.write("%50s %20.10e \n" % ("<<< Minimization not converged >>> Final RMS force: ", \
                                RMSforce))

        SAoutput.close()
        MDoutput.close()
        xyzFile.close()
        
        return 

