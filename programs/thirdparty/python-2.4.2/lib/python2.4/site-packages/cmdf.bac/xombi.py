import numpy

symbol = ['X','H','He', 'Li','Be','B','C','N','O','F','Ne',
          'Na','Mg', 'Al','Si','P','S','Cl','Ar','K','Ca',
          'Sc','Ti', 'V','Cr','Mn','Fe','Co','Ni','Cu','Zn',
          'Ga','Ge', 'As','Se','Br','Kr','Rb','Sr','Y','Zr',
          'Nb','Mo', 'Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
          'Sb','Te', 'I','Xe','Cs','Ba','La','Ce','Pr','Nd',
          'Pm','Sm', 'Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
          'Lu','Hf', 'Ta','W','Re','Os','Ir','Pt','Au','Hg',
          'Tl','Pb', 'Bi','Po','At','Rn','Fr','Ra','Ac','Th',
          'Pa','U', 'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
          'Md','No', 'Lr','Rf','Db','Sg','Bh','Hs','Mt']


atomicmass = [0.0,1.0079,4.0026,6.941,9.0122,10.811,12.0107,14.0067,15.9994,18.9984,20.1797,
              22.9897,24.305,26.9815,28.0855,30.9738,32.065,35.453,39.948,39.0983,40.078,
              44.9559,47.867,50.9415,51.9961,54.938,55.845,58.9332,58.6934,63.546,65.39,
              69.723,72.64,74.9216,78.96,79.904,83.8,85.4678,87.62,88.9059,91.224,
              92.9064,95.94,98.0,101.07,102.9055,106.42,107.8682,112.411,114.818,118.71,
              121.76,127.6,126.9045,131.293,132.9055,137.327,138.9055,140.116,140.9077,144.24,
              145.0,150.36,151.964,157.25,158.9253,162.5,164.9303,167.259,168.9342,173.04,
              174.967,178.49,180.9479,183.84,186.207,190.23,192.217,195.078,196.9665,200.59,
              204.3833,207.2,208.9804,209.0,210.0,222.0,223.0,226.0,227.0,232.0381,
              231.0359,238.0289,237.0,244.0,243.0,247.0,247.0,251.0,252.0,257.0,
              258.0,259.0,262.0,261.0,262.0,266.0,264.0,277.0,268.0]


sym2no = {}
for i in range(len(symbol)):
    if symbol[i]:
        sym2no[symbol[i]] = i
        sym2no[symbol[i].lower()] = i


class System:
    def __init__(self, molecules=None, number=0,sgName='', sgSymbol='',
                 sgNumber=0, sgCaseNumber=0, a=0, b=0, c=0,
                 alpha=0, beta=0, gamma=0):
    
        self.molecules = molecules
        if self.molecules is None:
            self.molecules = []
        self.number = number
        self.sgName = sgName
        self.sgSymbol = sgSymbol
        self.sgNumber = sgNumber
        self.sgCaseNumber = sgCaseNumber
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        return

    def addMolecule(self, molecule):
        self.molecules.append(molecule)

    def setCellParameters(self, a, b, c, alpha, beta, gamma):
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.betta = beta
        self.gamma = gamma


    def getArrays(self):
        mol = self.molecules[0]
        natoms = mol.numAtoms()

        cellDim = numpy.array([self.a, self.b, self.c, self.alpha, self.beta, self.gamma], numpy.Float)

        coords = numpy.zeros(3*natoms, numpy.Float)
        forces = numpy.zeros(3*natoms, numpy.Float)
        fixed = numpy.zeros(natoms, numpy.Int)
        charges = numpy.zeros(natoms, numpy.Float)
        fftypes = ['' for i in range(natoms)]
        velocities = numpy.zeros(3*natoms, numpy.Float)
        masses = numpy.ones(natoms, numpy.Float)
        imove = numpy.zeros(natoms, numpy.Int)

        bondlist = numpy.zeros(6*natoms, numpy.Int)
        orderlist = numpy.ones(6*natoms, numpy.Float)

        for i in range(natoms):
            atom = mol.getAtomWithNumber(i+1)
            coords[3*i] = atom.position[0]
            coords[3*i+1] = atom.position[1]
            coords[3*i+2] = atom.position[2]
            forces[3*i] = atom.force[0]
            forces[3*i+1] = atom.force[1]
            forces[3*i+2] = atom.force[2]
            charges[i] = atom.charge
            fftypes[i] = atom.fftype
            masses[i] = atom.atomicMass
            if atom.isMovable() == 1:
                imove[i] = 0 
            elif atom.isFixed() == 1:
                imove[i] = 1
            elif atom.isIgnored() == 1:
                imove[i] = 2

            numNeighbors = len(atom.neighbors)
            for j in range(numNeighbors):
                bond = atom.neighbors[j]
                if j < 6:
                    bondlist[6*i+j] = bond.neighborNumber
                    orderlist[6*i+j] = bond.order

        return (cellDim, coords, velocities, forces, imove, fixed, charges, masses, fftypes, bondlist, orderlist)


    def setArrays(self,  cellDim, coords, velocities, forces):
        self.a = cellDim[0]
        self.b = cellDim[1]
        self.c = cellDim[2]
        self.alpha = cellDim[3]
        self.beta = cellDim[4]
        self.gamma = cellDim[5]

        molecule = self.molecules[0]
        numAtoms = molecule.numAtoms()

        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)

            atom.position[0] = coords[3*i]
            atom.position[1] = coords[3*i+1]
            atom.position[2] = coords[3*i+2]


            atom.velocity[0] = velocities[3*i]
            atom.velocity[1] = velocities[3*i+1]
            atom.velocity[2] = velocities[3*i+2]

            atom.force[0] = forces[3*i]
            atom.force[1] = forces[3*i+1]
            atom.force[2] = forces[3*i+2]

        return


class Molecule:
    def __init__(self, name=''):
                 
        self.name = name
        self.number = 0
        self.chains = []
        self.hessian = None
        self.charge = 0
        self.potentialEnergy = 0.0
        self.valenceEnergy = 0.0
        self.vdwEnergy = 0.0
        self.coulombEnergy = 0.0
        self.solvationEnergy = 0.0
        self.potentialEnergies = {}
        self.oldPotentialEnergy = 0.0
        self.degFree = 3


    def calcKineticEnergy(self):
        n = self.numAtoms()
        N = n + 1
        mass = 0.0
        
        ke = 0.0
        vx = 0.0
        vy = 0.0
        vz = 0.0
        for i in range(1, N):
            atom = self.getAtomWithNumber(i)
            mass = atom.atomicMass()
            vx = atom.velocity[0]
            vy = atom.velocity[1]
            vz = atom.velocity[2]

            ke += mass*(vx*vx + vy*vy + vz*vz);

        return 0.5 * ke;


    def calcOldKineticEnergy(self):

        n = self.numAtoms()
        N = n + 1
        mass = 0.0
        ke = 0.0
        vx = 0.0
        vy = 0.0
        vz = 0.0

        for i in range(1, N):
        
            atom = self.getAtomWithNumber(i)
            mass = atom.atomicMass
            vx = atom.oldVelocity[0]
            vy = atom.oldVelocity[1]
            vz = atom.oldVelocity[2]

            ke += mass*(vx*vx + vy*vy + vz*vz);

        
        return 0.5 * ke;


    def getDimension(self):
        return 3


    def getHessian(self, i, j):
        if sefl.hessian is None:
            self.initHessian()
        if i < j:
            return self.hessian[j][i]

        return self.hessian[i][j]


    def getAtomWithNumber(self, number):
        for chain in self.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if atom.number == number:
                        return atom
        return None            


    def getDefaultResidue(self):
        chain_name = "A"
        res_name = "RES"
        res_number = 444
        chain = self.getChain(chain_name)
        if chain is None:
            chain = Chain(chain_name)
            self.chains.append(chain)
        
        residue = chain.getResidue(res_name, res_number)
        if residue is None:
            residue = Residue(res_name, res_number)
            chain.residues.append(residue)
        
        return residue


    def getResidue(self, res_name, res_number, chain_name):
        chain = self.getChain(chain_name)
        if chain is None:
            chain = Chain(chain_name)
            self.chains.append(chain)
        
        residue = chain.getResidue(res_name, res_number)
        if residue is None:
            residue = Residue(res_name, res_number)
            chain.residues.append(residue)

        return residue


    def numAtoms(self):
        numatoms = 0
        for chain in self.chains:
            numatoms += chain.numAtoms()
        return numatoms


    def getChain(self, name):
        for chain in self.chains:
            if chain.name == name:
                return chain
        return None        


    def numChains(self):
        return len(self.chains)


    # Set functions
    def initHessian(self):

        self.hessian = []
        n = 3*self.numAtoms()
        
        self.hessian = [0.0 for i in range(n)]

        for i in range(n):
            self.hessian[i] = [0.0 for j in range(i+1)]


    def setHessian(self, i, j, value):
        if self.hessian is None:
            self.initHessian()
        
        if i < j:
            self.hessian[j][i] = value
        else:    
            self.hessian[i][j] = value


    # Delete functions
    def removeAtomWithNumber(self, atomNumber):
        for chain in self.chains:
            for residue in chain.residues:
                residue.removeAtomWithNumber(atomNumber)
        return


    def addBond(self, rootNumber, neighborNumber, order, itran):
        atom = self.getAtomWithNumber(rootNumber)
        atom.addBond(neighborNumber, order, itran)
        return


    def addBonds(self, rootNumber, neighborNumber, order, itran):
        root = self.getAtomWithNumber(rootNumber);
        neighbor = self.getAtomWithNumber(neighborNumber);

        if root:
            root.addBond(neighborNumber, order, itran);

        if neighbor:
            neighbor.addBond(rootNumber, order, itran);
        return    

    
    def setBondOrders(self, rootNumber, neighborNumber, order):
        root = self.getAtomWithNumber(rootNumber)
        neighbor = self.getAtomWithNumber(neighborNumber)

        if root:
            root.addBondOrder(neighborNumber, order)
        if neighbor:
            neighbor.addBondOrder(rootNumber, order)
        return    


    def setBondItrans(self, rootNumber, neighborNumber, itran):
        root = self.getAtomWithNumber(rootNumber)
        neighbor = self.getAtomWithNumber(neighborNumber)

        if root:
            root.addBondItran(neighborNumber, itran)
        if neighbor:
            neighbor.addBondItran(rootNumber, itran)
        return    


    def removeBonds(self, rootNumber, neighborNumber):
        root = self.getAtomWithNumber(rootNumber);
        neighbor = self.getAtomWithNumber(neighborNumber)
        
        if root:
            root.removeBond(neighborNumber)
        if neighbor:
            neighbor.removeBond(rootNumber)
        return


    def translateCM(self, x, y, z):
        # Calculate CM for current system
        n = self.numAtoms();
        for i in range(1, n+1):
            atom = self.getAtomWithNumber(i)

            mass = atom.atomicMass
            totMass += mass;

            cmX += atom.position[0] * mass;
            cmY += atom.position[1] * mass;
            cmZ += atom.position[2] * mass;

        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass

        # Translate the system back to the reference CM: cmref
        deltaX = cmX - x
        deltaY = cmY - y
        deltaZ = cmZ - z

        for i in range(1, n+1):
            atom = self.getAtomWithNumber(i)

            xnew = atom.position[0] - deltaX
            ynew = atom.position[1] - deltaY
            znew = atom.position[2] - deltaZ

            atom.position[0] = xnew
            atom.position[1] = ynew
            atom.position[2] = znew

        return
        

    def numMovableAtoms(self):

        n = self.numAtoms()
        movable = 0
        for i in range(n):
            atom = self.getAtomWithNumber(i+1)
            if atom.isMovable():
                movable += 1

        return movable


    def numFixedAtoms(self):
        n = self.numAtoms()
        fixed = 0
        for i in range(n):
            atom = self.getAtomWithNumber(i+1)
            if atom.isFixed():
                fixed += 1

        return fixed


    def numIgnoredAtoms(self):
        n = self.numAtoms()
        ignored = 0
        for i in range(n):
            atom = self.getAtomWithNumber(i+1)
            if atom.isIgnored():
                ignored += 1

        return ignored


    def removeMomentum(self):
        #Calculate linear momentum p for the molecule   

        numatoms = self.numAtoms()
        totMass = 0.
        px = py = pz = 0.0

        for i in range(1, numatoms+1):
            atom = getAtomWithNumber(i)

            mass = atom.atomicMass()
            totMass += mass

            px += atom.velocity[0] * mass
            py += atom.velocity[1] * mass
            pz += atom.velocity[2] * mass

        deltaVx = px / totMass
        deltaVy = py / totMass
        deltaVz = pz / totMass

        # Remove linear momentum p for current system by shifting velocity 
       
        for i in range(1, numatoms+1):
            atom = self.getAtomWithNumber(i)

            vxnew = atom.velocity[0] - deltaVx;
            vynew = atom.velocity[1] - deltaVx;
            vznew = atom.velocity[2] - deltaVx;

            atom.velocity[0] = vxnew
            atom.velocity[1] = vynew
            atom.velocity[2] = vznew

        return
    

class Chain:

    def __init__(self, name='', number=0):
        self.name = ''
        self.number = 0
        self.residues = []
        return
    

    def numRresidues(self):
        return len(self.residues)


    def numAtoms(self):
        numAtoms = 0
        for residue in self.residues:
            numAtoms += len(residue.atoms)
        return numAtoms    


    def getResidue(self, name, number):
        for res in self.residues:
            if res.name == name and res.number == number:
                return res
        return None


class Residue:
    def __init__(self, name='RES', number=444):
        self.atoms = []
        self.name = name
        self.number = number
        return


    def getAtomWithNumber(self, number):
        for atom in self.atoms:
            if atom.number == number:
                return atom
        return None


    def addBonds(self, rootNumber, neighborNumber, order, itran):
        root = self.getAtomWithNumber(rootNumber);
        neighbor = self.getAtomWithNumber(neighborNumber);

        if root: 
            root.addBond(neighborNumber, order, itran);

        if neighbor:
            neighbor.addBond(rootNumber, order, itran);
        return


    def setBondOrders(self, rootNumber, neighborNumber, order):
        root = self.getAtomWithNumber(rootNumber)
        neighbor = self.getAtomWithNumber(neighborNumber)
        if root:
            root.addBondOrder(neighborNumber, order)
        if neighbor:
            neighbor.addBondOrder(rootNumber, order)
        return


    def setBondItrans(self, rootNumber, neighborNumber, itran):
        root = self.getAtomWithNumber(rootNumber)
        neighbor = self.getAtomWithNumber(neighborNumber)
        if root:
            root.addBondItran(neighborNumber, itran)
        if neighbor:
            neighbor.addBondItran(rootNumber, itran)
        return


    def removeBonds(self, rootNumber, neighborNumber):
        root = self.getAtomWithNumber(rootNumber)
        neighbor = self.getAtomWithNumber(neighborNumber)
        if root:
            root.removeBond(neighborNumber)
        if neighbor:
            neighbor.removeBond(rootNumber)
        return


    def getLabel(self):
        return self.name + str(self.number)


    def getAtomIndex(self, atomNumber):
        for i in range(len(self.atoms)):
            atom = self.atoms[i]
            if atom.number == atomNumber:
                return i
        return -1


    def removeAtomWithNumber(self, atomNumber):
        index = -1

        # get index of the atom with number = atomNumber
        index = self.getAtomIndex(atomNumber)
        # get atom with number == atomNumber
        if index != -1:
            atom = self.atoms[index]
        else:
            return


        # time for some bookkeeping: 
        # get each neighbor atom of the atom to be deleted
        # and iterate over that atom's neighbor list, deleting
        # bonds that correspond to the atom being deleted.
        for i in range(atom.numNeighbors()):
            bond = atom.getNeighbor(i)
            neighborNumber = bond.getNeighborNumber()
            at = self.getAtomWithNumber(neighborNumber)
            for j in range(at.numNeighbors()):
                bnd = at.getNeighbor(j)
                if bnd.getNeighborNumber() == atomNumber:
                    at.removeBond(atomNumber)
                

        # delete the atom from the list
        del self.atoms[index]
        return


class Atom:
    def __init__(self, number=0, label='', residueName='RES', chain='A', residueNumber=444,
                 x=0., y=0., z=0., fftype='', charge=0., maxCovalentBonds=0, lonePairs=0):
        
        self.number = number
        self.atomicMass = 0.0
        self.atomicNumber = 0

        self.position = numpy.array([0.0, 0.0, 0.0])
        self.position[0] = x
        self.position[1] = y
        self.position[2] = z
        self.velocity = numpy.array([0.0, 0.0, 0.0])
        self.force = numpy.array([0.0, 0.0, 0.0])

        self.oldPosition = numpy.array([0.0, 0.0, 0.0])
        self.oldVelocity = numpy.array([0.0, 0.0, 0.0])
        self.oldForce = numpy.array([0.0, 0.0, 0.0])

        self.frequency = numpy.array([0.0, 0.0, 0.0])

        self.residueName = residueName
        self.residueNumber = residueNumber
        self.chain = chain
        self.tag = ''
        self.fftype = fftype
        self.charge = charge
        self.element = ''
        self.gid = 0
        self.potentialEnergy = 0.0
        self.imove = 0

        self.neighbors = []

        self.weight = [0.0 for i in range(10)]
        self.engine = [0 for i in range(10)]
        self.tmp = [0.0 for i in range(10)]


    def setMovable(self):
        self.imove = 0

    def setFixed(self):
        self.imove = 1


    def setIgnored(self):
        self.imove = 2

    def isMovable(self):
        if self.imove == 0:
            return 1
        return 0
    
    def isFixed(self):
        if self.imove == 1:
            return 1
        return 0    
    
    def isIgnored(self):
        if self.imove == 2:
            return 1
        return 0    
        

    def setAtomicNumber(self, atomicNumber):
        self.atomicNumber = atomicNumber
        if atomicNumber < len(symbol):
            self.setElement(symbol[atomicNumber])
        return    


    def setElement(self, element):
        self.element = element
        if sym2no.has_key(element):
            self.atomicNumber = sym2no[element]
            self.atomicMass = atomicmass[self.atomicNumber]

    def setPosition(self, x, y, z):
        self.position[0] = x
        self.position[1] = y
        self.position[2] = z

    def setVelocity(self, vx, vy, vz):
        self.velocity[0] = vx
        self.velocity[1] = vy
        self.velocity[2] = vz


    def setForce(self, fx, fy, fz):
        self.force[0] = fx
        self.force[1] = fy
        self.force[2] = fz



    def setOldPosition(self, x, y, z):
        self.oldPosition[0] = x
        self.oldPosition[1] = y
        self.oldPosition[2] = z

    def setOldVelocity(self, vx, vy, vz):
        self.oldVelocity[0] = vx
        self.oldVelocity[1] = vy
        self.oldVelocity[2] = vz


    def setOldForce(self, fx, fy, fz):
        self.oldForce[0] = fx
        self.oldForce[1] = fy
        self.oldForce[2] = fz




    def addBond(self, neighborNumber, order=1, itran=222):
        bond = Bond(self.number, neighborNumber, order, itran)
        self.neighbors.append(bond)
        return bond


    def setBondOrder(self, neighborNumber, order):
        for bond in self.neighbors:
            if bond.neighborNumber == neighborNumber:
                bond.order = order
        return


    def setBondItran(self, neighborNumber, itran):
        for bond in self.neighbors:
            if bond.neighborNumber == neighborNumber:
                bond.itran = itran
        return


    def removeBond(self, neighborNumber):
        size = len(self.neighbors)
        i = 0
        while i < size:
            bond = self.neighbors[i]
            if bond.neighborNumber == neighborNumber:
                del self.neighbors[i]
                size -= 1
            else:
                i += 1
        return        
        

class Bond:
    def __init__(self, rootNumber=0, neighborNumber=0, order=1, itran=222):
        self.rootNumber = rootNumber
        self.neighborNumber = neighborNumber
        self.order = order
        self.itran = itran
        return


