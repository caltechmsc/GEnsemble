#!usr/bin/env python
#########################################################################################################
#                                                                                                       # 
# minimize.py         : minimizers adopted from SciPy including                                         # 
#                       Nelder-Mead Simplex algorithm                                                   # 
#                       BFGS quasi-Newton algorithm                                                     # 
#                       Conjugate gradient algorithm                                                    # 
#                       Newton-CG algorithm                                                             # 
#                       Modified Powell's algorithm                                                     # 
#                                                                                                       # 
# Created on 06/20/06, last revision on 06/22/06. yi                                                    #
#                                                                                                       # 
#########################################################################################################

import scipy
import scipy.optimize.optimize as optimize
import numpy 
#from Precision import *
#import modMulti
import MEE
#from utility_pf import *
#from integrator_pf import * 
#from distribution import *
#from mdEngine import *
#from thermostat_pf import *
#from control import *          
#from modbabel import *
from meeForceEngine import MeeForceEngine
from reaxForceEngine import ReaxForceEngine
#import bgfio, profile
#from shannoPhua_f import *
from communication import *
import sys
from math import sqrt

class Minimize:

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        self.molName = molName
        self.xthreshold = xthreshold
        self.fthreshold = fthreshold
        self.gthreshold = gthreshold
        self.maxiteration = maxiteration
        self.maxfunction = maxfunction
        self.full_output = full_output
        self.disp = disp
        self.retall = retall
        self.coords = coords
        self.args = ()
        self.norm = 2
        self.epsilon = sqrt(numpy.finfo(float).eps)

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        return

class Simplex(Minimize):

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        Minimize.__init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords) 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        from control import Control
        printLevel = Control.printLevel
        energyUnit = Control.printEnergyUnit
        energyFlag = Control.printEnergyFlag

        minFile = open(self.molName+'.min', 'a')
        minFile.write("%12s<<< CMDF minimization with Simplex method >>>\n" % (' '))

        x0 = self.coords

        f = forceEngine.Energy
        fprime = forceEngine.Gradient
        f0 = f(x0)
        g0 = fprime(x0)
        if printLevel > 0:
            minFile.write("Initial energy in minimization = %20.10e %10s\n" % (f0 / energyUnit, energyFlag)) 
            minFile.write("Initial coords in minimization = "+str(x0)+"\n") 
            minFile.write("Initial forces in minimization = "+str(g0 / energyUnit)+"\n") 

        #output = (xopt, fopt, iter, func_calls, warnflag)  
        minout = optimize.fmin(f, x0, self.args, self.xthreshold, self.fthreshold, self.maxiteration, self.maxfunction, self.full_output, self.disp, self.retall)

        energy = minout[1]                
        coords = minout[0]
        energy_final = f(coords) 
        force_final = fprime(coords) 
        arraysToSystem_min(system, coords, energy_final, force_final)  # Update system information.

        if printLevel > 0:
            minFile.write("The number of function_calls = %8i\n" % (minout[3]))
            minFile.write("The number of iterations     = %8i\n" % (minout[2]))
            minFile.write("Final energy in minimization = %20.10e %10s\n" % (energy / energyUnit, energyFlag)) 
            minFile.write("Final coords in minimization = "+str(coords)+"\n") 
            minFile.write("Final forces in minimization = "+str(force_final / energyUnit)+"\n") 
        elif printLevel > 2:
            #minFile.write("All coordinates at every step= "+str(minout[7])+"\n")
            pass

        minFile.close()

        return

class BFGS(Minimize):

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        Minimize.__init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords) 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        from control import Control
        printLevel = Control.printLevel
        energyUnit = Control.printEnergyUnit
        energyFlag = Control.printEnergyFlag

        minFile = open(self.molName+'.min', 'a')
        minFile.write("%12s<<< CMDF minimization with BFGS method >>>\n" % (' '))

        x0 = self.coords

        f = forceEngine.Energy
        fprime = forceEngine.Gradient
        f0 = f(x0)
        g0 = fprime(x0)
        if printLevel > 0:
            minFile.write("Initial energy in minimization = %20.10e %10s\n" % (f0 / energyUnit, energyFlag)) 
            minFile.write("Initial coords in minimization = "+str(x0)+"\n") 
            minFile.write("Initial forces in minimization = "+str(g0 / energyUnit)+"\n") 

        #output = (xopt, fopt, gopt, Hopt, func_calls, grad_calls, warnflag, allvecs)  
        minout = optimize.fmin_bfgs(f, x0, fprime, self.args, self.gthreshold, self.norm, self.epsilon, self.maxiteration, self.full_output, self.disp, self.retall)

        energy = minout[1]                
        coords = minout[0]
        energy_final = f(coords) 
        force_final = fprime(coords) 
        arraysToSystem_min(system, coords, energy_final, force_final)  # Update system information.

        if printLevel > 0:
            minFile.write("The number of function_calls = %8i\n" % (minout[4]))
            minFile.write("The number of gradient_calls = %8i\n" % (minout[5]))
            minFile.write("Final energy in minimization = %20.10e %10s\n" % (energy / energyUnit, energyFlag)) 
            minFile.write("Final coords in minimization = "+str(coords)+"\n") 
            minFile.write("Final forces in minimization = "+str(force_final / energyUnit)+"\n") 
        elif printLevel > 2:
            minFile.write("All coordinates at every step= "+str(minout[7])+"\n")

        minFile.close()

        return

class ConjugateGradient_PR(Minimize):
    """
    CG of Polak and Ribiere algorithm.
    """

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        Minimize.__init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords) 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        from control import Control
        printLevel = Control.printLevel
        energyUnit = Control.printEnergyUnit
        energyFlag = Control.printEnergyFlag

        minFile = open(self.molName+'.min', 'a')
        minFile.write("%12s<<< CMDF minimization with conjugate gradient method (Polak-Ribiere) >>>\n" % (' '))

        x0 = self.coords

        f = forceEngine.Energy
        fprime = forceEngine.Gradient
        f0 = f(x0)
        g0 = fprime(x0)
        if printLevel > 0:
            minFile.write("Initial energy in minimization = %20.10e %10s\n" % (f0 / energyUnit, energyFlag)) 
            minFile.write("Initial coords in minimization = "+str(x0)+"\n") 
            minFile.write("Initial forces in minimization = "+str(g0 / energyUnit)+"\n") 

        #output = (xopt, fopt, func_calls, grad_calls, warnflag, allvecs)  
        minout = optimize.fmin_cg(f, x0, fprime, self.args, self.gthreshold, self.norm, self.epsilon, self.maxiteration, self.full_output, self.disp, self.retall)

        energy = minout[1]               
        coords = minout[0]
        energy_final = f(coords) 
        force_final = fprime(coords) 
        arraysToSystem_min(system, coords, energy_final, force_final)  # Update system information.

        if printLevel > 0:
            minFile.write("The number of function_calls = %8i\n" % (minout[2]))
            minFile.write("The number of gradient_calls = %8i\n" % (minout[3]))
            minFile.write("Final energy in minimization = %20.10e %10s\n" % (energy / energyUnit, energyFlag)) 
            minFile.write("Final coords in minimization = "+str(coords)+"\n") 
            minFile.write("Final forces in minimization = "+str(force_final / energyUnit)+"\n") 
        elif printLevel > 2:
            minFile.write("All coordinates at every step= "+str(minout[5])+"\n")

        minFile.close()

        return

class Newton_CG(Minimize):

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        Minimize.__init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords) 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
    ### Warning: Coordinates don't update due to a possible bug. 
        from control import Control
        printLevel = Control.printLevel
        energyUnit = Control.printEnergyUnit
        energyFlag = Control.printEnergyFlag

        minFile = open(self.molName+'.min', 'a')
        minFile.write("%12s<<< CMDF minimization with Newton CG method >>>\n" % (' '))

        x0 = self.coords

        f = forceEngine.Energy
        fprime = forceEngine.Gradient
        f0 = f(x0)
        g0 = fprime(x0)
        if printLevel > 0:
            minFile.write("Initial energy in minimization = %20.10e %10s\n" % (f0 / energyUnit, energyFlag)) 
            minFile.write("Initial coords in minimization = "+str(x0)+"\n") 
            minFile.write("Initial forces in minimization = "+str(g0 / energyUnit)+"\n") 

        # Use approximate Hessian.
        fhess_p = None
        fhess = None
        #output = (xopt, fopt, func_calls, grad_calls, hess_calls, warnflag, allvecs)  
        minout = optimize.fmin_ncg(f, x0, fprime, fhess_p, fhess, self.args, self.xthreshold, self.epsilon, self.maxiteration, self.full_output, self.disp, self.retall)

        energy = minout[1]                
        coords = minout[0]
        energy_final = f(coords) 
        force_final = fprime(coords) 
        arraysToSystem_min(system, coords, energy_final, force_final)  # Update system information.

        if printLevel > 0:
            minFile.write("The number of function_calls = %8i\n" % (minout[2]))
            minFile.write("The number of gradient_calls = %8i\n" % (minout[3]))
            minFile.write("The number of Hessian_calls  = %8i\n" % (minout[4]))
            minFile.write("Final energy in minimization = %20.10e %10s\n" % (energy / energyUnit, energyFlag)) 
            minFile.write("Final coords in minimization = "+str(coords)+"\n") 
            minFile.write("Final forces in minimization = "+str(force_final / energyUnit)+"\n") 
        elif printLevel > 2:
            minFile.write("All coordinates at every step= "+str(minout[6])+"\n")

        minFile.close()

        return

class Powell(Minimize):

    def __init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords):
        Minimize.__init__(self, molName, xthreshold, fthreshold, gthreshold, maxiteration, maxfunction, full_output, disp, retall, coords) 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        from control import Control
        printLevel = Control.printLevel
        energyUnit = Control.printEnergyUnit
        energyFlag = Control.printEnergyFlag

        minFile = open(self.molName+'.min', 'a')
        minFile.write("%12s<<< CMDF minimization with Powell method >>>\n" % (' '))

        x0 = self.coords

        f = forceEngine.Energy
        fprime = forceEngine.Gradient
        f0 = f(x0)
        g0 = fprime(x0)
        if printLevel > 0:
            minFile.write("Initial energy in minimization = %20.10e %10s\n" % (f0 / energyUnit, energyFlag)) 
            minFile.write("Initial coords in minimization = "+str(x0)+"\n") 
            minFile.write("Initial forces in minimization = "+str(g0 / energyUnit)+"\n") 

        #output = (xopt, fopt, direc, iter, func_calls, warnflag, allvecs)  
        minout = optimize.fmin_powell(f, x0, self.args, self.xthreshold, self.fthreshold, self.maxiteration, self.maxfunction, self.full_output, self.disp, self.retall)

        energy = minout[1]                
        coords = minout[0]
        energy_final = f(coords) 
        force_final = fprime(coords) 
        arraysToSystem_min(system, coords, energy_final, force_final)  # Update system information.

        if printLevel > 0:
            minFile.write("The number of function_calls = %8i\n" % (minout[4]))
            minFile.write("The number of iterations     = %8i\n" % (minout[3]))
            minFile.write("Final energy in minimization = %20.10e %10s\n" % (energy / energyUnit, energyFlag)) 
            minFile.write("Final coords in minimization = "+str(coords)+"\n") 
            minFile.write("Final forces in minimization = "+str(force_final / energyUnit)+"\n") 
        elif printLevel > 2:
            minFile.write("All coordinates at every step= "+str(minout[6])+"\n")

        minFile.close()

        return

