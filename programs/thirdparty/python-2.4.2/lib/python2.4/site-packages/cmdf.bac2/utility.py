#####################################################################################
#                                                                                   #
#  Utility class consists of many useful methods often used in other main processes.#
#                                                                                   #
#  calcXXX          : calculate some properties.                                    #
#                                                                                   #
# Created on 02/27/06, last revision on 04/13/06. yi                                #
#                                                                                   #
#####################################################################################

from math import sqrt
from control import *
from unit import *   
from lapy import *    
from integrator import *
from distribution import *

class Utility:

    def setMBvelocity(self, molecule, ttarget, gaussian):
    # Assign velocity from Maxwell-Boltzmann distribution acoording to temperature and mass.
    # The MB distribution has standard deviation sigma and mean miu.
        from math import sqrt

        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        mass = [0.] * numAtoms1

        miu = 0.  # zero mean
        kbt = UNIT.KB * ttarget  # Kb*T    
        vmb = [0.] * 3

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            mass[i] = atom.getAtomicMass()

            sigma = sqrt(kbt / mass[i])  # Standard deviation of MB dist.: sigma = sqrt(Kb*T/m)
            if (gaussian is Gaussian1 or gaussian is Gaussian2):
                GAUSS = gaussian(sigma, miu) 
                for j in range(3):
                    vgaus = GAUSS.run()  # Assign velocity from Gaussian(MB) distribution.
                    vmb[j] = vgaus
            elif (gaussian is Gaussian3):
                sigmaVec = [sigma] * 3
                GAUSS = gaussian(sigmaVec, miu) 
                vmb = GAUSS.run(3)

            atom.setVelocity(vmb[0], vmb[1], vmb[2])  # Update velocity

        return

    def setRanVelocity(self, molecule, ttarget):
    # Assign velocities from random distribution according to temperature and mass. 
        from math import sqrt

        RAN = Random1()
        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kesum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            mass = atom.getAtomicMass()

            vx = 1. - 2. * RAN.run()
            vy = 1. - 2. * RAN.run()
            vz = 1. - 2. * RAN.run()

            atom.setVelocity(vx, vy, vz)

            kesum += mass * (vx ** 2. + vy ** 2. + vz ** 2.)

        temp = kesum / (UNIT.KB * molecule.getDegFree())
        scale = sqrt(ttarget / temp)
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue

            atom.setVelocity(atom.getVelocityX() * scale,
                             atom.getVelocityY() * scale,
                             atom.getVelocityZ() * scale) 

        return 

    def randomVector(self):
    # Generates a random vector on a unit sphere.
        from math import sqrt
        RAN = Random3()
    
        ranvec = [0.] * 3
        n = 2   
        ransq = 2.
        while (ransq >= 1):
            ranv = RAN.run(n)  # Generate two random numbers
            ranum1 = 1. - 2. * ranv[0]
            ranum2 = 1. - 2. * ranv[1]
            ransq = ranum1 * ranum1 + ranum2 * ranum2
        ranh = 2. * sqrt(1. - ransq)
        ranvec[0] = ranum1 * ranh
        ranvec[1] = ranum2 * ranh
        ranvec[2] = 1. - 2. * ransq
    
        return ranvec
    
    def calcDistance(self, molecule, numA, numB):
    # Compute the distance between atom A nad B. 
        from math import sqrt

        atom1 = molecule.getAtomWithNumber(numA)    
        atom2 = molecule.getAtomWithNumber(numB)    

        x1 = atom1.getX() 
        y1 = atom1.getY() 
        z1 = atom1.getZ() 

        x2 = atom2.getX() 
        y2 = atom2.getY() 
        z2 = atom2.getZ() 

        dist12 = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) 

        return dist12

    def calcDistance2(self, molecule, numA, numB):
    # Compute the distance square between atom A nad B. 
        atom1 = molecule.getAtomWithNumber(numA)    
        atom2 = molecule.getAtomWithNumber(numB)    

        x1 = atom1.getX() 
        y1 = atom1.getY() 
        z1 = atom1.getZ() 

        x2 = atom2.getX() 
        y2 = atom2.getY() 
        z2 = atom2.getZ() 

        dist12sq = (x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2 

        return dist12sq

    def calcVolume(self, system, integrator):

        if (integrator is VelocityVerletAH):
            volume = 2.71828 ** (system.getDimension() * self.xah)
        elif (integrator is VelocityVerletPRH):
            volume = self.matDet(self.box)
        else:
            volume = system.getA() * system.getB() * system.getC()

        return volume

    def calcPress(self, system, integrator):
        UNIT = Unit()
        volume = self.calcVolume(system, integrator)
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        # Initialize stress tensor (3*3)
        stress = {} 
        for i in range(3):
            for j in range(3):
                stress[(i, j)] = 0. 

        r = [0.] * 3; v = [0.] * 3; f = [0.] * 3
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass() 

            r = (atom.getX(), atom.getY(), atom.getZ()) 
            v = (atom.getVelocityX(), atom.getVelocityY(), atom.getVelocityZ()) 
            f = (atom.getForceX(), atom.getForceY(), atom.getForceZ()) 
            # Compute stress tensor.
            for j in range(3):
                for k in range(3):
                    stress[(j, k)] += mass * v[j] * v[k] + f[j] * r[k] 

        press = 0.
        for i in range(3):
            for j in range(3):
                stress[(i, j)] = stress[(i, j)] / volume 

            press += stress[(i, i)]  # Compute the trace of stress tensor

        # Instantaneous pressure
        press = press / 3.0

        return press

    def calcStress(self, molecule):
    # Compute stress tensor (P*V).

        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        r = {}
        v = {}
        f = {}
        stress = {}
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                stress[(i, j)] = 0.

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()

            r[1] = atom.getX()
            r[2] = atom.getY()
            r[3] = atom.getZ()

            v[1] = atom.getVelocityX()
            v[2] = atom.getVelocityY()
            v[3] = atom.getVelocityZ()

            f[1] = atom.getForceX()
            f[2] = atom.getForceY()
            f[3] = atom.getForceZ()

            for j in [1, 2, 3]:
                for k in [1, 2, 3]:
                    stress[(j, k)] += mass * v[j] * v[k] + f[j] * r[k]

        # Symmetrize the stress tensor to eliminate cell rotation.
        for i in range(1, 3):
            for j in range(i+1, 4):
                systress = 0.5 * (stress[(i, j)] + stress[(j, i)]) 
                stress[(i, j)] = systress
                stress[(j, i)] = systress

        return stress

    def calcKinEnergyBox(self, bmass, vbox):        
    # Compute total kinetic energy for box.

        kinEnergyBox = 0.
        for i in [1, 2, 3]: 
            for j in [1, 2, 3]:
                kinEnergyBox += vbox[(i, j)] ** 2                

        kinEnergyBox = 0.5 * bmass * kinEnergyBox

        return kinEnergyBox

    # Next function can be replaced by calcPositionCM.
    def calcCM1(self, molecule):
    # Calculate center of mass for the molecule
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += atom.getX() * mass
            cmY += atom.getY() * mass
            cmZ += atom.getZ() * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
        return (cmX, cmY, cmZ)
    
    def calcCM2(self, molecule, rx, ry, rz):
    # Calculate center of mass for the system (rx, ry, rz)
    #This allows one to calculate CM for a system whose coordinates differ from those in data model
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += rx[i] * mass
            cmY += ry[i] * mass
            cmZ += rz[i] * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
        return (cmX, cmY, cmZ)
    
    def translateCM1(self, molecule, cmref):
    # Translate the center of mass of the "molecule" to a reference cmref.
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
    # Calculate CM for current system
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += atom.getX() * mass
            cmY += atom.getY() * mass
            cmZ += atom.getZ() * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
    # Translate the system back to the reference CM: cmref
        delatX = cmX - cmref[0]
        delatY = cmY - cmref[1]
        delatZ = cmZ - cmref[2]
    
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            Xnew = atom.getX() - delatX
            Ynew = atom.getY() - delatY
            Znew = atom.getZ() - delatZ
    
            atom.setPosition(Xnew, Ynew, Znew)  #Update coordinate of molecule
    
        return
    
    def translateCM2(self, molecule, rx, ry, rz, cmref):
    # Translate the center of mass of the "system" (rx, ry, rz) to a reference cmref
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
    # Calculate CM for current system
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += rx[i] * mass
            cmY += ry[i] * mass
            cmZ += rz[i] * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
    # Translate the system back to the reference CM: cmref
        delatX = cmX - cmref[0]
        delatY = cmY - cmref[1]
        delatZ = cmZ - cmref[2]
    
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            rx[i] = rx[i] - delatX
            ry[i] = ry[i] - delatY
            rz[i] = rz[i] - delatZ
    
        return

    def calcKinEnergyTen(self, molecule, kinEnergyTen):
        #Compute total kinetic energy and KE tensor.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kinEnergySum = 0.
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                kinEnergyTen[(i, j)] = 0.

        v = {}
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            v[1] = atom.getVelocityX()
            v[2] = atom.getVelocityY()
            v[3] = atom.getVelocityZ()
            factor = 0.5 * mass
            for j in [1, 2, 3]: 
                for k in [1, 2, 3]:
                    kinEnergyTen[(j, k)] += factor * v[j] * v[k] 

            kinEnergySum += mass * (atom.getVelocityX()**2 + 
                        atom.getVelocityY()**2 + atom.getVelocityZ()**2)

        kinEnergy = 0.5 * kinEnergySum 
    
        kinEnergyTot = kinEnergyTen[(1, 1)] + kinEnergyTen[(2, 2)] + kinEnergyTen[(3, 3)]

        if (abs(kinEnergy - kinEnergyTot) > 1.e-3):
            print 'Warning! calcKinEnergyTen: kinetic energies are not consistent.'
            return

        return kinEnergyTot

    def calcKinEnergy(self, molecule):

        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        kinEnergySum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
    
            kinEnergySum += mass * (atom.getVelocityX() ** 2 + 
                                    atom.getVelocityY() ** 2 + 
                                    atom.getVelocityZ() ** 2 )

        kinEnergy = 0.5 * kinEnergySum 
    
        return kinEnergy
    
    def calcTemp(self, molecule):
        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        kinEnergySum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()

            kinEnergySum += mass * (atom.getVelocityX() ** 2 + 
                                    atom.getVelocityY() ** 2 + 
                                    atom.getVelocityZ() ** 2 )

        temp = kinEnergySum/(UNIT.KB * molecule.getDegFree())
    
        return temp
    
    def calcKinEnergyTemp(self, molecule):
        #from math import sqrt
        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kinEnergySum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
    
            kinEnergySum += mass * (atom.getVelocityX() ** 2 + 
                                    atom.getVelocityY() ** 2 + 
                                    atom.getVelocityZ() ** 2 )
    
        temp = kinEnergySum/(UNIT.KB * molecule.getDegFree())

        kinEnergy = 0.5 * kinEnergySum 
    
        return (kinEnergy, temp)

    def calcOldKinEnergyTemp(self, molecule):
    # Compute KE and temperature using OldVelocity in Leap Frog integration.
        #from math import sqrt
        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kinEnergySum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            
            kinEnergySum += mass * (atom.getOldVelocityX() ** 2 + 
                                    atom.getOldVelocityY() ** 2 + 
                                    atom.getOldVelocityZ() ** 2 )
    
        temp = kinEnergySum/(UNIT.KB * molecule.getDegFree())

        kinEnergy = 0.5 * kinEnergySum 
    
        return (kinEnergy, temp)

    def calcRMSforce(self, molecule):
        from math import sqrt

        forceSquareSum = 0.
        numAtoms = molecule.numAtoms()
        for i in range(1, numAtoms+1):
            atom = molecule.getAtomWithNumber(i)

            forceSquareSum += atom.getForceX()**2 + atom.getForceY()**2 + atom.getForceZ()**2

        rmsforce = sqrt(forceSquareSum / molecule.getDegFree())

        return rmsforce

    def calcRMScoord(self, molecule):
        from math import sqrt

        coordSquareSum = 0.
        numAtoms = molecule.numAtoms()
        for i in range(1, numAtoms+1):
            atom = molecule.getAtomWithNumber(i)
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()

            rxold = atom.getOldX()
            ryold = atom.getOldY()
            rzold = atom.getOldZ()

            coordSquareSum += (rx - rxold)**2 + (ry - ryold)**2 + (rz - rzold)**2

        rmscoord = sqrt(coordSquareSum / molecule.getDegFree())

        return rmscoord

    # Next function is similar to calcRMScoord above except explicitly asking for coordinates.
    def calcRMScoordinate(self, numAtoms, xnew, ynew, znew, xold, yold, zold):
        from math import sqrt

        coordSquareSum = 0.
        for i in range(1, numAtoms+1):
            coordSquareSum += (xnew[i] - xold[i])**2 + (ynew[i] - yold[i])**2 + (znew[i] - zold[i])**2

        ### Note no constraints considered yet for dof.
        degFree = 3. * numAtoms - 6
        rmscoord = sqrt(coordSquareSum / degFree)

        return rmscoord

    def calcMomentum(self, molecule):
    # Calculate linear momentum p for the molecule   
        totMass = 0.
        pX = 0.
        pY = 0.
        pZ = 0.
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            pX += atom.getVelocityX() * mass
            pY += atom.getVelocityY() * mass
            pZ += atom.getVelocityZ() * mass
    
        pX = pX / totMass
        pY = pY / totMass
        pZ = pZ / totMass
    
        return (pX, pY, pZ)
    
    def removeMomentum(self, molecule):
    # Calculate linear momentum p for the molecule   
        totMass = 0.
        pX = 0.
        pY = 0.
        pZ = 0.
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            pX += atom.getVelocityX() * mass
            pY += atom.getVelocityY() * mass
            pZ += atom.getVelocityZ() * mass
    
        deltaVx = pX / totMass
        deltaVy = pY / totMass
        deltaVz = pZ / totMass
    
    # Remove linear momentum p for current system by shifting velocity 
    
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            vxnew = atom.getVelocityX() - deltaVx
            vynew = atom.getVelocityY() - deltaVy
            vznew = atom.getVelocityZ() - deltaVz
    
            atom.setVelocity(vxnew, vynew, vznew)
    
        return
    
    def calcPositionCM(self, molecule):
    # Compute position of center of mass of system.
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        rcmx = 0.; rcmy = 0.; rcmz = 0. 
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            rcmx += rx * mass 
            rcmy += ry * mass 
            rcmz += rz * mass 
    
        rcmx /= masstot
        rcmy /= masstot
        rcmz /= masstot
    
        return (rcmx, rcmy, rcmz)
    
    def calcVelocityCM(self, molecule):
    # Compute linear velocity of center of mass of system.
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        vcmx = 0.; vcmy = 0.; vcmz = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass 
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            vcmx += vx * mass 
            vcmy += vy * mass 
            vcmz += vz * mass 
    
        vcmx /= masstot
        vcmy /= masstot
        vcmz /= masstot
    
        # Compute translational kinetic energy of entire system.
        transKinEnergy = 0.5 * masstot * (vcmx ** 2 + vcmy ** 2 + vcmz ** 2)
    
        return (vcmx, vcmy, vcmz, transKinEnergy)
    
    def calcInertia(self, molecule, inertia):
    # Compute inertia tensor I.    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        rcmx, rcmy, rcmz = self.calcPositionCM(molecule)
    
        mxx = 0.; myy = 0.; mzz = 0.
        mxy = 0.; myz = 0.; mzx = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            xrel = rx - rcmx
            yrel = ry - rcmy
            zrel = rz - rcmz
            
            mxx += mass * xrel * xrel 
            myy += mass * yrel * yrel 
            mzz += mass * zrel * zrel 
            mxy += mass * xrel * yrel 
            myz += mass * yrel * zrel 
            mzx += mass * zrel * xrel 
    
        inertia[(0, 0)] =  myy + mzz 
        inertia[(0, 1)] = -mxy 
        inertia[(0, 2)] = -mzx 
        inertia[(1, 0)] = -mxy 
        inertia[(1, 1)] =  mxx + mzz 
        inertia[(1, 2)] = -myz 
        inertia[(2, 0)] = -mzx 
        inertia[(2, 1)] = -myz 
        inertia[(2, 2)] =  mxx + myy 
    
        return
    
    def calcAngularMomentum(self, molecule):
    # Compute angular momentum of entire system. L = m (R x V)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        rcmx = 0.; rcmy = 0.; rcmz = 0. 
        vcmx = 0.; vcmy = 0.; vcmz = 0.
        angMomX = 0.; angMomY = 0.; angMomZ = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            rcmx += rx * mass 
            rcmy += ry * mass 
            rcmz += rz * mass 
    
            vcmx += vx * mass 
            vcmy += vy * mass 
            vcmz += vz * mass 
    
            angMomX += mass * (ry * vz - rz * vy)
            angMomY += mass * (rz * vx - rx * vz)
            angMomZ += mass * (rx * vy - ry * vx)
    
        # Note that above rcmx, vcmx etc. are not normalized by total mass to improve performance.
        # Thus R x V below is divided by total mass rather than be multiplied. 
        angMomX -= (rcmy * vcmz - rcmz * vcmy) / masstot 
        angMomY -= (rcmz * vcmx - rcmx * vcmz) / masstot 
        angMomZ -= (rcmx * vcmy - rcmy * vcmx) / masstot 
    
        return (angMomX, angMomY, angMomZ)
    
    def calcAngularVelocity(self, molecule):
    # Compute angular velocity of entire system. 
        LAPY = LAPy()
        angMoment = [0.] * 3
        angMoment = self.calcAngularMomentum(molecule)
        print 'Angular momnet=', angMoment
    
        inertia = {}
        # Compute inertia tensor. 
        self.calcInertia(molecule, inertia)
        print 'Inertia=', inertia 
        # Invert inertia matrix.
        LAPY.gaussJordan(inertia)
        print 'Inertia-1=', inertia 
        # Compute angular velocity: omega = (inverse of I) * L 
        rotKinEnergy = 0.
        omega = [0.] * 3
        for i in range(3):
            for j in range(3):
                omega[i] += inertia[(i, j)] * angMoment[j]
    
            # Compute rotational kinetic energy of entire system.
            rotKinEnergy += omega[i] * angMoment[i]
    
        rotKinEnergy *= 0.5
    
        return (omega[0], omega[1], omega[2], rotKinEnergy)
    
    def removeTranslation(self, molecule):
    # Remove translation of entire system.    
        # Compute linear velocity of CM.
        vcmx, vcmy, vcmz, transKE = self.calcVelocityCM(molecule)

        if Control.printLevel > 1:            
            logFile = open(molecule.getName()+'.log', 'a')
            logFile.write('%37s %10.5e %10.5e %10.5e \n%37s %10.5e\n' %  \
                ('Linear velocity of CM:', vcmx, vcmy, vcmz, \
                'Translational kinetic energy(eV/mol):', transKE))
            logFile.close()
    
        # No need to remove if linear velocities are small.
        vcmNorm = vcmx ** 2 + vcmy ** 2 + vcmz ** 2
        if vcmNorm < 1.e-12: return 

        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            vx -= vcmx
            vy -= vcmy
            vz -= vcmz
    
            atom.setVelocity(vx, vy, vz)
    
        return
    
    def removeRotation(self, molecule):
    # Remove rotation of entire system.    
        # Compute center of mass.
        rcmX, rcmY, rcmZ = self.calcPositionCM(molecule)

        # Compute angular velocity.
        omegaX, omegaY, omegaZ, rotKE = self.calcAngularVelocity(molecule) 
        print 'Omega = ', omegaX, omegaY, omegaZ

        if Control.printLevel > 1:            
            logFile = open(molecule.getName()+'.log', 'a')
            logFile.write('%37s %10.5e %10.5e %10.5e \n%37s %10.5e\n' %  \
                ('Angular velocity of CM:', omegaX, omegaY, omegaZ, \
                'Rotational kinetic energy(eV/mol):', rotKE))
            logFile.close()
    
        # No need to remove if angular velocities are small.
        omegaNorm = omegaX ** 2 + omegaY ** 2 + omegaZ ** 2
        if omegaNorm < 1.e-9: return 

        numAtoms = molecule.numAtoms()    
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            rxrel = rx - rcmX
            ryrel = ry - rcmY
            rzrel = rz - rcmZ
    
            vx -= omegaY * rzrel - omegaZ * ryrel  
            vy -= omegaZ * rxrel - omegaX * rzrel  
            vz -= omegaX * ryrel - omegaY * rxrel  
            
            atom.setVelocity(vx, vy, vz)
            
        return
    
    def calcTorque(self, molecule):
    # Compute torque of entire system about center of mass. T = R x F 
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        rcmx, rcmy, rcmz = self.calcPositionCM(molecule) 
    
        torqueX = 0.; torqueY = 0.; torqueZ = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()
    
            rrx = rx - rcmx 
            rry = ry - rcmy 
            rrz = rz - rcmz 
    
            torqueX += rry * fz - rrz * fy
            torqueY += rrz * fx - rrx * fz 
            torqueZ += rrx * fy - rry * fx
    
        return (torqueX, torqueY, torqueZ)
    
    def outputTrj(self, molecule, trjFile, iteration=None):
        from control import Control
        
        natoms = molecule.numAtoms()

        trjFile.write(' %i\n' % natoms)

        if iteration is not None:
            trjFile.write(' No. %i\n' % iteration)

        for i in range(1, natoms+1):
            atom = molecule.getAtomWithNumber(i)
            x = atom.getX()
            y = atom.getY()
            z = atom.getZ()
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()
            # Note that output of velocity still use internal units here.
            chunk = '%2s %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f\n' %   \
                (atom.getElement(), x, y, z,  \
                             vx, vy, vz,  \
                             fx/Control.printEnergyUnit,  \
                             fy/Control.printEnergyUnit,  \
                             fz/Control.printEnergyUnit)

            trjFile.write(chunk)

        return

    def sumForce(self, molecule, iteration=None):
        from control import Control
        molName = molecule.getName()
        natoms = molecule.numAtoms()

        #velFile = open(molName+'_vel.dat', 'a')
        forceFile = open(molName+'_sumforce.dat', 'a')

        totForceX = 0.
        totForceY = 0.
        totForceZ = 0.
        for i in range(1, natoms+1):
            atom = molecule.getAtomWithNumber(i)
            x = atom.getX()
            y = atom.getY()
            z = atom.getZ()
            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            #velFile.write("%12.6f\n" % (atom.getVelocityX))
            #velFile.write("%12.6f\n" % (atom.getVelocityY))
            #velFile.write("%12.6f\n" % (atom.getVelocityZ))

            if atom.isMovable() == 1 and atom.getElement() != 'H' and  \
                z > Control.sumForceMinZ and z < Control.sumForceMaxZ:
                totForceX += fx
                totForceY += fy
                totForceZ += fz

        forceFile.write("%i %20.10e %20.10e %20.10e\n" % (iteration,  \
                             totForceX/Control.printEnergyUnit,  \
                             totForceY/Control.printEnergyUnit,  \
                             totForceZ/Control.printEnergyUnit))

        #velFile.close()
        forceFile.close()

        return

    def timer(self, molName, starttime, endtime):

        TIYEAR = endtime.year-starttime.year; TIMONTH = endtime.month-starttime.month
        TIDAY = endtime.day-starttime.day; TIHOUR = endtime.hour-starttime.hour
        TIMINUTE = endtime.minute-starttime.minute; TISECOND = endtime.second-starttime.second
        TIMICROSECOND = endtime.microsecond-starttime.microsecond
        if TIMICROSECOND < 0: TIMICROSECOND += 1000000; TISECOND -= 1
        if TISECOND < 0: TISECOND += 60; TIMINUTE -= 1
        if TIMINUTE < 0: TIMINUTE += 60; TIHOUR -= 1
        if TIHOUR < 0: TIHOUR += 24; TIDAY -= 1
        if TIDAY < 0: TIDAY += 30; TIMONTH -= 1
        if TIMONTH < 0: TIMONTH += 12; TIYEAR -= 1

        logFile = open(molName+'.log', 'a')
        logFile.write("CMDF started at "+str(starttime)+'\n')
        logFile.write("CMDF ended   at "+str(endtime)+'\n')
        logFile.write("CMDF lasted "+str(TIYEAR)+' years '+str(TIMONTH)+' months '+str(TIDAY) \
            +' days '+ str(TIHOUR)+' hours '+str(TIMINUTE)+' minutes '+str(TISECOND)+' seconds '  \
            +str(TIMICROSECOND)+' microseconds.\n')
        logFile.close()

        return (TIYEAR, TIMONTH, TIDAY, TIHOUR, TIMINUTE, TISECOND, TIMICROSECOND)

