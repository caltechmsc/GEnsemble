#!/usr/bin/env python

"""\
 ModMulti.py: PYTHON routines for multi-scale modeling

 This program is part of the CMDF.
 Copyright 2004 California Institute of Technology.  All Rights
 Reserved. Markus J. Buehler, mbuehler@wag.caltech.edu

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation provided that the above copyright notice
 and this complete notice appear in all copies.

 This program is distributed in the hope that it will be useful, and in
 no event shall California Institute of Technology be liable to any
 party for direct, indirect, special, incidental or consequential
 damages, including lost profits, arising out of the use of this
 software and its documentation, even if the California Institute of
 Technology has been advised of the possibility of such damage. The
 California Institute of Technology specifically disclaims any
 warranties, including the implied warranties or merchantability and
 fitness for a particular purpose. The software and documentation
 provided hereunder is on an AS IS basis, and the California Institute
 of Technology has no obligations to provide maintenance, support,
 updates, enhancements or modifications.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307
"""
  
#
# Assign weights spherically
#
def assignsphere_weights(molecule, x, y, z, R, bufDR, SF=5.0):
    import math
   
    rrr = 0.0000
    
    natoms = molecule.numAtoms()
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
    
        atom.setTmp(1, 0)
        atom.setTmp(2, 0)
        # equiv. to:    
        atom.setEngine(1,0)
        atom.setEngine(2,0)


        xx = atom.getX()
        yy = atom.getY()
        zz = atom.getZ()
        
        rrr = math.sqrt( (x-xx)**2 + (y-yy)**2 + (z-zz)**2 )
        
        
        
        weight = 0

        # case 1: atom is completely within inner radius
        if rrr < R:
            weight = 1
          
        # case 2: atom is completely within outer radius
        if rrr > (R + bufDR):
            weight = 0
          
        # case 3: atom is in the transition layer
        if rrr >= R  and rrr <= (R + bufDR):
            weight = 1 - rrr - R / bufDR
        
        
        atom.setWeight(1, weight)


        # this is the region for reax   
        if rrr < (R+bufDR+SF):
            atom.setTmp(1, 1)
            atom.setEngine(1,1)


        # this is the region for TERSOFF    
        if rrr > (R-SF):
            atom.setTmp(2, 1)
            atom.setEngine (2,1)
        
        atom.setWeight(2, 1.0 - weight)

        
        i += 1
    
    return

#
# Assign weights spherically
#
def assignsphere_weights_add(molecule, x,y,z, R, bufDR, SF=5.0):
    import math
   
    rrr = 0.0
    
    natoms = molecule.numAtoms()
    
    i = 1
    while i<= natoms:
        atom = molecule.getAtomWithNumber(i)
    
        xx = atom.getX()
        yy = atom.GetY()
        zz = atom.GetZ()
        
        rrr = math.sqrt( (x-xx)**2 + (y-yy)**2 + (z-zz)**2 )
        
        ow1 = atom.getWeight(1)
        ow2 = atom.getWeight(2)
        ##

        
        weight = 0

        # case 1: atom is completely within inner radius
        if rrr < R:
            weight = 1
          
        # case 2: atom is completely within outer radius
        if rrr > (R + bufDR):
            weight = max(0, ow1)
          
        # case 3: atom is in the transition layer
        if rrr >= R and rrr <= (R + bufDR):
            weight = 1 - (rrr-R) / bufDR
            weight = max(weight, ow1)
        
        atom.setWeight(1, weight)


        # this is the region for reax   
        if rrr < (R+bufDR+SF):
            atom.setTmp(1, 1)
            atom.setEngine(1,1)


        # this is the region for TERSOFF    
        #   if (rrr> (R-SF) ):
        #    atom.SetTmp(N2, 1)
        
        atom.setWeight(2, 1.0 - weight)

        
        i += 1
    
    return
  

## Assigns weights to all the atoms in a residue and the atoms around it
def assignresidue_weights(molecule, res, R, bufDR, SF=5.0):
    import math
   
    rrr=0.0000
   
    natoms = molecule.numAtoms()
   
    i = 1
    while i<=natoms:
        atom = molecule.getAtomWithNumber(i)
    
        atom.setTmp(1, 0)
        atom.setEngine(1,0)
        atom.setTmp(2, 1)
        atom.setEngine(2,1)
    
        atom.setWeight(1, 0)
        atom.setWeight(2, 1.0)
        i += 1
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        if atom.getResidueName() == res:
            assignsphere_weights_add(molecule, atom.getX(), atom.getY(), atom.getZ(), R, bufDR, SF)

        i += 1
    
    return

## -----------------------------------------------------------------------------
## 
## assign proper tag for molecule object depending in position of atoms
## UPPER PART=1
## 
## -----------------------------------------------------------------------------
def find_reg(molecule, xmin, xmax, ymin, ymax, zmin, zmax, E_thr, R, bufDR, SF=5.0):
    import math
   
    rrr = 0.0
    
    natoms = molecule.numAtoms()
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtom(i)
    
        xx = atom.getX()
        yy = atom.getY()
        zz = atom.getZ()
    
    
        if xx > xmin and xx < xmax and yy > ymin and yy < ymax and zz > zmin and zz < zmax:
            if atom.getPE() > E_thr:
                assignsphere_weights_add(molecule, xx, yy, zz, R, bufDR, SF)
       
    
        i += 1
    
    return

  
## -----------------------------------------------------------------------------
## 
## assign proper tag for molecule object depending in position of atoms
## UPPER PART=1
## 
## -----------------------------------------------------------------------------
def init_weights(molecule, standard):
    import math
   
    rrr = 0.0
    
    natoms = molecule.numAtoms()
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)

        jj = 1
        while jj <= 10:
            atom.setTmp(jj, 0.)
            atom.setEngine(jj, 0)
            atom.setWeight(jj, 0.)
            if jj == standard:
                atom.setTmp(jj, 1)
                atom.setEngine(jj, 1)
                atom.setWeight(jj, 1.0)
            jj += 1
    
        i +=1
    
    return
## -----------------------------------------------------------------------------
## 
## assign proper tag for molecule object depending in position of atoms
## UPPER PART=1
## 
## -----------------------------------------------------------------------------
def assignweights(molecule, yy, bufy, SF=5.0):
    import math

    natoms = molecule.numAtoms()
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        atom.setTmp(1, 0)
        atom.setTmp(2, 0)
        atom.setEngine (1,0)
        atom.setEngine (2,0)

        ya = atom.getY()
        if ya <= yy: weight = 0
        if ya >= (yy+bufy): weight = 1
        if ya <= (yy+bufy) and ya >= yy:
            ddy = (ya-yy) / bufy
            weight = ddy
        
        atom.setWeight(1, weight)
        atom.setWeight(2, 1.0 - weight)
        
        i += 1
    
    
    if ya< (yy+bufy+SF):
        atom.setTmp(2, 1)
        atom.setEngine(2,1)

    # this is the region for    
    if ya > (yy-SF):
        atom.setTmp(1, 1)
        atom.setEngine(1, 1)
   
    return
   
### -----------------------------------------------------------------------------
## assign weight 2 for a small strip inside. the strip width is given by width and the center by yy
## 
## 
## assign proper tag for molecule object depending in position of atoms
## UPPER PART=1
## -----------------------------------------------------------------------------
def assignmidweightsold(molecule, direc, ymin, ymax, bufy, SF=5.00):

    natoms = molecule.numAtoms()
   
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        atom.setTmp(1, 0)
        atom.setTmp(2, 1) # standard
        atom.setWeight (1, 0.00)
        atom.setWeight (2, 0.00)
        
        if direc == 1: ya = atom.getX()
        if direc == 2: ya = atom.getY()
        if direc == 3: ya = atom.getZ()
        
        numss = atom.getAtomicNumber()
    
        # this is the region for reax   
        if ya > (ymin-bufy-SF) and ya < (ymax+bufy+SF):
            atom.setTmp(1, 1)

        weight = 1
        
        if ya < (ymin-bufy): 
            weight = 0
        if ya > (ymax+bufy): 
            weight = 0
        
        if ya >= ymin and ya <= ymax: 
            weight = 1
        
        # now handle transition elements
        if ya <= (ymax+bufy) and ya >= ymax:
            ddy = (ya - ymax) / bufy
            weight = 1 - ddy
        
        if ya >= (ymin-bufy) and ya <= ymin:
            ddy = (ya - (ymin-bufy)) / bufy
            weight = ddy

        atom.setWeight (1, weight)
        
        # this is the region for TERSOFF    
        if ya < (ymin+SF) or ya > (ymax-SF):
            #if numss==29:
            atom.SetTmp(2, 1)
        if ya < (ymax+SF+bufy) and ya > (ymin-SF-bufy):
            #if numss==29:
            atom.SetTmp(1, 1)
        
        
        # need to change the weight so that it is zero for the safety layer
        #if (ya>= (ymin)) and (ya<= (ymin+SF)):
        #   weight = 1
        #if (ya>= (ymax-SF)) and (ya<= (ymax)):
        #   weight = 1
          
        atom.setWeight(2, 1.0 - weight)

        i += 1
       
    return


def assignmidweights_si(molecule, direc, ymin, ymax, bufy, SF=5.00):

    natoms = molecule.numAtoms()
   
    print "buffer zone... safety layer size", bufy, SF
   
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        atom.setTmp(1, 0)
        atom.setTmp(2, 0)
        atom.setEngine (1, 0)
        atom.setEngine (2, 0)
        
        if direc == 1: ya = atom.getX()
        if direc == 2: ya = atom.getY()
        if direc == 3: ya = atom.getZ()
        
        numss = atom.getAtomicNumber()
        
        
        # this is the region for reax   
        if ya >= (ymin-bufy-SF) and ya <= (ymax+bufy+SF):
            atom.setTmp(1, 1)
            atom.setEngine(1,1)
        # this is the region for TERSOFF    
        if ya <= (ymin+SF) or ya >= (ymax-SF):
            atom.setTmp(2, 1)
            atom.setEngine(2,1)

        # 1 means it is ReaxFF
        weight = 1
        
        if ya < (ymin-bufy): 
            weight = 0
        if ya > (ymax+bufy): 
            weight = 0
        
        if ya >= ymin and ya <= ymax: 
            weight = 1
        
        # now handle transition elements
        if ya <= (ymax+bufy) and ya >= ymax:
            ddy = (ya - ymax) / bufy
            weight = 1 - ddy
        
        if ya >= (ymin-bufy) and ya <= ymin:
            ddy = (ya-(ymin-bufy)) / bufy
            weight = ddy

        atom.setWeight(1, weight)
        atom.setWeight(2, 1.0 - weight)

        i=i+1
    
    return
  

def assignmidweights(molecule, direc, ymin, ymax, bufy=5.00, SF=5.00,N1=1,N2=2):

    natoms = molecule.numAtoms()
   
    print "buffer zone... safety layer size", bufy, SF
   
    i = 1
    while i <= natoms:
        atom = molecule.GetAtomWithNumber(i)
        atom.setTmp(N1, 0)
        atom.setTmp(N2, 1)
        atom.setEngine (N1,0)
        atom.setEngine (N2,1)
        
        if direc == 1: ya = atom.getX()
        if direc == 2: ya = atom.getY()
        if direc == 3: ya = atom.getZ()
        
        #numss=atom.GetAtomicNum ()
        
        
        # this is the region for reax   
        if ya >= (ymin-bufy-SF) and ya <= (ymax+bufy+SF):
            atom.setTmp(N1, 1)
            atom.setEngine (N1,1)
        # this is the region for TERSOFF    
        if ya <= (ymin+SF) or ya >= (ymax-SF):
            atom.setTmp(N2, 1)
            atom.setEngine (N2,1)


        # 1 means it is ReaxFF
        weight = 1
        
        if ya< (ymin-bufy): 
            weight = 0
        if ya > (ymax+bufy): 
            weight = 0
        
        if ya >= ymin and ya <= ymax: 
            weight = 1
        
        # now handle transition elements
        if ya <= (ymax+bufy) and ya >= ymax:
            ddy = (ya-ymax) / bufy
            weight = 1 - ddy
        
        if ya >= (ymin-bufy) and ya <= ymin:
            ddy = (ya-(ymin-bufy)) / bufy
            weight = ddy

        atom.setWeight(N1, weight)
        atom.setWeight(N2, 1.0 - weight)


        i += 1
       
    return

# -----------------------------------------------------------------------------
## 
## 
## UPPER PART up=1
## -----------------------------------------------------------------------------
def assignzeroweights(molecule, yy, up, iweight):

    natoms = molecule.numAtoms()
   
    i = 1
    while i<= natoms:
        atom = molecule.GetAtomWithNumber(i)
        
        ya = atom.getY()
        
        weight = 1
        
        if ya > yy and up == 1: weight = 0
        if ya < yy and up == 0: weight = 0
        
        atom.setWeight(iweight, weight)
        
        i += 1
    
    return
## -----------------------------------------------------------------------------
## 
## 
## UPPER PART up=1
## -----------------------------------------------------------------------------
def strainMolecule(molecule, sx, sy, sz):

    natoms = molecule.numAtoms()
   
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        
        x = atom.getX()
        y = atom.getY()
        z = atom.getZ()
        
        atom.setPositions(x*sx, y*sy, z*sz)
        
        i += 1
       
    return

## -----------------------------------------------------------------------------
## 
## 
##  
## -----------------------------------------------------------------------------
def copyMoleculeZ(molecule, sz, Nz):

    natoms = molecule.numAtoms()
   
   
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        
        x = atom.getX()
        y = atom.getY()
        z = atom.getZ()
        
        ii = 1
        while ii <= Nz:
        
            atomn = molecule.newAtom()
            atomn.setPosition(x, y, z+ii*sz)
            atomn.setAtomicNumber(atom.getAtomicNumber())
            ii += 1
          
        i += 1
    
    print "now have %d atoms...." % molecule.numAtoms() 
    print "cell size = ", (Nz+1)*sz
    return
    
## -----------------------------------------------------------------------------
## 
## Generate two new OBmol objects depending on how the weights are chosen.
##
## atomdict is a dictionary that stores information 
##    for force updates
##
## -----------------------------------------------------------------------------
def divide(molecule, molecule1, molecule2):

    natoms = molecule.numAtoms()
  
   
    # ####################  
    # 
    #
    #
    # STRATEGY: First, determine to which regime each atom belong
    # this is done using the weight that was determined earlier
    # then put the atom into new molecule objects according to its weight
    # 
    # after  this is done have two objects. need to add a "tag" in the "large object" 
    # which atom belongs to which global atom. 
    #
    # this is critical to add forces back together in the end. 
    
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
    
    
    # here set up dictionary so we can later find the proper atom
    #    based on the GID we find in each of the two subsystems
    #
    #atomdict[atom.GetGID()] = atom

    
    
        if atom.getTmp(1) == 1:
            wwatom = molecule1.newAtom()
            wwatom.setAtomicNumber(atom.getAtomicNumber())
        
            wwatom.setPositon(atom.getX(), atom.getY(), atom.getZ())
            wwatom.setWeight(1, atom.getWeight(1))
            wwatom.setWeight(2, atom.getWeight(2))
            wwatom.setWeight(3, atom.getWeight(3))
            
            # this is used to point back to the atom in the global molecule object
            wwatom.setGID(i)
            ##
            
            #print "** info: ",  wwatom.GetAtomicMass (),  wwatom.GetAtomicNum(), atom.GetWeight(1), atom.GetWeight(2) 
        
        
        if atom.getTmp(2) == 1:
            wwatom = molecule2.newAtom()
            wwatom.setAtomicNumber(atom.getAtomicNumber())

            #print wwatom.GetAtomicNum(), atom.GetAtomicNum ()

            wwatom.setPosition(atom.getX(), atom.getY(), atom.getZ() )
            wwatom.setWeight(1, atom.getWeight(1))
            wwatom.setWeight(2, atom.getWeight(2))
            wwatom.setWeight(3, atom.getWeight(3))

            wwatom.setGID(i)

        i += 1
    
    

    return

## -----------------------------------------------------------------------------
## 
 
##
## -----------------------------------------------------------------------------
def CutRect(molecule, xmin, xmax, ymin, ymax):
    import modbabel 
    natoms = molecule.numAtoms()
  
    mol = modbabel.Molecule()
   
     
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
    
        x = atom.getX()
        y = atom.getY()
        z = atom.getZ()
        
        if not (x > xmin and x < xmax and y > ymin and y < ymax):
            natom = mol.newAtom()
            natom.setPosition(x, y, z)
            natom.setGID( atom.getGID())
            natom.setAtomicNumber(atom.getAtomicNumber())
            
        i=i+1
    
    return mol
   
 ## -----------------------------------------------------------------------------
## 
 
##
## -----------------------------------------------------------------------------
def ExtractType(molecule, atype):
    import modbabel 

    natoms = molecule.numAtoms()
  
    mol = modbabel.Molecule()
   
   
     
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        x = atom.getX()
        y = atom.getY()
        z = atom.getZ()
        
        aatype = atom.getAtomicNumber()
        
        if aatype == atype:
            natom = mol.newAtom()
            natom.setPosition(x, y, z)
            natom.setGID(atom.getGID())
            natom.setAtomicNumber(atom.getAtomicNumber())
            
        
        i += 1
    
    
   
    print "new molecule has %d atoms" % (i-1)
   
    return mol
  
## -----------------------------------------------------------------------------
## Put two new OBmol objects together
##
##    for force updates
##    NOTE: if oforce=0: old forces set to zero, otherwise forces are added to whatever is already in molecule
## -----------------------------------------------------------------------------
def forcecombine(molecule, molecule1, molecule2, oforce=0.):

   
    natoms = molecule.numAtoms()

    if oforce == 0:
        i = 1
        while i <= natoms:
            oatom = molecule.getAtomWithNumber(i)
            oatom.setForceX( 0.)
            oatom.setForceY( 0.) 
            oatom.setForceZ( 0.)
            i += 1
   
    natoms = molecule1.numAtoms()
    i = 1
    while i<= natoms:
        atom = molecule1.getAtomWithNumber(i)
        oatom = molecule.getAtomWithNumber(atom.getGID())

         
        fx = atom.getForceX() * oatom.getWeight(1) * (1.0 - oatom.getFixedX())
        fy = atom.getForceY() * oatom.getWeight(1) * (1.0 - oatom.getFixedY())
        fz = atom.getForceZ() * oatom.getWeight(1) * (1.0 - oatom.getFixedZ())
         
        oatom.setForceX(oatom.getForceX() + fx)
        oatom.setForceY(oatom.getForceY() + fy)
        oatom.setForceZ(oatom.getForceZ() + fz)
                 
        i += 1
    
    natoms = molecule2.numAtoms()
    i = 1
    while i <= natoms:
        atom = molecule2.getAtomWithNumber(i)
        
        oatom = molecule.getAtomWithNumber(atom.getGID())
          
        fx = atom.getForceX() * oatom.getWeight(2) * (1.0 - oatom.getFixedX())
        fy = atom.getForceY() * oatom.getWeight(2) * (1.0 - oatom.getFixedY()) 
        fz = atom.getForceZ() * oatom.getWeight(2) * (1.0 - oatom.getFixedZ()) 

        oatom.setForceX(oatom.getForceX() + fx)
        oatom.setForceY(oatom.getForceY() + fy)
        oatom.setForceZ(oatom.getForceZ() + fz)
        
        i += 1
  
    return


## -----------------------------------------------------------------------------
## Put two new OBmol objects together
##
##    for force updates
##    NOTE: if oforce=0: old forces set to zero, otherwise forces are added to whatever is already in molecule
## -----------------------------------------------------------------------------
def forcecombine_li(molecule, molecule1, molecule2, oforce=0.):
   
    x_list = {}
    y_list = {}
    z_list = {}
    
    natoms = molecule1.numAtoms()
    i = 1
    while i <= natoms:
        atom = molecule1.getAtomWithNumber(i)
        gid = atom.getGID()
        oatom = molecule.getAtomWithNumber(gid)

        x_list[gid] = atom.getForceX() * oatom.getWeight(1) * (1.0 - oatom.getFixedX())
        y_list[gid] = atom.getForceY() * oatom.getWeight(1) * (1.0 - oatom.getFixedY())
        z_list[gid] = atom.getForceZ() * oatom.getWeight(1) * (1.0 - oatom.getFixedZ())
                    
        i += 1
    
    natoms = molecule2.numAtoms()
    i = 1
    while i <= natoms:
        atom = molecule2.getAtomWithNumber(i)
        gid = atom.getGID()
        oatom = molecule.getAtomWithNumber(gid)
        
        if not x_list.has_key(gid):
            x_list[gid] = 0.0
            y_list[gid] = 0.0
            z_list[gid] = 0.0
          
        x_list[gid] = x_list[gid] + atom.getForceX() * oatom.GetWeight(2) * (1.0 - oatom.getFixedX())
        y_list[gid] = y_list[gid] + atom.getForceY() * oatom.GetWeight(2) * (1.0 - oatom.getFixedY())
        z_list[gid] = z_list[gid] + atom.getForceZ() * oatom.GetWeight(2) * (1.0 - oatom.getFixedZ())
        
        i += 1

    natoms = molecule.numAtoms()

    if oforce == 0:
        i = 1
        while i <= natoms:
            atom = molecule.getAtomWithNumber(i) 
            oatom = molecule.getAtomWithNumber(atom.getGID())
            oatom.setForceX(0.0)
            oatom.setForceY(0.0) 
            oatom.setForceZ(0.0)
            i += 1

    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i) 
        gid = atom.getGID()
        oatom = molecule.getAtomWithNumber(gid)

        if not x_list.has_key(gid):
            oatom.setForceX(0)
            oatom.setForceY(0)
            oatom.setForceZ(0)
        else:
            oatom.setForceX(x_list[gid])
            oatom.setForceY(y_list[gid])
            oatom.setForceZ(z_list[gid])

        i += 1
  
    return
   
## -----------------------------------------------------------------------------
## update the xyz in the local structures from the global data
##
##    for force updates
##    NOTE: if oforce=0: old forces set to zero, otherwise forces are added to whatever is already in molecule
## -----------------------------------------------------------------------------
def xyzupdate (moleule, molecule1, molecule2, oforce=0):

    natoms = molecule1.numAtoms()
    i = 1
    while i <= natoms:
        atom = molecule1.getAtomWithNumber(i)
        oatom = molecule.getAtomWithNumber(atom.getGID())
        atom.setPosition(oatom.getX(), oatom.getY(), oatom.getZ()) 
        i += 1
    
    natoms = molecule2.numAtoms()
    i = 1
    while i <= natoms:
        atom = molecule2.getAtomWithNumber(i)
        oatom = molecule.getAtomWithNumber(atom.getGID())
        atom.SetPosition(oatom.getX(), oatom.getY(), oatom.getZ()) 
        i += 1
    
    return

#
# Just for compatibility...
#


def dumpModbabel(molecule, newfile):

    natoms = molecule.numAtoms()
    newlines = []

    i = 1

    chunk = "#### format: i, atomic number, type, x, y, z, fx, fy, fz, mass, atomic number, weight.1, weight.2, weight.3, GID, strain energy fixed_x,y,z velx,y,z #### system contains %d atoms \n" % natoms
    newlines.append(chunk)
   
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        chunk = "%5d %5d %s %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %5d %9.4f %3d %3d %3d %9.4f %9.4f %9.4f\n" % (i, atom.getAtomicNumber(), atom.getElement(), atom.getX(), atom.getY(), atom.getZ(), atom.getForceX(), atom.getForceY(), atom.getForceZ(), atom.getAtomicMass(), atom.getWeight(1), atom.getWeight(2), atom.getWeight(3),atom.getGID(), atom.getPE(), atom.getFixedX(), atom.getFixedY(), atom.getFixedZ(), atom.getVelocityX(), atom.getVelocityY(), atom.getVelocityZ() )

        newlines.append(chunk)
       
        i += 1
  
    f = open(newfile,'w')
    f.writelines(newlines)
    f.close()

    return


def dumpModbabelToXYZ(molecule, filename):

    natoms = molecule.numAtoms()
    newlines = []

    chunk = '   %6d \n' % (natoms)
    newlines.append(chunk)
    chunk = '  XYZ file generated by CMDF\n' 
    newlines.append(chunk)
       
    i=1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        chunk = "%2s %9.5f %9.5f %9.5f\n" %  (atom.getElement () , atom.getX(), atom.getY(), atom.getZ() )
        newlines.append(chunk)
        i += 1
   
    f = open(filename,'w')
    f.writelines(newlines)
    f.close()
    return


def writexyz(f, molecule, iteration=None):
    natoms = molecule.numAtoms()

    f.write('%i\n' % natoms)

    if iteration is not None:
        f.write('# Iteration %i\n' % iteration)


    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        chunk = '%2s %12.6f %12.6f %12.6f\n' %  (atom.getElement(), atom.getX(), atom.getY(), atom.getZ())
        f.write(chunk)
        i += 1
   
    return


"""
def writeEnergy(energy, filename, iteration):
    f = open(filename, 'a')
    s = '%i %5.10f\n' % (iteration, energy)
    f.write(s)
    f.close()
    return
"""


def writeToFile(f, value, iteration=None):
    import types
    dataTypes = {types.FloatType: '%5.10f', types.IntType: '%i', 
                 types.LongType: '%i', types.StringType: '%s' }
    if dataTypes.has_key(type(value)):
        formatString = dataTypes[type(value)]

    if iteration is not None: 
        s = '%i ' + formatString + '\n'
        s = s % (iteration, value)
    else:
        s = formatString + '\n' 
        s = s % value
    f.write(s)
    return


def dumpModbabelResidueToXYZ(molecule, res, newfile):

    atoms_tot = molecule.numAtoms()
    newlines = []
    atoms_res = 0

    i = 1
    while i <= atoms_tot:
    
        atom = molecule.getAtomWithNumber(i)
        if atom.getResidueName() == res:
            chunk = "%2s %9.5f %9.5f %9.5f\n" %  (atom.getElement() , atom.getX(), atom.getY(), atom.getZ())
            newlines.append(chunk)
            atoms_res = atoms_res + 1
        i += 1
    
    f = open(newfile,'w')
    f.writelines('   %6d \n  XYZ file generated by CMDF\n' % (atoms_res))
    f.writelines(newlines)
    f.close()

    return

