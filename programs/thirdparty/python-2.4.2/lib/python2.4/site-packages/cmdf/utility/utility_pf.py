#####################################################################################
#                                                                                   #
#  Utility class consists of many useful methods often used in other main processes.#
#  This is Python/Fortran hybrid code using array passing scheme. It should do the  #
#  the same job as pure Python version with improved performance.                   #
#                                                                                   #
#  calcXXX          : calculate some properties.                                    #
#                                                                                   #
# Created on 02/27/06, last revision on 06/04/06. yi                                #
#                                                                                   #
#####################################################################################

import sys
import os, os.path
import numpy
from math import sqrt
#from cmdf.utility.control import Control
from cmdf.utility.unit import Unit
from cmdf.utility.utility_f import calcpositioncm, calcvelocitycm, calcangularmomentum,  \
        calcinertia, calckinenergysum, calcstresstensor, symstresstensor, totforce
#from cmdf.utility.lapy import LaPy 
from cmdf.dynamics.integrator_pf import VelocityVerlet_f, VelocityVerletAH, VelocityVerletPRH
from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3

class Utility:

    def setMBvelocity(self, imove, masses, v, ttarget, gaussian):
    # Assign velocity from Maxwell-Boltzmann distribution acoording to temperature and mass.
    # The MB distribution has standard deviation sigma and mean miu.
        unit = Unit()
        numAtoms = len(masses)

        miu = 0.  # zero mean
        kbt = unit.KB * ttarget  # Kb*T    
        vmb = numpy.zeros(3, numpy.Float)
        for i in range(numAtoms):
            if imove[i] != 0:
                continue

            sigma = sqrt(kbt / masses[i])  # Standard deviation of MB dist.: sigma = sqrt(Kb*T/m)
            if (gaussian is Gaussian1 or gaussian is Gaussian2):
                gauss = gaussian(sigma, miu) 
                for j in range(3):
                    vgaus = gauss.run()  # Assign velocity from Gaussian(MB) distribution.
                    vmb[j] = vgaus
            elif (gaussian is Gaussian3):
                sigmaVec = numpy.array([sigma, sigma, sigma], numpy.Float)
                gauss = gaussian(sigmaVec, miu) 
                vmb = gauss.run(3)

            i3  = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            v[i3]  = vmb[0]  # Update velocity
            v[i31] = vmb[1]  
            v[i32] = vmb[2]  

        return v

    def setRanVelocity(self, degFree, imove, masses, v, ttarget):
    # Assign velocities from random distribution according to temperature and mass. 
        ran = Random1()
        unit = Unit()

        numAtoms = len(masses) 
        kesum = 0.
        for i in range(numAtoms):
            if imove[i] != 0:
                continue

            i3  = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            v[i3]  = 1. - 2. * ran.run()
            v[i31] = 1. - 2. * ran.run()
            v[i32] = 1. - 2. * ran.run()

            kesum += masses[i] * (v[i3] ** 2. + v[i31] ** 2. + v[i32] ** 2.)

        temp = kesum / (unit.KB * degFree)
        scale = sqrt(ttarget / temp)
        # Scale velocities according to target temperature.
        v = v * scale

        return v 

    def randomVector(self):
    # Generates a random vector on a unit sphere.
        #from math import sqrt
        RAN = Random3()
    
        ranvec = [0.] * 3
        n = 2   
        ransq = 2.
        while (ransq >= 1):
            ranv = RAN.run(n)  # Generate two random numbers
            ranum1 = 1. - 2. * ranv[0]
            ranum2 = 1. - 2. * ranv[1]
            ransq = ranum1 * ranum1 + ranum2 * ranum2
        ranh = 2. * sqrt(1. - ransq)
        ranvec[0] = ranum1 * ranh
        ranvec[1] = ranum2 * ranh
        ranvec[2] = 1. - 2. * ransq
    
        return ranvec
    
    def calcDistance(self, molecule, numA, numB):
    # Compute the distance between atom A nad B. 
        #from math import sqrt

        atom1 = molecule.getAtomWithNumber(numA)    
        atom2 = molecule.getAtomWithNumber(numB)    

        x1 = atom1.getX() 
        y1 = atom1.getY() 
        z1 = atom1.getZ() 

        x2 = atom2.getX() 
        y2 = atom2.getY() 
        z2 = atom2.getZ() 

        dist12 = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) 

        return dist12

    def calcDistance2(self, molecule, numA, numB):
    # Compute the distance square between atom A nad B. 
        atom1 = molecule.getAtomWithNumber(numA)    
        atom2 = molecule.getAtomWithNumber(numB)    

        x1 = atom1.getX() 
        y1 = atom1.getY() 
        z1 = atom1.getZ() 

        x2 = atom2.getX() 
        y2 = atom2.getY() 
        z2 = atom2.getZ() 

        dist12sq = (x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2 

        return dist12sq

    def calcVolume(self, cellDim, integrator):

        if (integrator is VelocityVerletAH):
            volume = 2.71828 ** (system.getDimension() * self.xah)
        elif (integrator is VelocityVerletPRH):
            volume = self.matDet(self.box)
        else:
            # More general form V = a . b X c
            volume = cellDim[0] * cellDim[1] * cellDim[2]

        return volume

    def calcPress(self, cellDim, mass, r, v, f, integrator):
        # Initialize stress tensor (3*3)
        #stress = numpy.zeros([3,3], numpy.Float)

        # Compute stress tensor.
        stress = calcstresstensor(mass, r, v, f)  

        # Compute instantaneous pressure (trace of stress tensor).
        volume = self.calcVolume(cellDim, integrator)
        stress = stress / volume
        press = (stress[(0, 0)] + stress[(1, 1)] + stress[(2, 2)]) / 3. 

        return press

    def calcStress(self, cellDim, mass, r, v, f, integrator):
    # Compute stress tensor (P*V).
        # Initialize stress tensor (3*3)
        #stress = numpy.zeros([3,3], numpy.Float)

        # Compute stress tensor.
        stress = calcstresstensor(mass, r, v, f)

        # Symmetrize the stress tensor to eliminate cell rotation.
        stress = symstresstensor(stress)

        return stress

    def calcKinEnergyBox(self, bmass, vbox):        
    # Compute total kinetic energy for box.

        kinEnergyBox = 0.
        for i in [1, 2, 3]: 
            for j in [1, 2, 3]:
                kinEnergyBox += vbox[(i, j)] ** 2                

        kinEnergyBox = 0.5 * bmass * kinEnergyBox

        return kinEnergyBox

    # Next function can be replaced by calcPositionCM.
    def calcCM1(self, molecule):
    # Calculate center of mass for the molecule
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += atom.getX() * mass
            cmY += atom.getY() * mass
            cmZ += atom.getZ() * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
        return (cmX, cmY, cmZ)
    
    def calcCM2(self, molecule, rx, ry, rz):
    # Calculate center of mass for the system (rx, ry, rz)
    #This allows one to calculate CM for a system whose coordinates differ from those in data model
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += rx[i] * mass
            cmY += ry[i] * mass
            cmZ += rz[i] * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
        return (cmX, cmY, cmZ)
    
    def translateCM1(self, molecule, cmref):
    # Translate the center of mass of the "molecule" to a reference cmref.
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
    # Calculate CM for current system
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += atom.getX() * mass
            cmY += atom.getY() * mass
            cmZ += atom.getZ() * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
    # Translate the system back to the reference CM: cmref
        delatX = cmX - cmref[0]
        delatY = cmY - cmref[1]
        delatZ = cmZ - cmref[2]
    
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            Xnew = atom.getX() - delatX
            Ynew = atom.getY() - delatY
            Znew = atom.getZ() - delatZ
    
            atom.setPosition(Xnew, Ynew, Znew)  #Update coordinate of molecule
    
        return
    
    def translateCM2(self, molecule, rx, ry, rz, cmref):
    # Translate the center of mass of the "system" (rx, ry, rz) to a reference cmref
        totMass = 0.
        cmX = 0.
        cmY = 0.
        cmZ = 0.
    
    # Calculate CM for current system
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            cmX += rx[i] * mass
            cmY += ry[i] * mass
            cmZ += rz[i] * mass
    
        cmX = cmX / totMass
        cmY = cmY / totMass
        cmZ = cmZ / totMass
    
    # Translate the system back to the reference CM: cmref
        delatX = cmX - cmref[0]
        delatY = cmY - cmref[1]
        delatZ = cmZ - cmref[2]
    
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            rx[i] = rx[i] - delatX
            ry[i] = ry[i] - delatY
            rz[i] = rz[i] - delatZ
    
        return

    def calcKinEnergyTen(self, molecule, kinEnergyTen):
        #Compute total kinetic energy and KE tensor.
    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kinEnergySum = 0.
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                kinEnergyTen[(i, j)] = 0.

        v = {}
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            v[1] = atom.getVelocityX()
            v[2] = atom.getVelocityY()
            v[3] = atom.getVelocityZ()
            factor = 0.5 * mass
            for j in [1, 2, 3]: 
                for k in [1, 2, 3]:
                    kinEnergyTen[(j, k)] += factor * v[j] * v[k] 

            kinEnergySum += mass * (atom.getVelocityX()**2 + 
                        atom.getVelocityY()**2 + atom.getVelocityZ()**2)

        kinEnergy = 0.5 * kinEnergySum 
    
        kinEnergyTot = kinEnergyTen[(1, 1)] + kinEnergyTen[(2, 2)] + kinEnergyTen[(3, 3)]

        if (abs(kinEnergy - kinEnergyTot) > 1.e-3):
            print 'Warning! calcKinEnergyTen: kinetic energies are not consistent.'
            return

        return kinEnergyTot

    def calcKinEnergy(self, mass, v):
        kinEnergySum = calckinenergysum(mass, v)

        kinEnergy = 0.5 * kinEnergySum 
    
        return kinEnergy
    
    def calcTemp(self, degFree, mass, v):
        unit = Unit()
    
        #kinEnergySum = 0.
        kinEnergySum = calckinenergysum(mass, v)

        temp = kinEnergySum / (unit.KB * degFree)
    
        return temp
    
    def calcKinEnergyTemp(self, degFree, mass, v):
        unit = Unit()
    
        #kinEnergySum = 0.
        kinEnergySum = calckinenergysum(mass, v)

        temp = kinEnergySum / (unit.KB * degFree)

        kinEnergy = 0.5 * kinEnergySum 
    
        return kinEnergy, temp
    
    """
    def calcOldKinEnergyTemp(self, molecule):
    # Compute KE and temperature using OldVelocity in Leap Frog integration.
        #from math import sqrt
        UNIT = Unit()
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        kinEnergySum = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            
            kinEnergySum += mass * (atom.getOldVelocityX() ** 2 + 
                                    atom.getOldVelocityY() ** 2 + 
                                    atom.getOldVelocityZ() ** 2 )
    
        temp = kinEnergySum/(UNIT.KB * molecule.getDegFree())

        kinEnergy = 0.5 * kinEnergySum 
    
        return (kinEnergy, temp)
    """

    def calcRMSforce(self, molecule):
        #from math import sqrt

        forceSquareSum = 0.
        numAtoms = molecule.numAtoms()
        for i in range(1, numAtoms+1):
            atom = molecule.getAtomWithNumber(i)

            forceSquareSum += atom.getForceX()**2 + atom.getForceY()**2 + atom.getForceZ()**2

        rmsforce = sqrt(forceSquareSum / molecule.getDegFree())

        return rmsforce

    def calcRMScoord(self, molecule):
        #from math import sqrt

        coordSquareSum = 0.
        numAtoms = molecule.numAtoms()
        for i in range(1, numAtoms+1):
            atom = molecule.getAtomWithNumber(i)
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()

            rxold = atom.getOldX()
            ryold = atom.getOldY()
            rzold = atom.getOldZ()

            coordSquareSum += (rx - rxold)**2 + (ry - ryold)**2 + (rz - rzold)**2

        rmscoord = sqrt(coordSquareSum / molecule.getDegFree())

        return rmscoord

    # Next function is similar to calcRMScoord above except explicitly asking for coordinates.
    def calcRMScoordinate(self, numAtoms, xnew, ynew, znew, xold, yold, zold):
        #from math import sqrt

        coordSquareSum = 0.
        for i in range(1, numAtoms+1):
            coordSquareSum += (xnew[i] - xold[i])**2 + (ynew[i] - yold[i])**2 + (znew[i] - zold[i])**2

        ### Note no constraints considered yet for dof.
        ### degFree is 3 * Nmovable in minimization.
        degFree = 3. * numAtoms - 6
        rmscoord = sqrt(coordSquareSum / degFree)

        return rmscoord

    def calcMomentum(self, molecule):
    # Calculate linear momentum p for the molecule   
        totMass = 0.
        pX = 0.
        pY = 0.
        pZ = 0.
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            pX += atom.getVelocityX() * mass
            pY += atom.getVelocityY() * mass
            pZ += atom.getVelocityZ() * mass
    
        pX = pX / totMass
        pY = pY / totMass
        pZ = pZ / totMass
    
        return (pX, pY, pZ)
    
    def removeMomentum(self, molecule):
    # Calculate linear momentum p for the molecule   
        totMass = 0.
        pX = 0.
        pY = 0.
        pZ = 0.
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            mass = atom.getAtomicMass()
            totMass += mass
    
            pX += atom.getVelocityX() * mass
            pY += atom.getVelocityY() * mass
            pZ += atom.getVelocityZ() * mass
    
        deltaVx = pX / totMass
        deltaVy = pY / totMass
        deltaVz = pZ / totMass
    
    # Remove linear momentum p for current system by shifting velocity 
    
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            vxnew = atom.getVelocityX() - deltaVx
            vynew = atom.getVelocityY() - deltaVy
            vznew = atom.getVelocityZ() - deltaVz
    
            atom.setVelocity(vxnew, vynew, vznew)
    
        return

    """
    #The following method is replaced by a Fortran version in utility.f. 
    
    def calcPositionCM(self, molecule):
    # Compute position of center of mass of system.
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        rcmx = 0.; rcmy = 0.; rcmz = 0. 
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            rcmx += rx * mass 
            rcmy += ry * mass 
            rcmz += rz * mass 
    
        rcmx /= masstot
        rcmy /= masstot
        rcmz /= masstot
    
        return (rcmx, rcmy, rcmz)
    
    def calcVelocityCM(self, molecule):
    # Compute linear velocity of center of mass of system.
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        vcmx = 0.; vcmy = 0.; vcmz = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass 
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            vcmx += vx * mass 
            vcmy += vy * mass 
            vcmz += vz * mass 
    
        vcmx /= masstot
        vcmy /= masstot
        vcmz /= masstot
    
        # Compute translational kinetic energy of entire system.
        transKinEnergy = 0.5 * masstot * (vcmx ** 2 + vcmy ** 2 + vcmz ** 2)
    
        return (vcmx, vcmy, vcmz, transKinEnergy)

    #The following method is replaced by a Fortran version in utility.f. 
    #Usage: inertia = utility_f.calcinertia(mass, r)
    
    def calcInertia(self, molecule, inertia):
    # Compute inertia tensor I.    
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        rcmx, rcmy, rcmz = self.calcPositionCM(molecule)
    
        mxx = 0.; myy = 0.; mzz = 0.
        mxy = 0.; myz = 0.; mzx = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            xrel = rx - rcmx
            yrel = ry - rcmy
            zrel = rz - rcmz
            
            mxx += mass * xrel * xrel 
            myy += mass * yrel * yrel 
            mzz += mass * zrel * zrel 
            mxy += mass * xrel * yrel 
            myz += mass * yrel * zrel 
            mzx += mass * zrel * xrel 
    
        inertia[(0, 0)] =  myy + mzz 
        inertia[(0, 1)] = -mxy 
        inertia[(0, 2)] = -mzx 
        inertia[(1, 0)] = -mxy 
        inertia[(1, 1)] =  mxx + mzz 
        inertia[(1, 2)] = -myz 
        inertia[(2, 0)] = -mzx 
        inertia[(2, 1)] = -myz 
        inertia[(2, 2)] =  mxx + myy 
    
        return

    #The following method is replaced by a Fortran version in utility.f. 
    #Usage: angMoment = utility_f.calcangularmomentum(mass, r, v)

    def calcAngularMomentum(self, molecule):
    # Compute angular momentum of entire system. L = m (R x V)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        masstot = 0.
        rcmx = 0.; rcmy = 0.; rcmz = 0. 
        vcmx = 0.; vcmy = 0.; vcmz = 0.
        angMomX = 0.; angMomY = 0.; angMomZ = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            mass = atom.getAtomicMass()
            masstot += mass
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            rcmx += rx * mass 
            rcmy += ry * mass 
            rcmz += rz * mass 
    
            vcmx += vx * mass 
            vcmy += vy * mass 
            vcmz += vz * mass 
    
            angMomX += mass * (ry * vz - rz * vy)
            angMomY += mass * (rz * vx - rx * vz)
            angMomZ += mass * (rx * vy - ry * vx)
    
        # Note that above rcmx, vcmx etc. are not normalized by total mass to improve performance.
        # Thus R x V below is divided by total mass rather than be multiplied. 
        angMomX -= (rcmy * vcmz - rcmz * vcmy) / masstot 
        angMomY -= (rcmz * vcmx - rcmx * vcmz) / masstot 
        angMomZ -= (rcmx * vcmy - rcmy * vcmx) / masstot 
    
        return (angMomX, angMomY, angMomZ)
    """
    
    def calcAngularVelocity(self, mass, r, v):
    # Compute angular velocity of entire system. 
        from cmdf.utility.lapy import LAPy  
        lapy = LAPy()
        angMoment = calcangularmomentum(mass, r, v)
    
        # Compute inertia tensor. 
        inertia = calcinertia(mass, r)
        # Invert inertia matrix.
        lapy.gaussJordan2(inertia)
        # Compute angular velocity: omega = (inverse of I) * L 
        rotKinEnergy = 0.
        omega = numpy.zeros(3, numpy.Float) 
        for i in range(3):
            for j in range(3):
                omega[i] += inertia[i, j] * angMoment[j]
    
            # Compute rotational kinetic energy of entire system.
            rotKinEnergy += omega[i] * angMoment[i]
    
        rotKinEnergy *= 0.5
    
        return (omega, rotKinEnergy)
    
    def removeTranslation(self, molName, imove, masses, vels):
    # Remove translation of entire system.    
        from control import Control
        # Compute linear velocity of CM.
        vcm, transKE = calcvelocitycm(masses, vels)

        if Control.printLevel > 1:            
            logFile = open(molName+'.log', 'a')
            logFile.write('%37s %10.5e %10.5e %10.5e \n%37s %10.5e\n' %  \
                ('Linear velocity of CM:', vcm[0], vcm[1], vcm[2], \
                'Translational kinetic energy(eV/mol):', transKE))
            logFile.close()
    
        # No need to remove if linear velocities are small.
        vcmNorm = vcm[0] ** 2 + vcm[1] ** 2 + vcm[2] ** 2
        if vcmNorm < 1.e-12: return 

        numAtoms = len(masses)
        for i in range(numAtoms):
            if imove[i] != 0:
                continue

            i3  = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            vels[i3]  -= vcm[0]
            vels[i31] -= vcm[1]
            vels[i32] -= vcm[2]
    
        return
    
    def removeRotation(self, molName, imove, mass, r, v):
    # Remove rotation of entire system.    
        from control import Control
        # Compute center of mass.
        rcm = calcpositioncm(mass, r)

        # Compute angular velocity.
        omega, rotKE = self.calcAngularVelocity(mass, r, v) 

        if Control.printLevel > 1:            
            logFile = open(molName+'.log', 'a')
            logFile.write('%37s %10.5e %10.5e %10.5e \n%37s %10.5e\n' %  \
                ('Angular velocity of CM:', omega[0], omega[1], omega[2], \
                'Rotational kinetic energy(eV/mol):', rotKE))
            logFile.close()
    
        # No need to remove if angular velocities are small.
        omegaNorm = omega[0] ** 2 + omega[1] ** 2 + omega[2] ** 2
        if omegaNorm < 1.e-9: return 

        numAtoms = len(mass)    
        for i in range(numAtoms):
            if imove[i] != 0:
                continue
            
            i3  = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
    
            rxrel = r[i3]  - rcm[0]
            ryrel = r[i31] - rcm[1]
            rzrel = r[i32] - rcm[2]
    
            v[i3]  -= omega[1] * rzrel - omega[2] * ryrel  
            v[i31] -= omega[2] * rxrel - omega[0] * rzrel  
            v[i32] -= omega[0] * ryrel - omega[1] * rxrel  
            
        return
    
    def calcTorque(self, molecule):
    # Compute torque of entire system about center of mass. T = R x F 
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
    
        rcmx, rcmy, rcmz = self.calcPositionCM(molecule) 
    
        torqueX = 0.; torqueY = 0.; torqueZ = 0.
        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
    
            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
    
            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()
    
            rrx = rx - rcmx 
            rry = ry - rcmy 
            rrz = rz - rcmz 
    
            torqueX += rry * fz - rrz * fy
            torqueY += rrz * fx - rrx * fz 
            torqueZ += rrx * fy - rry * fx
    
        return (torqueX, torqueY, torqueZ)

    def outputTrjSys(self, molecule, trjFile, iteration=None):
        from cmdf.utility.control import Control

        natoms = molecule.numAtoms()

        trjFile.write(' %i\n' % natoms)

        if iteration is not None:
            trjFile.write(' No. %i\n' % iteration)

        for i in range(1, natoms+1):
            atom = molecule.getAtomWithNumber(i)
            x = atom.getX()
            y = atom.getY()
            z = atom.getZ()
            #vx = atom.getVelocityX()
            #vy = atom.getVelocityY()
            #vz = atom.getVelocityZ()
            #fx = atom.getForceX()
            #fy = atom.getForceY()
            #fz = atom.getForceZ()
            # Note that output of velocity still use internal units here.
            #chunk = '%2s %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f\n' %   \
                #(atom.getElement(), x, y, z,  \
                #             vx, vy, vz,  \
                #             fx/Control.printEnergyUnit,  \
                #             fy/Control.printEnergyUnit,  \
                #             fz/Control.printEnergyUnit)
            chunk = '%2s %16.8f %16.8f %16.8f\n' %   \
                (atom.getElement(), x, y, z)   

            trjFile.write(chunk)

        return
    
    def outputTrj(self, trjFile, level, cellDim, elements, r, v, f, iteration=None):
        from cmdf.utility.control import Control
        unit = Unit()
        
        natoms = len(elements) 

        trjFile.write(' %i\n' % natoms)

        if iteration is not None:
            trjFile.write(' No. %i %s\n' % (iteration, str(cellDim)))

        for i in range(natoms):
            i3 = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            # Units are A, A/ps, printEnergyUnit
            if level == 1:
                chunk = '%2s %16.8f %16.8f %16.8f \n' %   \
                    (elements[i], r[i3], r[i31], r[i32])    
            elif level == 2:
                chunk = '%2s %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f \n' %   \
                    (elements[i], r[i3], r[i31], r[i32],  \
                                  v[i3]  * unit.ps,  \
                                  v[i31] * unit.ps,  \
                                  v[i32] * unit.ps)   
            elif level == 3:
                chunk = '%2s %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f %16.8f \n' %   \
                    (elements[i], r[i3], r[i31], r[i32],  \
                                  v[i3]  * unit.ps,  \
                                  v[i31] * unit.ps,  \
                                  v[i32] * unit.ps,  \
                                  f[i3]  / Control.printEnergyUnit, \
                                  f[i31] / Control.printEnergyUnit, \
                                  f[i32] / Control.printEnergyUnit)   

            trjFile.write(chunk)

        return

    def sumForce(self, molName, imove, element, coords, forces, minz, maxz, iteration=None):
        from cmdf.utility.control import Control
        unitConversion = Control.printEnergyUnit

        #totForce = numpy.zeros(3, Float)
        forceFile = open(molName+'_sumforce.dat', 'w')

        totForce = totforce(imove, element, coords, forces, minz, maxz)

        forceFile.write("%i %20.10e %20.10e %20.10e\n" % (iteration,  \
                             totForce[0]/unitConversion,  \
                             totForce[1]/unitConversion,  \
                             totForce[2]/unitConversion))
        forceFile.close()

        return

    def searchFileName(self, filename):
        """
        Search file in sys.path.
        """
        #import sys
        #import os, os.path

        for path in sys.path:
            fullFileName = os.path.join(path, filename)
            if os.path.isfile(fullFileName):
                return fullFileName

        return None

    def timer(self, molName, starttime, endtime):

        TIYEAR = endtime.year-starttime.year; TIMONTH = endtime.month-starttime.month
        TIDAY = endtime.day-starttime.day; TIHOUR = endtime.hour-starttime.hour
        TIMINUTE = endtime.minute-starttime.minute; TISECOND = endtime.second-starttime.second
        TIMICROSECOND = endtime.microsecond-starttime.microsecond
        if TIMICROSECOND < 0: TIMICROSECOND += 1000000; TISECOND -= 1
        if TISECOND < 0: TISECOND += 60; TIMINUTE -= 1
        if TIMINUTE < 0: TIMINUTE += 60; TIHOUR -= 1
        if TIHOUR < 0: TIHOUR += 24; TIDAY -= 1
        if TIDAY < 0: TIDAY += 30; TIMONTH -= 1
        if TIMONTH < 0: TIMONTH += 12; TIYEAR -= 1

        logFile = open(molName+'.log', 'a')
        logFile.write("CMDF started at "+str(starttime)+'\n')
        logFile.write("CMDF ended   at "+str(endtime)+'\n')
        logFile.write("CMDF lasted "+str(TIYEAR)+' years '+str(TIMONTH)+' months '+str(TIDAY) \
            +' days '+ str(TIHOUR)+' hours '+str(TIMINUTE)+' minutes '+str(TISECOND)+' seconds '  \
            +str(TIMICROSECOND)+' microseconds.\n')
        logFile.close()

        return (TIYEAR, TIMONTH, TIDAY, TIHOUR, TIMINUTE, TISECOND, TIMICROSECOND)

