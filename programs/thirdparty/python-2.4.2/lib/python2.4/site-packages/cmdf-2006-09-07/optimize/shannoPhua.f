! Fortran functions/subroutines to be wrapped in Python conmin function (via f2py).
       function dmin(x, y) 
            doubleprecision dmin, x, y 
cf2py       intent (in) x            
cf2py       intent (in) y            
cf2py       intent (out) dmin         
            if (x.lt.y) then
                dmin = x
            else
                dmin = y
            endif
            return  
       end

       function dmax(x, y) 
            doubleprecision dmax, x, y 
cf2py       intent (in) x            
cf2py       intent (in) y            
cf2py       intent (out) dmax         
            if (x.gt.y) then
                dmax = x
            else
                dmax = y
            endif
            return  
       end

       subroutine normsq(n, m, x, g, w, xsq, dg1)
           doubleprecision x(*)
           doubleprecision g(*)
           doubleprecision w(*)
           doubleprecision xsq, dg1
           integer n, m
           integer i
cf2py      intent (in) x, g
cf2py      intent (in, out) w 
cf2py      integer intent (hide), depend(x) :: n = len(x) 
cf2py      integer intent (hide), depend(w) :: m = len(w) 
cf2py      intent (out) xsq, dg1
           xsq = 0.
           dg1 = 0. 
           do 100 i = 1, n
              w(i) = -g(i)
              xsq = xsq + x(i) * x(i)
              dg1 = dg1 - g(i) * g(i)
100        continue
           return
       end

       subroutine rmscoords(n, x, xold, rmsx)
            implicit none
            double precision x(*)
            double precision xold(*)
            double precision rmsx, sqSumX
            integer n
            integer i
cf2py       intent (in) x, xold       
cf2py       intent (out) rmsx       
cf2py       integer intent (hide), depend(x) :: n = len(x)
            sqSumX = 0.
            do 100 i = 1, n
                sqSumX = sqSumX + (x(i) - xold(i)) ** 2   
100         continue
            rmsx = sqrt(sqSumX / n)

       end 

       subroutine rmsforces(n, f, rmsf)
            implicit none
            double precision f(*)
            double precision rmsf, sqSumF
            integer n, i
cf2py       intent (in) f
cf2py       intent (out) rmsf
cf2py       integer intent (hide), depend(f) :: n = len(f)
            sqSumF = 0.
            do 100 i = 1, n
                sqSumF = sqSumF + f(i) * f(i)
100         continue
            rmsf = sqrt(sqSumF / n)

       end

       subroutine steplength(n, m, nx, ng, x, g, w, step)
           doubleprecision x(*)
           doubleprecision g(*)
           doubleprecision w(*)
           doubleprecision step 
           integer n, m, nx, ng
           integer i
           integer nxpi, ngpi
cf2py      intent (in) nx, ng
cf2py      intent (in) x, g
cf2py      intent (in, out) w 
cf2py      integer intent (in), depend(x) :: n = len(x) 
cf2py      integer intent (in), depend(w) :: m = len(w) 
cf2py      intent (out) step
           step = 0.
           do 100 i = 1, n
              step = step + w(i) * w(i)
              nxpi = nx + i
              ngpi = ng + i
              w(nxpi) = x(i)
              w(ngpi) = g(i)
100        continue
           step = sqrt(step)
           return
       end

       subroutine trialpoint(n, m, nx, x, w, alpha)
           doubleprecision x(*)
           doubleprecision w(*)
           doubleprecision alpha 
           integer n, m, nx
           integer i
           integer nxpi
cf2py      intent (in) nx, alpha 
cf2py      intent (in, out) x
cf2py      intent (in) w
cf2py      integer, intent (in), depend(x) :: n = len(x)
cf2py      integer, intent (in), depend(w) :: m = len(w)
           do 100 i = 1, n
              nxpi = nx + i
              x(i) = w(nxpi) + alpha * w(i)
100        continue
           return
       end

       subroutine deralpha(n, m, g, w, dal)
           doubleprecision g(*)
           doubleprecision w(*)
           doubleprecision dal 
           integer n, m
           integer i
cf2py      intent (in) g, w
cf2py      integer intent (in), depend(g) :: n = len(g)
cf2py      integer intent (in), depend(w) :: m = len(w)
cf2py      intent (out) dal 
           dal = 0. 
           do 100 i = 1, n
              dal = dal + g(i) * w(i)
100        continue
           return
       end

       subroutine normsq2(n, x, g, xsq, gsq)
           doubleprecision x(*)
           doubleprecision g(*)
           doubleprecision xsq, gsq 
           integer n
           integer i
cf2py      intent (in) x, g
cf2py      integer intent(in), depend(x) :: n = len(x)
cf2py      intent (out) xsq, gsq 
           xsq = 0.
           gsq = 0. 
           do 100 i = 1, n
              xsq = xsq + x(i) * x(i)
              gsq = gsq + g(i) * g(i)
100        continue
           return
       end

       subroutine stepvector(n, m, w, alpha)
           doubleprecision w(*)
           doubleprecision alpha 
           integer n, m
           integer i
cf2py      intent (in) n
cf2py      intent (in, out) w
cf2py      integer intent(in), depend(w) :: m = len(w)
cf2py      intent (in) alpha
           do 100 i = 1, n
              w(i) = w(i) * alpha
100        continue
           return
       end

       subroutine searchvector_cg(n, m, nx, ng, nry, nrd, ncons,
     &      ncons0, ncons1, gsq, g, w, nrst, dg1)
           ! Conjugate gradient algorithm 
           doubleprecision g(*)
           doubleprecision w(*)
           doubleprecision step, dg1 
           doubleprecision u1, u2, u3, u4 
           doubleprecision rtst, gsq 
           integer n, m, nx, ng, nry, nrd, ncons, ncons0, ncons1
           integer i, nrst(1)
           integer nxpi, ngpi
           integer nrdpi, nxdpi
cf2py      intent (in) nx, ng, nry, nrd, ncons, ncons0, ncons1, gsq
cf2py      intent (in) g
cf2py      intent (in, out) w, nrst
cf2py      integer intent (in), depend(g) :: n = len(g)
cf2py      integer intent (in), depend(w) :: m = len(w)
cf2py      intent (out) dg1 
           rtst = 0. 
           do 100 i = 1, n
              ngpi = ng + i
              rtst = rtst + g(i) * w(ngpi) 
100        continue
           if (abs(rtst/gsq) .gt. 0.2) then
              nrst(1) = n 
           endif
           ! Increase 1 for matching Fortran index (from 1). 
           ncons0 = ncons0 + 1 
           ncons1 = ncons1 + 1 
           if (nrst(1) .eq. n) then
                w(ncons0) = 0.
                w(ncons1) = 0.
                do 110 i = 1, n
                    nrdpi = nrd + i
                    nrypi = nry + i
                    ngpi = ng + i
                    w(nrypi) = g(i) - w(ngpi)
                    w(nrdpi) = w(i)
                    w(ncons0) = w(ncons0) + w(nrypi) * w(nrypi)
                    w(ncons1) = w(ncons1) + w(i) * w(nrypi)
110             continue
           endif
           u1 = 0. 
           u2 = 0. 
           do 120 i = 1, n
                nrdpi = nrd + i
                nrypi = nry + i
                u1 = u1 - w(nrdpi) * g(i) / w(ncons0)
                u2 = u2 + w(nrdpi) * g(i) * 2 / w(ncons1) - 
     &              w(nrypi) * g(i) / w(ncons0)
120             continue
           u3 = w(ncons1) / w(ncons0)
           do 130 i = 1, n
                nxpi = nx + i
                nrdpi = nrd + i
                nrypi = nry + i
                w(nxpi) = -u3 * g(i) - u1 * w(nrypi) - u2 * w(nrdpi)
130             continue

           if (nrst(1) .ne. n) then 
                u1 = 0.
                u2 = 0.
                u3 = 0.
                u4 = 0.
                do 140 i = 1, n
                    ngpi = ng + i
                    nrdpi = nrd + i
                    nrypi = nry + i
                    u1 = u1 - (g(i) - w(ngpi)) * w(nrdpi) / w(ncons0)
                    u2 = u2 - (g(i) - w(ngpi)) * w(nrypi) / w(ncons0)  
     &                  + 2.0 * w(nrdpi) * (g(i) - w(ngpi)) / w(ncons1)
                    u3 = u3 + w(i) * (g(i) - w(ngpi))
140             continue
                step = 0.
                do 150 i = 1, n
                    ngpi = ng + i
                    nrdpi = nrd + i
                    nrypi = nry + i
                    step = (w(ncons1) / w(ncons0)) * (g(i) - w(ngpi))  
     &                  + u1 * w(nrypi) + u2 * w(nrdpi)
                    u4 = u4 + step * (g(i) - w(ngpi))
                    w(ngpi) = step
150             continue
                u1 = 0.
                u2 = 0.
                do 160 i = 1, n
                    u1 = u1 - w(i) * g(i) / u3 
                    ngpi = ng + i
                    u2 = u2 + (1.0 + u4 / u3) * w(i) * g(i) / u3  
     &                  - w(ngpi) * g(i) / u3
160             continue
                do 170 i = 1, n
                    ngpi = ng + i
                    nxpi = nx + i
                    w(nxpi) = w(nxpi) - u1 * w(ngpi) - u2 * w(i)
170             continue

           endif
           ! /* CALCULATE THE DERIVATIVE ALONG THE NEW SEARCH VECTOR. */
           dg1 = 0. 
           do 180 i = 1, n
                nxpi = nx + i
                w(i) = w(nxpi)
                dg1 = dg1 + w(i) * g(i)
180             continue
           return
       end

       subroutine searchvector_bfgs(n, m, nx, ng, ncons, rsw,
     &      g, w, dg1)
           ! BFGS algorithm 
           doubleprecision g(*)
           doubleprecision w(*)
           doubleprecision dg1 
           doubleprecision u1, u2, u3, u4 
           integer n, m, nx, ng, ncons, ncons0
           integer i, j, ii, ij 
           integer nxpi, ngpi, ngpj
           ! rsw integer corresponds to logical variable in main program 
           integer rsw  

cf2py      intent (in) nx, ng, ncons, rsw
cf2py      intent (in) g
cf2py      intent (in, out) w
cf2py      integer intent (in), depend(g) :: n = len(g)
cf2py      integer intent (in), depend(w) :: m = len(w)
cf2py      intent (out) dg1

           ! Note changes for matching Fortran array index (from 1). 
           u1 = 0. 
           do 100 i = 1, n
                ngpi = ng + i
                w(ngpi) = g(i) - w(ngpi)
                u1 = u1 + w(i) * w(ngpi)
100             continue
           if (rsw .ne. 0) then  !rsw is true 
                u2 = 0.
                do 110 i = 1, n
                    ngpi = ng + i
                    u2 = u2 + w(ngpi) * w(ngpi)
110             continue
                ij = 1  !yi original ij = 0
                u3 = u1 / u2
                do 130 i = 1, n
                    do 120 j = i, n
                        ncons0 = ncons + ij !yi
                        w(ncons0) = 0.
                        if (i .eq. j) then
                            w(ncons0) = u3
                        endif
                        ij = ij + 1
120                 continue
                    nxpi = nx + i
                    ngpi = ng + i
                    w(nxpi) = u3 * w(ngpi)
130             continue
                u2 = u3 * u2
           else  
                u2 = 0.
                do 160 i = 1, n
                    u3 = 0.
                    ij = i
                    if (i .ne. 1) then  !yi original (i .ne. 0)
                        ii = i - 1  !yi original ii = i 
                        do 140 j = 1, ii
                            ngpj = ng + j
                            ncons0 = ncons + ij
                            u3 = u3 + w(ncons0) * w(ngpj)
                            ij = ij + n - j !yi -1 
140                     continue
                    endif
                    do 150 j = i, n
                        ncons0 = ncons + ij
                        ngpj = ng + j
                        u3 = u3 + w(ncons0) * w(ngpj)
                        ij = ij + 1
150                 continue
                    ngpi = ng + i
                    u2 = u2 + u3 * w(ngpi)
                    nxpi = nx + i
                    w(nxpi) = u3
160             continue
           endif 
           u4 = 1. + u2 / u1 
           do 170 i = 1, n 
                nxpi = nx + i
                ngpi = ng + i
                w(ngpi) = u4 * w(i) - w(nxpi)
170        continue
           ij = 1 !yi ij = 0 
           do 190 i = 1, n 
                nxpi = nx + i
                u3 = w(i) / u1
                u4 = w(nxpi) / u1
                do 180 j = i, n
                    ncons0 = ncons + ij
                    ngpj = ng + j
                    w(ncons0) = w(ncons0) + u3 * w(ngpj) - u4 * w(j)
                    ij = ij + 1
180             continue
190        continue
           dg1 = 0.  
           do 230 i = 1, n  
                u3 = 0.
                ij = i
                if (i .ne. 1) then  !yi (i .ne. 0)
                    ii = i - 1
                    do 210 j = 1, ii
                        ncons0 = ncons + ij
                        u3 = u3 - w(ncons0) * g(j)
                        ij = ij + n - j  !yi -1
210                 continue
                endif
                do 220 j = i, n
                    ncons0 = ncons + ij
                    u3 = u3 - w(ncons0) * g(j)
                    ij = ij + 1
220             continue
                dg1 = dg1 + u3 * g(i)
                w(i) = u3
230        continue
           return
       end

