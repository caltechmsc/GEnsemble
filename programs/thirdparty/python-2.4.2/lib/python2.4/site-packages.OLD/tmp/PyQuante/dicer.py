#!/usr/bin/env python
"""\
 Divide and conquer routine

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

# Some random thoughts on Fermi-Dirac distributions: unless the electron
#  temperature is *really* high, Efermi simply has to be some number in
#  the band gap. Since Kboltz is so small, the temperature has to be
#  on the order of 1e5 before you can see much softening of the
#  occupations. Open-shell and metallic systems are a little more
#  sensitive. For a doublet state, you just need Efermi to be the
#  energy of the unoccupied orbital. Higher order multiplicities
#  aren't in general possible with FD occupations. But they're not
#  really necessary for divide and conquer, which is fundamentally
#  a method to treat insulating systems as a combination of fragments.

from basis_631ss import basis
from Molecule import Molecule
from Ints import getbasis,getints,get2JmK
from LA2 import GHeigenvectors
from Numeric import sum,matrixmultiply,transpose
from math import exp,pi
from Convergence import SimpleAverager
from Constants import Kboltz

VERBOSE = 1
EF_VERBOSE = 0
Tdefault = 1e3

class dicer_block:
    def __init__(self,atoms,bufferatoms=[],charge=0):
        allatoms = atoms + bufferatoms
        atombasis = getbasis(atoms,basis)
        bufferbasis = getbasis(bufferatoms,basis)
        self.nbfat = len(atombasis)
        bfs = atombasis+bufferbasis
        self.nbf = len(bfs)
        self.S,self.h,self.Ints = getints(bfs,allatoms)
        self.orbe,self.orbs = GHeigenvectors(self.h,self.S)
        self.nel = allatoms.get_nel(charge)
        self.nclosed,self.nopen = divmod(self.nel,2)
        self.avg = SimpleAverager()
        return

    def get_efermi_T0(self):
        if self.nopen: return self.orbe[self.nclosed]
        return 0.5*(self.orbe[self.nclosed-1]+self.orbe[self.nclosed])        

    def get_nel(self,efermi,T): return 2*sum(self.get_fermi_occs(efermi,T))

    def get_fermi_occs(self,efermi,T):
        occs = []
        for en in self.orbe: occs.append(get_fermi_occ(efermi,en,T))
        return occs

    def update(self,efermi,T):
        self.occs = self.get_fermi_occs(efermi,T)
        self.D = self.avg.getD(get_dens(self.orbs,self.occs))
        self.G = get2JmK(self.Ints,self.D)
        self.F = self.h+self.G
        self.orbe,self.orbs = GHeigenvectors(self.F,self.S)
        return self.get_energy()

    def get_energy(self):
        # Note that the range the sums are made over is not square,
        #  but rectangular. This is because of the Mulliken approximation
        #  that is made to approximate the coupling between the core
        #  regions via the buffer zones.
        na = self.nbfat
        n = self.nbf
        energy = sum(sum(self.D[:na,:n]*(self.h[:na,:n]+self.F[:na,:n])))
        return energy
        
def dicer(atoms,blocksizes,T=Tdefault,charge=0,ConvCriteria=0.0001,MaxIter=20):
    nstart = 0
    blocks = []
    for nb in blocksizes:
        blocks.append(dicer_block(atoms[nstart:nstart+nb]))
        nstart += nb
    eold = 0.
    enuke = atoms.get_enuke()
    for i in range(MaxIter):
        efermi = get_efermi_T0(blocks)
        efermi = get_efermi(efermi,blocks,T)
        energy = 0
        for block in blocks: energy += block.update(efermi,T)
        if VERBOSE: print "%2d %10.4f %10.4f %10.4f" % (i,energy+enuke,efermi,T)
        if abs(energy - eold) < ConvCriteria: break
        eold = energy
    else: print "Maximum iterations %d exceeded" % MaxIter

def get_efermi_T0(blocks):
    efT0 = 0
    for block in blocks: efT0 += block.get_efermi_T0()
    return efT0/len(blocks)

def get_fermi_occ(efermi,en,T,cutoff=25):
    kT = Kboltz*T
    x = (en-efermi)/kT
    if x < -cutoff: return 1.
    elif x > cutoff: return 0
    return 1/(1+exp(x))
    
def get_efermi(efermi_guess,blocks,T,tol=1e-4,delta=5.):
    nel = 0
    for block in blocks: nel += block.nel
    elow,ehigh = efermi_guess-delta,efermi_guess+delta
    nlow,nhigh = 0,0
    for block in blocks:
        nlow += block.get_nel(elow,T)
        nhigh += block.get_nel(ehigh,T)
    assert nlow < nel, "elow incorrect %f" % nlow
    assert nhigh > nel, "ehigh incorrect %f" % nhigh
    
    for i in range(100):
        efermi = (elow+ehigh)/2
        n = 0
        for block in blocks: n += block.get_nel(efermi,T)
        if EF_VERBOSE: print "get_efermi: %f %f" %  (n,efermi)
        if abs(n-nel) < tol: break
        elif n < nel: elow = efermi
        else: ehigh = efermi
    else: print "get_fd_occs: Too many iterations"
    if EF_VERBOSE: print "get_efermi: ",efermi_guess,efermi,i
    return efermi

def get_dens(orbs,occs):
    n = orbs.shape[0]
    nc,no = get_core_open(occs)
    D = matrixmultiply(transpose(orbs[:nc,:]),orbs[:nc,:])
    for i in range(nc,nc+no):
        for k in range(n):
            for l in range(k+1):
                D[k,l] = D[k,l] + occs[i]*orbs[i,k]*orbs[i,l]
                D[l,k] = D[k,l]
    # Ultimately replace this loop with something like:
    #for i in range(nc,nc+no):
    #    D += occs[i]*matrixmultiply(transpose(orbs[i,:]),orbs[i,:])
    return D

def get_core_open(occs,tol=0.005):
    ncore = nopen = 0
    for occ in occs:
        if occ > (1-tol): ncore += 1
        elif occ > tol: nopen += 1
    return ncore,nopen

if __name__ == '__main__':
    #h2o = Molecule(
    #    atomlist = [
    #    (8,(0.,0.,0.)),
    #    (1,(0.,1.,0.)),
    #    (1,(0.,0.,1.))
    #    ],
    #    units='Angstrom')
    #dicer(atoms,[3])
    ethane = Molecule(
        atomlist = [
        (6, ( 0.0000,     0.0000,     0.0000)),
        (1, (-0.6000,     0.6000,     0.0000)),
        (1, ( 0.0000,    -0.6500,     0.8800)),
        (1, ( 0.0000,    -0.6500,    -0.8800)),
        (6, ( 1.3000,     1.0000,     0.0000)),
        (1, ( 1.9000,     0.4000,     0.0000)),
        (1, ( 1.3000,     1.6500,     0.8800)),
        (1, ( 1.3000,     1.6500,    -0.8800))
        ],
        units = 'Angstrom')
    dicer(ethane,[8])



