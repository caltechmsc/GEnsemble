#!/usr/bin/env python
"""\
 LA2.py: Simple additions to the Python LinearAlgebra library

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

from math import sqrt
from Numeric import matrixmultiply,transpose,sum,diagonal,identity,Float
from LinearAlgebra import Heigenvalues,Heigenvectors,cholesky_decomposition,\
     eigenvectors


# Note: to be really smart in a quantum chemistry program, we would
#  want to only symmetrically orthogonalize the S matrix once, since
#  the matrix doesn't change during the SCF procedure. Thus, we would
#  want to call X = SymOrth(S), and then GHeigenvectorsD(H,X), rather
#  than calling GHeigenvectors(H,S) every time, since the latter
#  recomputes the symmetric orthogonalization every SCF cycle.

def Orthogonalize(H,S):
    X = SymOrth(S)
    return SimilarityTransform(H,X)

def GHeigenvaluesD(H,X):
    """Return generalized eigenvalues of the real symmetric matrix H
    given the symmetric orthogonalizing transformation X"""
    return Heigenvalues(SimilarityTransform(H,X))
    
def GHeigenvectorsD(H,X):
    """Return generalized eigenvalues/vectors of the real symmetric matrix H
    given the symmetric orthogonalizing transformation X"""
    val,vec = Heigenvectors(SimilarityTransform(H,X))
    # original
    return val,matrixmultiply(vec,X)

def GHeigenvalues(H,S):
    """Return eigenvalues of generalized Hx=lSx eigenproblem. H and S
    are real symmetric matrices."""
    X = SymOrth(S)
    return GHeigenvaluesD(H,X)

def GHeigenvectors(H,S):
    """Return eigenvalues/vectors of generalized Hx=lSx eigenproblem. H and S
    are real symmetric matrices"""
    X = SymOrth(S)
    return GHeigenvectorsD(H,X)

def SymOrth(X):
    """Symmetric orthogonalization of the real symmetric matrix X.
    This is given by Ut(1/sqrt(lambda))U, where lambda,U are the
    eigenvalues/vectors."""
    val,vec = Heigenvectors(X)
    n = vec.shape[0]
    shalf = identity(n,Float)
    for i in range(n):
        shalf[i,i] /= sqrt(val[i])
    return SimilarityTransformT(shalf,vec)

def CanOrth(X): 
    """Canonical orthogonalization of matrix X. This is given by
    U(1/sqrt(lambda)), where lambda,U are the eigenvalues/vectors."""
    val,vec = Heigenvectors(X)
    n = vec.shape[0]
    for i in range(n):
        for j in range(n):
            vec[i,j] = vec[i,j]/sqrt(val[i])
    return vec

def TraceProperty(H,D):
    "Return the trace(H*D), used in computing QM energies"
    return sum(diagonal(matrixmultiply(H,D)))

def SimilarityTransformT(H,X):
    "Return the similarity transformation XtHX of H"
    return matrixmultiply(transpose(X),matrixmultiply(H,X))

def SimilarityTransform(H,X): 
    "Return the transpose similarity transformation XHXt of H"
    return matrixmultiply(X,matrixmultiply(H,transpose(X)))

def mkdens(c,nstart,nstop):
    "Form a density matrix C*Ct given eigenvectors C[nstart:nstop,:]"
    d = c[nstart:nstop,:]
    return matrixmultiply(transpose(d),d)

def mkdens2(c,nstart,nstop):
    "2*normal density matrix, since that's more common"
    return 2*mkdens(c,nstart,nstop)
