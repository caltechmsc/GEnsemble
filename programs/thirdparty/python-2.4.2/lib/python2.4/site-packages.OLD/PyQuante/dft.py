#!/usr/bin/env python
"""\
 dft.py Initial version of dft routines in PyQuante

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

#from math import *
from Ints import getbasis,getJ,get1ints,get2ints
from basis_631ss import basis
from MolecularGrid import MolecularGrid
from LA2 import GHeigenvectors,mkdens,TraceProperty
from Numeric import zeros,Float,dot,array
from DFunctionals import S,VWN
from time import time
from Convergence import DIIS
from PyQuante.cints import dist


VERBOSE = 0

def getJ_dft(gr,bfs,dodelta=0):
    "Construct the Coulomb operator in the normal DFT way"
    nbf = len(bfs)
    J = zeros((nbf,nbf),Float)
    dens = gr.dens()
    for a in range(nbf):
        bfa = bfs[a]
        for b in range(a+1):
            bfb = bfs[b]
            for point in gr.points():
                x,y,z,w = point.xyzw()
                if dodelta:
                    J[a,b] += -w*point.ddens()*bfa.nuclear(bfb,(x,y,z))
                else:
                    J[a,b] += -w*point.dens()*bfa.nuclear(bfb,(x,y,z))
            J[b,a] = J[a,b]
    return J

def getJ_dft_vec(gr,bfs,dodelta=0):
    "Construct the Coulomb operator in the normal DFT way"
    nbf = len(bfs)
    J = zeros((nbf,nbf),Float)

    xc = []
    yc = []
    zc = []
    wc = []
    qc = []

    for point in gr.points():

        x,y,z,w = point.xyzw()
        
        if dodelta: q = point.ddens()
        else:       q = point.dens()

        if abs(q) > 1e-8:
            xc.append(x)
            yc.append(y)
            zc.append(z)
            wc.append(w)
            qc.append(-q) # electrons are negative
        
    for a in range(nbf):
        bfa = bfs[a]
        for b in range(a+1):
            bfb = bfs[b]

            J[a,b] = bfa.nuclear_vec(bfb,xc,yc,zc,wc,qc)
            J[b,a] = J[a,b]
    return J

def getXC(gr,nel,bfgrid):
    "Form the exchange-correlation matrix"
    nbf = gr.nbf()
    XC = zeros((nbf,nbf),Float)
    dens = gr.dens() # densities at each grid point
    weight = gr.weights()  # weights at each grid point

    ex,vx = S(dens)
    ec,vc = VWN(dens)
    vxc = vx+vc
    exc = ex+ec

    renorm_factor = nel/dot(weight,dens)
    weight *= renorm_factor # Renormalize to the proper # electrons

    Exc = dot(weight,exc)
    wv = weight*vxc  # Combine w*v in a vector for multiplication by bfs
    
    for a in range(nbf):
        wva = wv*bfgrid[:,a] 
        for b in range(nbf):
            XC[a,b] = dot(wva,bfgrid[:,b])
    return Exc,XC

def getX(gr,nel,bfgrid):
    "Form the exchange-only matrix"
    nbf = gr.nbf()
    X = zeros((nbf,nbf),Float)
    dens = gr.dens() # densities at each grid point
    weight = gr.weights()  # weights at each grid point

    ex,vx = S(dens)

    renorm_factor = nel/dot(weight,dens)
    weight *= renorm_factor # Renormalize to the proper # electrons

    Ex = dot(weight,ex)
    wv = weight*vx  # Combine w*v in a vector for multiplication by bfs
    
    for a in range(nbf):
        wva = wv*bfgrid[:,a] 
        for b in range(nbf):
            X[a,b] = dot(wva,bfgrid[:,b])
    return Ex,X

def read_jaguar_restart(filename,nbf):
    "Gets the orbitals from a Jaguar restart file"
    import re
    file = open(filename)
    guess_pat = re.compile('&guess')
    end_pat = re.compile('&')
    reading = 0
    for line in file.readlines():
        if reading:
            if end_pat.search(line):
                reading = 0
                break
            guess_section.append(line)
        if not reading:
            if guess_pat.search(line):
                reading = 1
                guess_section = []
    file.close()
    orbe = []
    orbs = zeros((nbf,nbf),Float)
    orbptr = -1
    orb_pat = re.compile('Orbital Energy')
    for line in guess_section:
        if orb_pat.search(line):
            basptr = 0
            orbptr += 1
        else:
            words = map(float,line.split())
            nwords = len(words)
            for i in range(nwords):
                orbs[orbptr,basptr+i] = words[i]
            basptr += nwords
    return orbs

def dft(atoms,charge=0,ConvCriteria=0.0001,MaxIter=20,VERBOSE=True):
    "Simple DFT driving routine"
    bfs = getbasis(atoms,basis)
    S,h = get1ints(bfs,atoms)
    
    Ints = get2ints(bfs)

    gr = MolecularGrid(atoms,32,1) # default medium mesh
    gr.set_bf_amps(bfs)

    if VERBOSE:
        print "Nbf = ",len(bfs)
        print "Ng = ",len(gr)

    bfgrid = gr.allbfs() # bfs over all grid points

    orbe,orbs = GHeigenvectors(h,S)
    nel = atoms.get_nel(charge)
    nocc,nopen = divmod(nel,2)
    assert(nopen == 0), "DFT currently only works for closed-shell systems"

    Enuke = atoms.get_enuke()
    eold = 0.
    avg=DIIS(S)

    for i in range(MaxIter):
        D = mkdens(orbs,0,nocc)
        gr.setdens(D)

        J = getJ(Ints,D)
        Exc,XC = getXC(gr,nel,bfgrid)
        F = h+2*J+XC
        F = avg.getF(F,D)

        orbe,orbs = GHeigenvectors(F,S)

        Ej = 2*TraceProperty(D,J)
        Eone = 2*TraceProperty(D,h)
        energy = Eone + Ej + Exc + Enuke
        if VERBOSE: print "%10.4f %10.4f %10.4f %10.4f %10.4f" %\
           (energy,Eone,Ej,Exc,Enuke)
        if abs(energy-eold) < ConvCriteria: break
        eold = energy
    return energy

# def dft_scf(atoms,S,h,Ints,grid,charge=0,ConvCriteria=0.0001,MaxIter=20):
#     bfgrid = grid.allbfs() # bfs over all grid points

#     orbe,orbs = GHeigenvectors(h,S)
#     nel = atoms.get_nel(charge)
#     nocc,nopen = divmod(nel,2)
#     assert(nopen == 0), "DFT currently only works for closed-shell systems"

#     Enuke = atoms.get_enuke()
#     eold = 0.
#     avg=DIIS(S)

#     for i in range(MaxIter):
#         D = mkdens(orbs,0,nocc)
#         grid.setdens(D)

#         J = getJ(Ints,D)
#         Exc,XC = getXC(grid,nel,bfgrid)
#         F = h+2*J+XC
#         F = avg.getF(F,D)

#         orbe,orbs = GHeigenvectors(F,S)

#         Ej = 2*TraceProperty(D,J)
#         Eone = 2*TraceProperty(D,h)
#         energy = Eone + Ej + Exc + Enuke
#         if VERBOSE: print "%10.4f %10.4f %10.4f %10.4f %10.4f" %\
#            (energy,Eone,Ej,Exc,Enuke)
#         if abs(energy-eold) < ConvCriteria: break
#         eold = energy
#     return energy

# WARNING: This is PAINFULLY slow...
# def dft_new(atoms,charge=0,ConvCriteria=0.0001,MaxIter=20):
#     "Simple DFT driving routine"
#     bfs = getbasis(atoms,basis)
#     S,h = get1ints(bfs,atoms)
    
#     gr = MolecularGrid(atoms,32,1)
#     gr.set_bf_amps(bfs)
#     bfgrid = gr.allbfs() # bfs over all grid points

#     orbe,orbs = GHeigenvectors(h,S)
#     nel = atoms.get_nel(charge)
#     nocc,nopen = divmod(nel,2)
#     assert(nopen == 0), "DFT currently only works for closed-shell systems"

#     Enuke = atoms.get_enuke()
#     eold = 0.
#     avg=DIIS(S)

#     for i in range(MaxIter):
#         D = mkdens(orbs,0,nocc)
#         gr.setdens(D)

#         J = getJ_dft(gr,bfs)

#         Exc,XC = getXC(gr,nel,bfgrid)
#         F = h+2*J+XC
#         F = avg.getF(F,D)

#         orbe,orbs = GHeigenvectors(F,S)

#         Ej = 2*TraceProperty(D,J)
#         Eone = 2*TraceProperty(D,h)
#         energy = Eone + Ej + Exc + Enuke
#         print "%10.4f %10.4f %10.4f %10.4f %10.4f" %\
#               (energy,Eone,Ej,Exc,Enuke)
#         if abs(energy-eold) < ConvCriteria: break
#         eold = energy
#     return energy,orbe,orbs

if __name__ == '__main__':
    from Molecule import Molecule,toBohr3
    so2 = Molecule('so2',
                   [(16,toBohr3(.0000000000, 0.0000000000, .3720406868)),
                    ( 8,toBohr3(.0000000000, 1.2648815034,-.3718341554)),
                    ( 8,toBohr3(.0000000000,-1.2648815034,-.3718341554))])
    en = dft(so2)
    print en

