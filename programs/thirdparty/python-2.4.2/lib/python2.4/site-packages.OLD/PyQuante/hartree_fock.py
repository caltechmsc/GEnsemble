#!/usr/bin/env python
"""\
 hartree_fock.py Basic routines for HF programs in the PyQuante framework

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

import string,sys,time

from LA2 import GHeigenvectors,mkdens,TraceProperty
from Ints import get2JmK
from Convergence import DIIS

from math import sqrt,pow
from PyQuante.cints import dist

VERBOSE = 1

def get_energy(h,F,D,enuke=0.):
    "Form the total energy of the closed-shell wave function."
    eone = TraceProperty(D,h)
    etwo = TraceProperty(D,F)
    if VERBOSE>1:
        print "eone = ",2*eone
        print "etwo = ",etwo-eone
    return eone+etwo+enuke

def get_energy2(h,F,D,enuke=0):
    eone = TraceProperty(D,h)
    etwo = TraceProperty(D,F)
    return eone+0.5*etwo+enuke
    

def get_guess(h,S):
    "Form an initial guess from the one-electron Hamiltonian"
    evals,evecs = GHeigenvectors(h,S)
    return evecs

def get_nel(atoms,charge=0):
    print "Warning, hartree_fock.get_nel deprecated"
    print "Use the Molecular instance function"
    return atoms.get_nel(charge)
def get_enuke(atoms):
    print "Warning, hartree_fock.get_enuke deprecated"
    print "Use the Molecular instance function"
    return atoms.get_enuke()

def scf(atoms,S,h,Ints,charge=0,ConvCriteria=0.0001,MaxIter=20,
        use_diis=False):
    """Run the self-consistent field optimization of the molecular wave
    function until the energy converges"""
    orbe,orbs = GHeigenvectors(h,S)
    nel = atoms.get_nel(charge)
    nclosed,nopen = divmod(nel,2)
    nocc = nclosed
    assert(nopen == 0), "SCF currently only works for closed-shell systems"
    enuke = atoms.get_enuke()
    eold = 0.
    if use_diis: avg = DIIS(S)
    for i in range(MaxIter):
        D = mkdens(orbs,0,nocc)
        G = get2JmK(Ints,D)
        F = h+G
        if use_diis: F = avg.getF(F,D)
        orbe,orbs = GHeigenvectors(F,S)
        energy = get_energy(h,F,D,enuke)
        if VERBOSE: print i,energy
        if abs(energy-eold) < ConvCriteria: break
        eold = energy
    return energy,orbe,orbs

def scf_noavg(atoms,S,h,Ints,charge=0,ConvCriteria=0.0001,MaxIter=20):
    orbe,orbs = GHeigenvectors(h,S)
    nel = atoms.get_nel(charge)
    nclosed,nopen = divmod(nel,2)
    nocc = nclosed
    assert(nopen == 0), "SCF currently only works for closed-shell systems"
    enuke = atoms.get_enuke()
    eold = 0.
    for i in range(MaxIter):
        D = mkdens(orbs,0,nocc)
        G = get2JmK(Ints,D)
        F = h+G
        orbe,orbs = GHeigenvectors(F,S)
        energy = get_energy(h,F,D,enuke)
        if VERBOSE: print i,energy
        if abs(energy-eold) < ConvCriteria: break
        eold = energy
    return energy,orbe,orbs

def rhf(atoms):
    "General wrapper for restricted closed-shell hartree fock"
    from basis_631ss import basis
    from Ints import getbasis,getints
    
    bfs = getbasis(atoms,basis)
    S,h,Ints = getints(bfs,atoms)
    en,orbe,orbs = scf(atoms,S,h,Ints,0,0.0001,10)
    return en

if __name__ == '__main__':
    from Molecule import Molecule
    h2 = Molecule('H2',atomlist=[(1,(1.,0,0)),(1,(-1.,0,0))])
    en = rhf(h2)
    print en
