#!/usr/bin/env python
"""\
 Quest.py LDA using Quest-style Hamiltonian construction.

 The Quest method is due to PJ Feibelman, PA Schultz, and MP Sears
 from Sandia National Laboratories.

 Feibelman, PJ. PRB 33, 719 (1986)
 Feibelman, PJ. JCP 81, 5864 (1984)
 Schultz, PA. Manuscript in Preparation.

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

from basis_631ss import basis
from Ints import getbasis,getS,getT,getV
from PyQuante.cints import dist
from MolecularGrid import MolecularGrid
from LA2 import GHeigenvectors,mkdens,TraceProperty
from Numeric import zeros,Float,dot
from ThomasFermi import rho
from dft import getXC,getJ_dft,getJ_dft_vec
from Convergence import DIIS

class Rho0:
    "Simple interface to Thomas-Fermi atomic density"
    def __call__(self,r):  return self.density(r)
    def __init__(self,Z): self.Z = Z
    def density(self,r): return rho(r,self.Z)

def Quest(atoms,ConvCriteria=0.0001,MaxIter=1):
    "Simple DFT driving routine"
    nel = atoms.get_nel(0)
    nocc,nopen = divmod(nel,2)
    Enuke = atoms.get_enuke()

    bfs = getbasis(atoms,basis)
    gr = MolecularGrid(atoms,32,1)
    gr.set_bf_amps(bfs)
    bfgrid = gr.allbfs() # bfs over all grid points

    S = getS(bfs)
    T = getT(bfs)
    V = getV(bfs,atoms)

    h = T+V

    rho0s = [Rho0(atom.atno) for atom in atoms]
    gr.setdens0(rho0s)

    J0 = getJ_dft_vec(gr,bfs)

    h0 = h+J0
    Exc,XC = getXC(gr,nel,bfgrid)

    orbe,orbs = GHeigenvectors(h0+XC,S)
    eold = 0

    avg=DIIS(S)

    for i in range(MaxIter):
        D = mkdens(orbs,0,nocc)
        gr.setdens(D)

        J_change = getJ_dft_vec(gr,bfs,dodelta=1)
        Exc,XC = getXC(gr,nel,bfgrid)
        
        F = h0+J_change+XC
        F = avg.getF(F,D)
        orbe,orbs = GHeigenvectors(F,S)

        Ej = TraceProperty(D,J_change)
        Eone = TraceProperty(D,h+h0)
        energy = Eone + Ej + Exc + Enuke
        print "%10.4f %10.4f %10.4f %10.4f %10.4f" %\
              (energy,Eone,Ej,Exc,Enuke)
        if abs(energy-eold) < ConvCriteria: break
        eold = energy

    return energy

def main():
    from Molecule import Molecule
    R = 1.0
    r = R/0.52918
    h2o = Molecule('water',atomlist=[(8,(0,0,0)),(1,(r,0,0)),(1,(0,r,0))])
    Quest(h2o)

if __name__ == '__main__':
    profile = 1
    
    if profile:
        import profile,pstats
        profile.run('main()','quest_prof')
        quest_prof = pstats.Stats('quest_prof')
        quest_prof.strip_dirs().sort_stats('time').print_stats(15)
    else:
        main()
    #endif
#end
