#!/usr/bin/env python

import os
import numpy
from cmdf.reaxFF import reax
from cmdf.utility.unit import Unit
#import cmdf.utility.element as element

unit = Unit()

class ReaxForceEngine:
    def __init__(self, natoms, geoFileName, forceFieldName, controlFileName, rnum=234535.1):
        os.system('echo %d.1 > fort.35' % rnum)
        #os.system('echo "      1 igeofo" > control')
        #os.system('touch control')  # Works if reax reads bgf as default, but may not produce the same energy. 
        os.system('cp %s fort.3' % geoFileName)
        os.system('cp %s fort.4' % forceFieldName)
        os.system('cp %s control' % controlFileName)
        reax.pyinit()
        self.natoms = natoms
        return

    def reset(self):
        pass

    def readForceFieldFile(self, filename):
        # Not use
        os.system('cp %s fort.4' % filename)
        return

    def setupEnergyExpression(self, coords, fixed, charges, fftypes, blist, bolist):
        # Not use
        pass
        """
        for i in range(self.natoms):
            
            i3 = 3 * i
            x = float(coords[i3])
            y = float(coords[i3+1])
            z = float(coords[i3+2])

            i1 = i + 1
            modreax.setpos(1, i1, x)
            modreax.setpos(2, i1, y)
            modreax.setpos(3, i1, z)
            
            anumber = element.sym2no[element.fftype2element(fftypes[i])]

            modreax.setatomicnumber(i1, anumber)
            modreax.setcharge(i1, float(charges[i]))
            #modreax.setcharge(i1, 0.0)
        return 
        """

    """
    def setCoords(self, coords):
       
        for i in range(self.natoms):
            x = float(coords[3*i])
            y = float(coords[3*i+1])
            z = float(coords[3*i+2])
            
            modreax.setpos(1, i+1, x)
            modreax.setpos(2, i+1, y)
            modreax.setpos(3, i+1, z)
        return             
    """
   

    def calcEnergyForce(self, coords):
        """
        Copy positions from modbabel to reax.
        """
       
        for i in range(self.natoms):
            i3 = 3 * i
            x = float(coords[i3])
            y = float(coords[i3+1])
            z = float(coords[i3+2])
            
            i1 = i + 1
            reax.setpos(1, i1, x)
            reax.setpos(2, i1, y)
            reax.setpos(3, i1, z)

        self.energy = reax.pyencalc() * unit.kcalpermol

        natoms = self.natoms
        #forces = [0.0 for i in range(3*natoms)]
        forces = numpy.zeros(3 * natoms, numpy.Float64)
        for i in range(natoms):
            i3 = 3 * i
            i1 = i + 1
            forces[i3]   = -reax.getforce(1, i1)         
            forces[i3+1] = -reax.getforce(2, i1) 
            forces[i3+2] = -reax.getforce(3, i1) 

        self.forces = forces * unit.kcalpermol

        return self.energy, self.forces


    def getEnergy(self):
        #modreax.print_energies()
        #return (modreax.get_estr() + modreax.get_eb() + \
        #       modreax.get_ea() + modreax.get_ev()) * unit.kcalpermol
        #return (modreax.get_estr() * unit.kcalpermol)
        return self.energy
       

    def getForces(self):
        #natoms = self.natoms
        #forces = [0.0 for i in range(3*natoms)]
        #forces = numpy.zeros(3 * natoms, numpy.Float64)
        #for i in range(natoms):
        #    forces[3*i] = modreax.getforce(1, i+1) * unit.kcalpermol        
        #    forces[3*i+1] = modreax.getforce(2, i+1) * unit.kcalpermol
        #    forces[3*i+2] = modreax.getforce(3, i+1) * unit.kcalpermol
        return self.forces


    def calcValenceEnergyForce(self):
        modreax.pyencalc()
        return

