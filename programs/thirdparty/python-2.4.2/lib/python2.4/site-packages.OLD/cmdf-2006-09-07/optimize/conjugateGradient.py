#!usr/bin/env python
#########################################################################################################
# ConjugateGradient.py   : include Conjugate Gradient, BFGS (Shanno-Phua) and CG (MEE) methods.     # 
#                                                                                                       # 
# ConjugateGradient: Conjugate gradient method (FLETCHER-REEVES) for energy minimization.           # 
# This is a modified python version of WAG's CG subroutine in Lingraph (and MEE). The program switchs   # 
# to Steppest Descent (SD) method when CG does not work well. This code does not include the            #
# optimization of fixed (rigid) molecule.                                                               #
#                                                                                                       # 
# Shanno-Phua version for CG and BFGS methods.                                                                             # 
#                                                                                                       # 
# Created on 01/19/06, last revision on 06/16/06. yi                                                    #
#                                                                                                       # 
#########################################################################################################

import sys
import numpy 
import profile
from math import sqrt
#from cmdf.utility.utility_pf import Utility
from cmdf.utility.communication import systemToArrays, arraysToSystem_md, arraysToSystem_min
#import cmdf.utility.bgfio as bgfio
#from cmdf.dynamics.integrator_pf import VelocityVerlet_f
#from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3
#from cmdf.dynamics.mdEngine import MDEngine
#from cmdf.dynamics.thermostat_pf import BerendsenThermostat
#from cmdf.utility.control import Control    
#from cmdf.modbabel.modbabel import *          
import cmdf.mee.mee as mee
#from cmdf.mee.meeForceEngine import MeeForceEngine
#from cmdf.reax.reaxForceEngine import ReaxForceEngine
from cmdf.optimize.shannoPhua_f import dmin, dmax, normsq, normsq2, rmscoords, steplength,  \
    trialpoint, deralpha, stepvector, searchvector_cg, searchvector_bfgs

class ConjugateGradient:

    def __init__(self, molName, nMethod, numSteps, threshold, freqOutput, degFree, coords):
        self.molName = molName
        self.nMethod = nMethod
        self.numSteps = numSteps
        self.threshold = threshold
        self.freqOutput = freqOutput
        self.degFree = degFree
        self.coords = coords

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        return

class ConjugateGradient_MEE(ConjugateGradient):

    def __init__(self, numSteps, threshold):
        #ConjugateGradient.__init__(self, molName, nMethod, numSteps, threshold, freqOutput, degFree, coords)
        self.numSteps = numSteps
        self.threshold = threshold

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        mee.cmdf_mee_set_minimization_parameters(self.numSteps, self.threshold)
        mee.cmdf_mee_minimize_cg()

        return

    """
    /*
    C REMARK ON ALGORITHM 500
    C
    C MINIMIZATION OF UNCONSTRAINED MULTIVARIATE FUNCTIONS
    C
    C BY D.F. SHANNO AND K.H. PHUA
    C
    C ACM TRANSACTIONS ON MATHEMATICAL SOFTWARE 6 (DECEMBER 1980),
    C 618-622
    C
    C TEST PROGRAM TO TEST CONMIN ON WOODS FUNCTION                         CNMN0001
    */
    
    /* Translated from the FORTRAN version by Julius Su, jsu@caltech.edu, 2-15-06
       Original FORTRAN source:
         http://www.netlib.org/toms/500
    
       Changes made:
       -- NFLAG returned as return value, not entered as argument.
       -- IDEV not included, defaults to std. output.
       -- A function to be called every IOUT iterations is included here.
       -- Function to evaluate entered in as a function pointer.
       -- arrays made into C-arrays that are indexed from zero, not one.
    */
    
    This Python version of Shanno-Phua minimizer is migrated from Julius' C++ minimizer.
    
        Major changes are:
        - Eliminate GO TO statements while keep original flow.
        - Input and output of conmin function.
        - Output results to file. RMS gradient rather than gradient square are saved. 
        - Use force engine as evaluation function. 
        - Use absolute RMS gradient as convergence threshold.
    
    Last revision: April 13, 2006 by Yi Liu, yi@wag.caltech.edu 
    """
    """
    # Woods function for test. 
    def calcfg(x):
    
        degFree = len(x)
        g = [0.] * degFree
        a = x[1] - x[0] * x[0]
        b = x[3] - x[2] * x[2]
        f = 100 * a * a + (1.0 - x[0]) * (1.0 - x[0])  \
           + 90 * b * b + (1.0 - x[2]) * (1.0 - x[2])  \
           + 10.1 * ((x[1] - 1) * (x[1] - 1) + (x[3] - 1) * (x[3] - 1))  \
           + 19.8 * (x[1] - 1) * (x[3] - 1)
        g[0] = -2 * (200 * x[0] * a + 1.0 - x[0])
        g[1] = 2 * (100 * a + 10.1 * (x[1] - 1.0) + 9.9 * (x[3] - 1.0))
        g[2] = -2 * (180 * x[2] * b + 1.0 - x[2])
        g[3] = 2 * (90 * b + 10.1 * (x[3] - 1) + 9.9 * (x[1] - 1.0))
        
        return f, g
    
    def dmin(a, b):
        if a <= b:
            return a
        else:
            return b
    
    def dmax(a, b):
        if a >= b:
            return a
        else:
            return b
    """
    
    
class ConjugateGradient_SP(ConjugateGradient):

    def __init__(self, molName='cmdf', nMethod=0, numSteps=1000, threshold=0.01, freqOutput=100, degFree=3, coords=numpy.zeros([1],numpy.Float)):
        ConjugateGradient.__init__(self, molName, nMethod, numSteps, threshold, freqOutput, degFree, coords)
        return

    def initialize(self):

        return

    """
    /*   
    C PURPOSE:    SUBROUTINE CONMIN MINIMIZES AN UNCONSTRAINED NONLINEAR
    C             SCALAR VALUED FUNCTION OF A VECTOR VARIABLE X
    C             EITHER BY THE BFGS VARIABLE METRIC ALGORITHM OR BY A
    C             BEALE RESTARTED CONJUGATE GRADIENT ALGORITHM.
    C
    C USAGE:      CALL CONMIN(N,X,F,G,IFUN,ITER,EPS,NFLAG,MXFUN,W,
    C             IOUT,MDIM,IDEV,ACC,NMETH)
    C
    C PARAMETERS: N      THE NUMBER OF VARIABLES IN THE FUNCTION TO
    C                    BE MINIMIZED.
    C             X      THE VECTOR CONTAINING THE CURRENT ESTIMATE TO
    C                    THE MINIMIZER. ON ENTRY TO CONMIN,X MUST CONTAIN
    C                    AN INITIAL ESTIMATE SUPPLIED BY THE USER.
    C                    ON EXITING,X WILL HOLD THE BEST ESTIMATE TO THE
    C                    MINIMIZER OBTAINED BY CONMIN. X MUST BE DOUBLE
    C                    PRECISIONED AND DIMENSIONED N.
    C             F      ON EXITING FROM CONMIN,F WILL CONTAIN THE LOWEST
    C                    VALUE OF THE OBJECT FUNCTION OBTAINED.
    C                    F IS DOUBLE PRECISIONED.
    C             G      ON EXITING FROM CONMIN,G WILL CONTAIN THE
    C                    ELEMENTS OF THE GRADIENT OF F EVALUATED AT THE
    C                    POINT CONTAINED IN X. G MUST BE DOUBLE
    C                    PRECISIONED AND DIMENSIONED N.
    C             IFUN   UPON EXITING FROM CONMIN,IFUN CONTAINS THE
    C                    NUMBER OF TIMES THE FUNCTION AND GRADIENT
    C                    HAVE BEEN EVALUATED.
    C             ITER   UPON EXITING FROM CONMIN,ITER CONTAINS THE
    C                    TOTAL NUMBER OF SEARCH DIRECTIONS CALCULATED
    C                    TO OBTAIN THE CURRENT ESTIMATE TO THE MINIZER.
    C             EPS    EPS IS THE USER SUPPLIED CONVERGENCE PARAMETER.
    C                    CONVERGENCE OCCURS WHEN THE NORM OF THE GRADIENT
    C                    IS LESS THAN OR EQUAL TO EPS TIMES THE MAXIMUM
    C                    OF ONE AND THE NORM OF THE VECTOR X. EPS
    C                    MUST BE DOUBLE PRECISIONED.
    C             NFLAG  UPON EXITING FROM CONMIN,NFLAG STATES WHICH
    C                    CONDITION CAUSED THE EXIT.
    C                    IF NFLAG=0, THE ALGORITHM HAS CONVERGED.
    C                    IF NFLAG=1, THE MAXIMUM NUMBER OF FUNCTION
    C                       EVALUATIONS HAVE BEEN USED.
    C                    IF NFLAG=2, THE LINEAR SEARCH HAS FAILED TO
    C                       IMPROVE THE FUNCTION VALUE. THIS IS THE
    C                       USUAL EXIT IF EITHER THE FUNCTION OR THE
    C                       GRADIENT IS INCORRECTLY CODED.
    C                    IF NFLAG=3, THE SEARCH VECTOR WAS NOT
    C                       A DESCENT DIRECTION. THIS CAN ONLY BE CAUSED
    C                       BY ROUNDOFF,AND MAY SUGGEST THAT THE
    C                       CONVERGENCE CRITERION IS TOO STRICT.
    C             MXFUN  MXFUN IS THE USER SUPPLIED MAXIMUM NUMBER OF
    C                    FUNCTION AND GRADIENT CALLS THAT CONMIN WILL
    C                    BE ALLOWED TO MAKE.
    C             W      W IS A VECTOR OF WORKING STORAGE.IF NMETH=0,
    C                    W MUST BE DIMENSIONED 5*N+2. IF NMETH=1,
    C                    W MUST BE DIMENSIONED N*(N+7)/2. IN BOTH CASES,
    C                    W MUST BE DOUBLE PRECISIONED.
    C             IOUT   IOUT IS A USER  SUPPLIED OUTPUT PARAMETER.
    C                    IF IOUT = 0, THERE IS NO PRINTED OUTPUT FROM
    C                    CONMIN. IF IOUT > 0,THE VALUE OF F AND THE
    C                    NORM OF THE GRADIENT SQUARED,AS WELL AS ITER
    C                    AND IFUN,ARE WRITTEN EVERY IOUT ITERATIONS.
    C             MDIM   MDIM IS THE USER SUPPLIED DIMENSION OF THE
    C                    VECTOR W. IF NMETH=0,MDIM=5*N+2. IF NMETH=1,
    C                    MDIM=N*(N+7)/2.
    C             IDEV   IDEV IS THE USER SUPPLIED NUMBER OF THE OUTPUT
    C                    DEVICE ON WHICH OUTPUT IS TO BE WRITTEN WHEN
    C                    IOUT>0.
    C             ACC    ACC IS A USER SUPPLIED ESTIMATE OF MACHINE
    C                    ACCURACY. A LINEAR SEARCH IS UNSUCCESSFULLY
    C                    TERMINATED WHEN THE NORM OF THE STEP SIZE
    C                    BECOMES SMALLER THAN ACC. IN PRACTICE,
    C                    ACC=10.D-20 HAS PROVED SATISFACTORY. ACC IS
    C                    DOUBLE PRECISIONED.
    C             NMETH  NMETH IS THE USER SUPPLIED VARIABLE WHICH
    C                    CHOOSES THE METHOD OF OPTIMIZATION. IF
    C                    NMETH=0,A CONJUGATE GRADIENT METHOD IS
    C                    USED. IF NMETH=1, THE BFGS METHOD IS USED.
    C
    C REMARKS:    IN ADDITION TO THE SPECIFIED VALUES IN THE ABOVE
    C             ARGUMENT LIST, THE USER MUST SUPPLY A SUBROUTINE
    C             CALCFG WHICH CALCULATES THE FUNCTION AND GRADIENT AT
    C             X AND PLACES THEM IN F AND G(1),...,G(N) RESPECTIVELY.
    C             THE SUBROUTINE MUST HAVE THE FORM:
    C                    SUBROUTINE CALCFG(N,X,F,G)
    C                    DOUBLE PRECISION X(N),G(N),F
    C
    C             AN EXAMPLE SUBROUTINE FOR THE ROSENBROCK FUNCTION IS:
    C
    C                    SUBROUTINE CALCFG(N,X,F,G)
    C                    DOUBLE PRECISION X(N),G(N),F,T1,T2
    C                    T1=X(2)-X(1)*X(1)
    C                    T2=1.0-X(1)
    C                    F=100.0*T1*T1+T2*T2
    C                    G(1)=-400.0*T1*X(1)-2.0*T2
    C                    G(2)=200.0*T1
    C                    RETURN
    C                    END
    C
    */
    """

    def conmin(self, molName, n, x, f, g, eps, maxfun, w, iout, mdim, acc, nmeth, forceEngine, freqOutput):
        from cmdf.utility.control import Control


        def outputCG(num_iterations, num_fevals, f_val, f_diff, x_rms, g_rms):
   
            miniFile = open(molName+'.min', 'a')
            miniFile.write("%6i %6i %18.10e %18.10e %18.10e %18.10e\n" % (num_iterations, num_fevals, f_val, f_diff, x_rms, g_rms))
            miniFile.close()
            return

      #/* INITIALIZE ITER,IFUN,NFLAG,AND IOUTK,WHICH COUNTS OUTPUT ITERATIONS. */
        iter = 0
        ifun = 0
        ioutk = 0
        nflag = 0
        alpha = 0.  #yi
        dg = 0.  #yi
        epsq = eps * eps  #yi
        fold = f   #yi 
        xold = x.copy()  #yi
    
      #/* SET PARAMETERS TO EXTRACT VECTORS FROM W.
      #W(I) HOLDS THE SEARCH VECTOR,W(NX+I) HOLDS THE BEST CURRENT
      #ESTIMATE TO THE MINIMIZER,AND W(NG+I) HOLDS THE GRADIENT
      #AT THE BEST CURRENT ESTIMATE.
      #*/
    
        nx = n
        ng = nx + n
    
      #/* TEST WHICH METHOD IS BEING USED.
      #IF NMETH=0, W(NRY+I) HOLDS THE RESTART Y VECTOR AND
      #W(NRD+I) HOLDS THE RESTART SEARCH VECTOR.
      #*/
    
        #/* IF NMETH=1,W(NCONS+I) HOLDS THE APPROXIMATE INVERSE HESSIAN. */
        if nmeth == 1:
            ncons = 3 * n
        elif nmeth == 0:
            nry = ng + n;
            nrd = nry + n;
            ncons = 5 * n;
            ncons0 = ncons + 0;
            ncons1 = ncons + 1;
    
      #/* CALCULATE THE FUNCTION AND GRADIENT AT THE INITIAL
      #POINT AND INITIALIZE NRST,WHICH IS USED TO DETERMINE
      #WHETHER A BEALE RESTART IS BEING DONE. NRST=N MEANS THAT THIS
      #ITERATION IS A RESTART ITERATION. INITIALIZE RSW,WHICH INDICATES
      #THAT THE CURRENT SEARCH DIRECTION IS A GRADIENT DIRECTION.
      #*/
    
        goto20 = False  
        while 1:
            #fold = f  # yi
            #forceEngine.setCoords(x)
            #forceEngine.calcEnergyForce()
            #f = forceEngine.getEnergy()
            #g = -forceEngine.getForces()
            f, forces = forceEngine.calcEnergyForce(x)
            g = -forces 
            ifun += 1
            nrst = numpy.array([n], numpy.Int)
            rsw = True
    
      #/* CALCULATE THE INITIAL SEARCH DIRECTION , THE NORM OF X SQUARED,
      #AND THE NORM OF G SQUARED. DG1 IS THE CURRENT DIRECTIONAL
      #DERIVATIVE,WHILE XSQ AND GSQ ARE THE SQUARED NORMS.
      #*/
            #dg1 = 0
            #xsq = 0
            #for i in range(n):
            #    w[i] = -g[i]
            #    xsq += x[i] * x[i]
            #    dg1 -= g[i] * g[i]
            w, xsq, dg1 = normsq(x, g, w)  # Fortran module of above loop.
            #print 'xsq, dg1=', xsq, dg1 
    
            gsq = -dg1
    
      #/* TEST IF THE INITIAL POINT IS THE MINIMIZER. */
            #if (gsq <= eps * eps * dmax(xsq, 1.0)):
            #yi
            gsqn = gsq / n
            if (gsqn <= epsq):
                rmsg = sqrt(gsqn) / Control.printEnergyUnit
                fminOut = f / Control.printEnergyUnit 
                foldOut = fold / Control.printEnergyUnit
                f_diff = fminOut - foldOut
                rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                return nflag, iter, ifun, x, f, g
    
      #/* BEGIN THE MAJOR ITERATION LOOP. NCALLS IS USED TO GUARANTEE THAT
      #AT LEAST TWO POINTS HAVE BEEN TRIED WHEN NMETH=0. FMIN IS THE
      #CURRENT FUNCTION VALUE.
      #*/
            while 1:
                fmin = f
                ncalls = ifun
      #/* IF OUTPUT IS DESIRED,TEST IF THIS IS THE CORRECT ITERATION
      #AND IF SO, WRITE OUTPUT. 
      #*/
                if iout != 0:
                    if ioutk == 0 and iter%freqOutput == 0:
                        #yi
                        gsqn = gsq / n
                        rmsg = sqrt(gsqn) / Control.printEnergyUnit
                        fminOut = f / Control.printEnergyUnit 
                        foldOut = fold / Control.printEnergyUnit
                        f_diff = fminOut - foldOut
                        rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                        outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                    ioutk += 1
                    if ioutk == iout: ioutk = 0
      #/* BEGIN LINEAR SEARCH. ALPHA IS THE STEPLENGTH.
      #SET ALPHA TO THE NONRESTART CONJUGATE GRADIENT ALPHA.
      #*/
    #label_60:
                alpha *= dg / dg1
    
      #/* IF NMETH=1 OR A RESTART HAS BEEN PERFORMED, SET ALPHA=1.0. */
                if nrst[0] == 1 or nmeth == 1:
                    alpha = 1.0
    
      #/* IF A GRADIENT DIRECTION IS USED, SET ALPHA=1.0/DSQRT(GSQ),
      #WHICH SCALES THE INITIAL SEARCH VECTOR TO UNITY.
      #*/
                if rsw:
                    alpha = 1.0 / sqrt(gsq)
    
      #/* THE LINEAR SEARCH FITS A CUBIC TO F AND DAL, THE FUNCTION AND ITS
      #DERIVATIVE AT ALPHA, AND TO FP AND DP,THE FUNCTION
      #AND DERIVATIVE AT THE PREVIOUS TRIAL POINT AP.
      #INITIALIZE AP ,FP,AND DP.
      #*/
                ap = 0
                fp = fmin
                dp = dg1
    
      #/* SAVE THE CURRENT DERIVATIVE TO SCALE THE NEXT SEARCH VECTOR. */
                dg = dg1
    
      #/* UPDATE THE ITERATION. */
                iter += 1
    
      #/* CALCULATE THE CURRENT STEPLENGTH  AND STORE THE CURRENT X AND G. */
                #step = 0
                #for i in range(n):
                #    step += w[i] * w[i]
                #    nxpi = nx + i
                #    ngpi = ng + i
                #    w[nxpi] = x[i]
                #    w[ngpi] = g[i]
    
                #step = sqrt(step)  
                w, step = steplength(nx, ng, x, g, w)
                #print 'step =', step
    
      #/* BEGIN THE LINEAR SEARCH ITERATION.
      #TEST FOR FAILURE OF THE LINEAR SEARCH.
      #*/
                while 1:  
                    if alpha * step < acc:
      #/* TEST IF DIRECTION IS A GRADIENT DIRECTION. */
                        if not rsw:
                            goto20 = True  
                            break  
                        nflag = 2
                        #yi
                        gsqn = gsq / n
                        rmsg = sqrt(gsqn) / Control.printEnergyUnit
                        fminOut = f / Control.printEnergyUnit 
                        foldOut = fold / Control.printEnergyUnit
                        f_diff = fminOut - foldOut
                        rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                        outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                        return nflag, iter, ifun, x, f, g  # Line search failed maybe because calcfg is not correctly coded.
    
      #/* CALCULATE THE TRIAL POINT. */
                    #for i in range(n):
                    #    nxpi = nx + i
                    #    x[i] = w[nxpi] + alpha * w[i]
                    xold = x.copy()  # yi save old coordinates
                    x = trialpoint(nx, x, w, alpha)
                    rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                    #print 'x[0], x[n-1]=', x[0], x[n-1]
     
      #/* EVALUATE THE FUNCTION AT THE TRIAL POINT. */
                    fold = f  # yi save old energy
                    #forceEngine.setCoords(x)
                    #forceEngine.calcEnergyForce()
                    #f = forceEngine.getEnergy()
                    #g = -forceEngine.getForces()
                    f, forces = forceEngine.calcEnergyForce(x)
                    g = -forces
    
      #/* TEST IF THE MAXIMUM NUMBER OF FUNCTION CALLS HAVE BEEN USED. */
                    ifun += 1
                    if ifun > maxfun:
                        nflag = 1
                        #yi
                        gsqn = gsq / n
                        rmsg = sqrt(gsqn) / Control.printEnergyUnit
                        fmin = f
                        fminOut = f / Control.printEnergyUnit 
                        foldOut = fold / Control.printEnergyUnit
                        f_diff = fminOut - foldOut
                        rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                        outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                        return nflag, iter, ifun, x, f, g  # return because maximum function calls reached
    
      #/* COMPUTE THE DERIVATIVE OF F AT ALPHA. */
                    #dal = 0.0
                    #for i in range(n):
                    #    dal += g[i] * w[i]
                    dal = deralpha(g, w)
                    #print 'dal = ', dal
    
      #/* TEST WHETHER THE NEW POINT HAS A NEGATIVE SLOPE BUT A HIGHER
      #FUNCTION VALUE THAN ALPHA=0. IF THIS IS THE CASE,THE SEARCH
      #HAS PASSED THROUGH A LOCAL MAX AND IS HEADING FOR A DISTANT LOCAL
      #MINIMUM. 
      #*/
                    if f > fmin and dal < 0:
                        #/* A RELATIVE MAX HAS BEEN PASSED.REDUCE ALPHA AND RESTART THE SEARCH. */
                        alpha = alpha / 3.0
                        ap = 0
                        fp = fmin
                        dp = dg
                        continue  
    
                    #/* IF NOT, TEST WHETHER THE STEPLENGTH CRITERIA HAVE BEEN MET. */
                    if f < (fmin+.0001*alpha*dg) and abs(dal/dg) < .9:  # eq. (1) and (2) in ref.
                        #/* IF THEY HAVE BEEN MET, TEST IF TWO POINTS HAVE BEEN TRIED
                        #IF NMETH=0 AND IF THE TRUE LINE MINIMUM HAS NOT BEEN FOUND.
                        #*/
                        if (ifun-ncalls) > 1 or abs(dal/dg) < eps or nmeth != 0:
                            #/* THE LINE SEARCH HAS CONVERGED. TEST FOR CONVERGENCE OF THE ALGORITHM. */
                            #gsq = 0.0;
                            #xsq = 0.0;
                            #for i in range(n):
                            #    gsq += g[i] * g[i]
                            #    xsq += x[i] * x[i]
                            xsq, gsq = normsq2(x, g)
                            #print 'gsq = ', gsq
                            #print 'xsq = ', xsq
    
                            #if gsq <= eps * eps * dmax(1.0, xsq):
                            #yi
                            gsqn = gsq / n
                            if gsqn <= epsq:
                                rmsg = sqrt(gsqn) / Control.printEnergyUnit
                                fminOut = f / Control.printEnergyUnit 
                                foldOut = fold / Control.printEnergyUnit
                                f_diff = fminOut - foldOut
                                rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                                outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                                return nflag, iter, ifun, x, f, g  # normal return as converged
                            
                            #/* SEARCH CONTINUES. SET W(I)=ALPHA*W(I),THE FULL STEP VECTOR. */
                            #for i in range(n):
                            #    w[i] *= alpha
                            w = stepvector(n, w, alpha)
                            #print 'w[0]=', w[0]
                            break  
    
      #/* A NEW POINT MUST BE TRIED. USE CUBIC INTERPOLATION TO FIND
      #THE TRIAL POINT AT.
      #*/
                    u1 = dp + dal - 3.0 * (fp - f) / (ap - alpha)
                    u2 = u1 * u1 - dp * dal
                    if u2 < 0: u2 = 0
                    u2 = sqrt(u2)
                    at = alpha - (alpha - ap) * (dal + u2 - u1) / (dal - dp + 2 * u2)
    
                    #/* TEST WHETHER THE LINE MINIMUM HAS BEEN BRACKETED. */
                    if (dal/dp) > 0:
                        #/* THE MINIMUM HAS NOT BEEN BRACKETED. TEST IF BOTH POINTS ARE
                        #GREATER THAN THE MINIMUM AND THE TRIAL POINT IS SUFFICIENTLY
                        #SMALLER THAN EITHER.
                        #*/
                        if dal > 0.0 and 0.0 < at and at < 0.99 * dmin(ap, alpha):
                            ap = alpha
                            fp = f
                            dp = dal
                            alpha = at
                            continue  
                        
                        #/* TEST IF BOTH POINTS ARE LESS THAN THE MINIMUM AND THE TRIAL POINT
                        #IS SUFFICIENTLY LARGE. */
                        if dal <= 0.0 and at > 1.01 * dmax(ap, alpha):
                            ap = alpha
                            fp = f
                            dp = dal
                            alpha = at
                            continue  
                        
                        #/* IF THE TRIAL POINT IS TOO SMALL,DOUBLE THE LARGEST PRIOR POINT. */
                        if dal <= 0:
                            at = 2.0 * dmax(ap, alpha)
    
                        #/* IF THE TRIAL POINT IS TOO LARGE, HALVE THE SMALLEST PRIOR POINT. */
                        if dal > 0:
                            at = dmin(ap, alpha) / 2.0
                            
                        ap = alpha
                        fp = f
                        dp = dal
                        alpha = at
                        continue  
    
                    #/* THE MINIMUM HAS BEEN BRACKETED. TEST WHETHER THE TRIAL POINT LIES
                    #SUFFICIENTLY WITHIN THE BRACKETED INTERVAL.
                    #IF IT DOES NOT, CHOOSE AT AS THE MIDPOINT OF THE INTERVAL.
                    #*/
                    if at < (1.01 * dmin(alpha, ap)) or at > 0.99 * dmax(alpha,ap):
                        at = (alpha + ap) / 2.0
                        
                    ap = alpha
                    fp = f
                    dp = dal
                    alpha = at
                    continue  
                if goto20: break  
                
      #/* COMPUTE THE NEW SEARCH VECTOR. FIRST TEST WHETHER A
      #CONJUGATE GRADIENT OR A VARIABLE METRIC VECTOR IS USED. 
      #*/
                if nmeth == 0:  # CG algorithm
                    # Get new search vector dg1 and nrst for checking restart.
                    w, nrst, dg1 = searchvector_cg(nx, ng, nry, nrd, ncons, ncons0, ncons1, gsq, g, w, nrst)
                    #print 'dg1_CG =', dg1 
    
      #/* IF THE NEW DIRECTION IS NOT A DESCENT DIRECTION, STOP. */
                    if dg1 > 0:
                        nflag = 3
                        #yi
                        gsqn = gsq / n
                        rmsg = sqrt(gsqn) / Control.printEnergyUnit
                        fminOut = f / Control.printEnergyUnit 
                        foldOut = fold / Control.printEnergyUnit
                        f_diff = fminOut - foldOut
                        rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                        outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                        return nflag, iter, ifun, x, f, g
    
      #/* UPDATE NRST TO ASSURE AT LEAST ONE RESTART EVERY N ITERATIONS. */
                    if nrst[0] == n:
                        nrst[0] = 0
                    
                    nrst[0] += 1
                    rsw = False
                    continue  
    
                #/* A VARIABLE METRIC ALGORITM IS BEING USED. CALCULATE Y AND D'Y. */
                elif nmeth == 1:  # BFGS algorithm
                    # Get new search vector dg1.
                    irsw = int(rsw)
                    w, dg1 = searchvector_bfgs(nx, ng, ncons, irsw, g, w)
                    #print 'for, dg1_BFGS=', dg1
    
      #/* TEST FOR A DOWNHILL DIRECTION. */
                    if dg1 > 0:
                        nflag = 3
                        gsqn = gsq / n
                        rmsg = sqrt(gsqn) / Control.printEnergyUnit
                        fminOut = f / Control.printEnergyUnit 
                        foldOut = fold / Control.printEnergyUnit
                        f_diff = fminOut - foldOut
                        rmsx = rmscoords(x, xold)  # Calculate RMS coordinates.
                        outputCG(iter, ifun, fminOut, f_diff, rmsx, rmsg)
                        return nflag, iter, ifun, x, f, g
                    
                    rsw = False
                    continue
                if goto20: break
            if goto20: continue 
        return nflag, iter, ifun, x, f, g
    
    def run(self, system, forceEngine):
        from cmdf.utility.control import Control

        molName = self.molName
        nmeth = self.nMethod
        maxfun = self.numSteps
        threshold = self.threshold
        freqOutput = self.freqOutput
        degFree = self.degFree
        coords = self.coords
        # Choose method:
        #nmeth = 0 # CG
        #nmeth = 1 # BFGS quasi-newton
    
        if nmeth == 0:
            mdim = 5 * degFree + 2
        elif nmeth == 1:
            mdim = degFree * (degFree + 7) / 2
    
        f = 0.
        #x = [0.] * degFree
        #g = [0.] * degFree
        #w = [0.] * mdim
        x = numpy.zeros(degFree, numpy.Float)
        g = numpy.zeros(degFree, numpy.Float)
        w = numpy.zeros(mdim, numpy.Float)
        acc = 1.e-20
        #eps = .00001
        iout = 1
    
        # Initial estimate of x for test function.
        #x[0] = -3.
        #x[1] = -1.0
        #x[2] = -3.
        #x[3] = -1.0
        
        x = coords
        #forceEngine.setCoords(coords)
        #forceEngine.calcEnergyForce()
        #f = forceEngine.getEnergy()
        #g = -forceEngine.getForces()
        f, forces = forceEngine.calcEnergyForce(coords)
        g = -forces
    
        miniFile = open(molName+'.min', 'a')
        if nmeth == 0:
            miniFile.write('%12s<<< CMDF minimization with conjugate gradient method (Shanno-Phua) >>>\n' % (' '))
        elif nmeth == 1:
            miniFile.write('%12s<<< CMDF minimization with BFGS quasi-newton method (Shanno-Phua) >>>\n' % (' '))
        #miniFile.write("Initial coordinates =\n")
        #for i in range(degFree/3):
        #    miniFile.write("%e\t%e\t%e\t\n" % (x[3*i], x[3*i+1], x[3*i+2]))
        #miniFile.write("Initial forces =\n")
        #for i in range(degFree/3):
        #    miniFile.write("%e\t%e\t%e\t\n" % (g[3*i], g[3*i+1], g[3*i+2]))
        strEnergy = 'Energy('+Control.printEnergyFlag+')'
        strEnergyDiff = 'Energy_diff'
        miniFile.write('%8s%8s%17s %14s %18s %17s\n' % ('N_iter','N_func',strEnergy,strEnergyDiff,'RMS_coords','RMS_force'))
        miniFile.flush()
            
        nflag, iter, ifun, x, f, g = self.conmin(molName, degFree, x, f, g, threshold, maxfun, w, iout, mdim, acc, nmeth, forceEngine, freqOutput)

        miniFile.write("Final energy= %18.10e\n" % (f / Control.printEnergyUnit))
        miniFile.write("nflag = %6i, total N_iterations = %6i, total N_function_calls = %6i\n" % (nflag, iter, ifun))
        #miniFile.write("Final coordinates =\n")
        #for i in range(degFree/3):
        #    miniFile.write("%e\t%e\t%e\t\n" % (x[3*i], x[3*i+1], x[3*i+2]))
        #miniFile.write("Final forces =\n")
        #for i in range(degFree/3):
        #    miniFile.write("%e\t%e\t%e\t\n" % (g[3*i] / Control.printEnergyUnit, g[3*i+1] / Control.printEnergyUnit, g[3*i+2] / Control.printEnergyUnit))
        #miniFile.close()

        if nflag == 0: 
            miniFile.write("<< Minimization converged >>\n")
        elif nflag == 1: 
            miniFile.write("<< Maximum steps reached >>\n")
        elif nflag == 2: 
            miniFile.write("<< Linear search failed >>\n")
        elif nflag == 3: 
            miniFile.write("<< Convergence criteria too strict >>\n")

        arraysToSystem_min(system, x, f, g)  # Update system information.

        return

# This CG_FR is not working with array-based force engine.
# I may not make it work due to the performance concern.
class ConjugateGradient_FR(ConjugateGradient):

    def __init__(self, molName='cmdf', nMethod=0, numSteps=1000, threshold=0.01, freqOutput=100, degFree=3, coords=numpy.zeros([1],numpy.Float)):
        ConjugateGradient.__init__(self, molName, nMethod, numSteps, threshold, freqOutput, degFree, coords)
        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        #import datetime
        #import random
        #from math import sqrt
        #from control import Control
        #from utility_pf import Utility
        UTI = Utility()

        numSteps = self.numSteps
        threshold = self.threshold
        outFreq = self.freqOutput
    
        molecule = system.getMolecule(0)
        ### Here numatoms should be movable atoms if fixed atoms exist.
        numatoms = molecule.numAtoms()
        molName = molecule.getName()
    
    #     PathXYZ HAS CURRENT CG PATH, PathXYZ[3*numatoms] 
    #     NEWX IS X FOR CURRENT PTHSTP, THIS IS UPDATED INTO X AT END OF
    #       CURRENT PTHNUM
    #
    #     DOLDX IS X COMP OF GRADDIF VECTOR = GRAD(N)-GRAD(N-1) WHERE N
    #       REFERS TO THE FIRST GRADIENT ALONG A PATH
    #
    #     IF STEEPDSSAV = True then always does steepest descents
    #       otherwise, does conjugate gradients (but does sd step when thing
    #       go badly
    
    #yi Maximal gradients beyond which one just does simple displacement rather than CG or SD.
        MAXGRD = 1.0e16
        MAXDERIV = 1.0e16 
    # PTHNUM is number of CG pathways (iterations)
    # PTHSTP is number of energy steps for current CG pathways
    # PTHSTPMX is maximum number of energy steps for one pathway
        STEPDEF = 0.02
        PTHSTPMX = 30  #yi Original is 20.
    
    # use standard multiplier for bracketing
        GOLD = 1.618034
    
    #***********************
    #*** INITIALIZATION
    #**********************
        STPMIN = 0.00001
        STPMAX = 1.0e6  # yi 
        ISTART = 1
        ISTOP = numSteps
        TOLGRD = threshold  
        STEEPDSSAV = False # Logical variable to control whether next step is cg (False) or sd (True).
    
        SQRTMOV3 = sqrt(numatoms * 3)
    
    # FOR OUTPUT, NEED HERE IN CASE NOT CALL TOTFRC
        TSTRS=0.0
    
    #***********************
    #*** START CALCULATIONS
    #***********************
    #     SAVE COORDINATES FOR INITIAL GEOMETRY
    #
    #     INITIAL GEOM WILL REMAIN IN X... CURRENT GEOM WILL BE IN NEWX...
    #@    WAG WOULD LIKE TO CHANGE THIS SO THAT REF GEOM IS OLDX AND X IS
    #       ALWAYS THE CURRENT GEOM (DYN IS DONE THIS WAY)
    #@v250 note that minmiz already use x,y,z as current variables
    #     MOVE ALL ATOMS SINCE USE NEWX... FOR CALC ENERGY
    #     IF KEPT OLDX, THEN WOULD ONLY NEED TO KEEP NMOVATM SET
    
        NEWX= [0.]; NEWY= [0.]; NEWZ= [0.]
        curX= [0.]; curY= [0.]; curZ= [0.]
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            NEWX.append(atom.getX())
            NEWY.append(atom.getY())
            NEWZ.append(atom.getZ())
    
            curX.append(atom.getX())
            curY.append(atom.getY())
            curZ.append(atom.getZ())
    #
    #     START OUTPUT FOR MINIMIZATION
    #
        CGoutput = open(molName+'.min', 'a')
    
        if (STEEPDSSAV):
    #yi    if (miniFlag == 'SD'):
            CGoutput.write("%22s<<< CMDF minimization with Steepest Descents method >>>\n" % (' '))
        else:
    #yi    elif(miniFlag == 'CG'):
            CGoutput.write("%22s<<< CMDF minimization with Conjugate Gradient method >>>\n" % (' '))
    
    #
    #     CONVERGENCE CRITERIA:
    #
    #           CALCULATION IS CONVERGED IF GRDRMS.LE.TOLGRD, WHERE GRDRMS
    #           IS THE SQUARE ROOT OF THE AVERAGE FORCE SQUARED PER DEGREE
    #           OF FREEDOM
    #           REASONING IN CHOOSING TOLGRD:
    #           DELTX=RCURV*FORCE WHERE RCURV=1/(FORCE CONSTANT)
    #           A LOW FORCE CONSTANT IS 100 KCAL/A, HENCE RCURV=.01
    #           THUS A FORCE OF .1 WOULD CHANGE X BY LESS THAN .001
    #           THIS WOULD LEAD TO GRDRMS=0.1*SQRT(3*NATOM)
    #           RECOMMENDED TOLGRD=.1  FOR STRUCTURE OPTIMIZATION
    #           .01 FOR VIBRATIONAL CALCULATIONS
    #
    #     INITIALIZE VARIABLES FOR A SEQUENCE OF CG
    #
    #           RCURV IS RECIPRICAL CURVATURE, X(N+1)=X(N)-RCURV*ENRGRAD
    #
    #           CONJGRAD PATH: PATH(N+1) = -ENRGRAD(AT MIN OF PATH N) +
    #           BETA*PATH(N)
    #
    # First path will be SD not CG
        BETA = 0.
        CNTCG = 0
        STEPAV = 0.
        GRADAV = 0.
    # AFTER THE 1ST ITER, ABM IS THE FULL STEP ALONG LAST PATH
        ABM = STEPDEF
    #
    #     ON SUBSEQUENT PATHS, THE ENERGY AND GRADIENT WILL BE
    #           AVAILABLE FROM THE LAST CALC OF PREVIOUS PATH
    #
    
    # Cal. energy and rms force for molecule
        if Control.printLevel > 1:
            forceStart = datetime.datetime.now()
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)
        if Control.printLevel > 1:
            forceEnd = datetime.datetime.now()
            logFile = open(molName+'.log', 'a')
            logFile.write('CG force timing:\n'); logFile.flush()
            UTI.timer(molName, forceStart, forceEnd)
    
        GRDRMS = UTI.calcRMSforce(molecule)
    #     ESTART USED TO CALC EAVE AT END
        ESTART = molecule.getPotentialEnergy()
    
        PTHNUM = 0 
        PTHSTP = 2  #yi
        DIFE = 0.
        CORDRMS = 0.
    
    #   print "%s %12.6f, %12.6f \n" % ("Initial ESTART, GRDRMS = ", ESTART, GRDRMS)
    
    # Output information: Number of iteration(PTHNUM), number of energy calls(PTHSTP), 
    # potential energy, energy difference between last two steps, RMS force, 
    # and RMS coordinate between last two steps. 
        CGoutput.write("N_Iter.  N_Estep          Pot_E(eV)            Diff_E(eV)           RMS_Grad.            RMS_Coord.\n")  
    
        Ecur = ESTART
    
        def writeCGoutput():
            CGoutput.write("%6i  %6i  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                (PTHNUM-1, PTHSTP-1, Ecur, DIFE, GRDRMS, CORDRMS))
            return
    
        writeCGoutput()
    
        PTHNUM = ISTART 
    
        if (GRDRMS <= TOLGRD): 
            STOPMIN = True
            GRADAV = GRDRMS 
            ABM = 0.
            # go to 21, finish CG and store convergence info.
            NSTP = PTHNUM - ISTART + 1
            if (NSTP > 1):
                STEPAV = STEPAV/NSTP 
                GRADAV = GRADAV/NSTP 
            ISTOP = PTHNUM 
            CGoutput.write("%55s %12.6f %12.6f\n" % ("Minimization is converged (0) ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS))
    
            return 
        
    #yi Do simple displacement if force is too large.
        while (GRDRMS > MAXGRD):
            print "%s %12.6f \n" % ("Do simple displacement because force is too large. \
                                    GRDRMS = ", GRDRMS)
            for i in range(1, numatoms+1):
                atom = molecule.getAtomWithNumber(i)
                if atom.isMovable() != 1:
                    continue
                
                xnew = atom.getX() 
                ynew = atom.getY() 
                znew = atom.getZ() 
    
                fx = atom.getForceX() 
                fy = atom.getForceY() 
                fz = atom.getForceZ() 
    
                if (abs(fx) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fx >= 0.): 
                        xnew += displace 
                    else:
                        xnew -= displace 
                if (abs(fy) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fy >= 0.): 
                        ynew += displace 
                    else:
                        ynew -= displace 
                if (abs(fz) > MAXDERIV): 
                    displace = random.uniform(0.,1.) * 0.25 
                    if (fz >= 0.): 
                        znew += displace 
                    else:
                        znew -= displace 
    
                atom.setPosition(xnew, ynew, znew) #Update coordinate
    
            # Cal. energy and rms force for molecule
            if Control.printLevel > 1:
                forceStart = datetime.datetime.now()
            forceEngine.downloadCoords(molecule)
            forceEngine.calcEnergyForce()
            forceEngine.uploadEnergyForce(molecule)
            if Control.printLevel > 1:
                forceEnd = datetime.datetime.now()
                logFile = open(molName+'.log', 'a')
                logFile.write('CG force timing:\n'); logFile.flush()
                UTI.timer(molName, forceStart, forceEnd)
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
    #yi  The above loop continues until force is not too large compared to MAXDERIV.
    
        ESTART = molecule.getPotentialEnergy()
    
    #Check convergence again.
        if (GRDRMS <= TOLGRD): 
            STOPMIN = True
            GRADAV = GRDRMS 
            ABM = 0.
            # go to 21, finish CG and store convergence info.
            NSTP = PTHNUM - ISTART + 1
            if (NSTP > 1):
                STEPAV = STEPAV/NSTP 
                GRADAV = GRADAV/NSTP 
            ISTOP = PTHNUM 
            CGoutput.write("%50s %12.6f \n" % ("Minimization is converged (1) ==> GRDRMS = ", GRDRMS))
    
            return 
    
    #******************************
    #    ALL CG or SD PATHS START HERE
    #******************************
    #*** INITIALIZE NEW OPTIMIZATION PATH
        pathXYZ = [0.] * (3 * numatoms + 1)
    
        NCGCYC = 10 # yi added 
        GRDRMS0 = GRDRMS # yi added 
    
        cm0 = UTI.calcPositionCM(molecule)  # get the original CM of the molecule
    
        STOPMIN = False
        FRSTSTP = True
    
        while (PTHNUM <= ISTOP and not STOPMIN):  #80
    
            if ((PTHNUM-1) % outFreq == 0): writeCGoutput()  #yi
    
            PTHSTP = 0  #yi
    
    #     SHIFT CM BACK TO REFERENCE VALUE (CALC BY calCM1)
            UTI.translateCM2(molecule, NEWX, NEWY, NEWZ, cm0) #Translate the system NEWX to original refernce cm0
            # translateCM1(molecule, cm0) #Translate the molecule to original refernce cm0
    
    #     THE COORD FOR THIS INITIAL POINT ARE KEPT IN X..
    #******************************
    #     CACULATE PATH
    #********************************
    #     HAVE ALREADY CALCULATED E,DX..,GRDRMS,DF FOR CURRENT POINT
    #           (0) GET NEW DIRECTION (P) AND DERIVATIVE ALONG THIS
    #           DIRECTION (GRDPRJ0)
    #
    #     NCGCYC=10 IS THE NUMBER OF STEPS BEFORE THE P ARRAY IS DISCARDED A
    #         THE CG IS REINITIALIZED
    #
            PTHNRM = 0.
            GRDPRJ0 = 0.
    
            if (CNTCG % NCGCYC == 0):
    #        if (miniFlag == 'SD'):  #yi
    #
    #    Steepest Descent Path
    #
    #            print "SD path, PTHNUM=", PTHNUM
                STEEPDS = True
                CNTCG = 0
                BETA = 0.
                PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0)
    
            else:
    #        elif (miniFlag == 'CG'): #yi 
    #       CONJ GRAD PATH
    #
    #       ESTIMATE BETA FOR NEXT ITERATION
    #
    #       PATH(N)=-GRAD(N) + BETA(N-1)*PATH(N-1)
    #       X(N+1)-X(N)=LAMBDA*PATH(N) WHERE LAMBDA LEADS TO A MINIMUM
    #         N=1: START WITH X(1), CALC GRAD(1), THEN PATH(1) USING
    #            BETA(0)=0 THEN CALC X(2)
    #         N=2: CALC GRAD(2), THEN BETA(1), THEN PATH(2), THEN LAMBDA,
    #            THEN X(3)...
    #
    #       FLETCHER-REEVES:
    #           BETA(N-1)=GRAD(N)**2/GRAD(N-1)**2
    #
    #       WOLFE:           {GRAD(N) dot (GRAD(N)-GRAD(N-1))}
    #           BETA(N-1)=   ---------------------------------
    #                        {PATH(N-1) dot (GRAD(N)-GRAD(N-1))}
    #
    #         NOT RESET GRDRMS0 UNTIL BELOW
    
    # Fletcher-Reeves CG method
                BETA = GRDRMS * GRDRMS/(GRDRMS0 * GRDRMS0)
    
                if (abs(BETA) > 10.): 
                    # CG beta is too large. Switch back to SD.
                    print "CG BETA is too large==> do SD path. PTHNUM = %i" % (PTHNUM)
                    STEEPDS = True
                    CNTCG = 0
                    BETA = 0.
                    PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # SD path
                else:
    #                print "CG path, PTHNUM = %i" % (PTHNUM)
                    PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # CG path
    
                    if (GRDPRJO > (-0.1*TOLGRD)):
                        # First point has too small slope along CG path, will do SD instead.
                        print "First point has too small slope along CG path==> do SD path. PTHNUM = %i" \
                            % (PTHNUM)
                        STEEPDS = True
                        CNTCG = 0
                        BETA = 0.
                        PTHNRM, GRDPRJO = self.newPath(molecule, pathXYZ, BETA, PTHNRM, GRDPRJ0) # SD path
    
    #     ENERGY AT START OF PATH
            PTHSTP = 1
            ENR0 = molecule.getPotentialEnergy()
            GRDRMS0 = GRDRMS
    #
    # Start linear search for optimal step along new path
    #
    #     SUBSEQUENT ITERATIONS, DLTSTP IS FROM PREVIOUS ITERATION
    #****************************
    #     INITIALIZE POINT A
    #****************************
            ENRA = ENR0
            GRDRMSA = GRDRMS0
            GRDPRJA = GRDPRJ0
            DSTA = 0.
    #   DSTB=ABM/GOLD IS GOOD ESTIMATE OF NEXT MIN, SET DSTB=ABM SO THAT
    #   IS BRACKETED
            DSTB = ABM
    
    #*********************************
    #     SECOND POINT OF PATH, B
    #*******************************
            if (FRSTSTP):
                if (DSTB > STPMAX): #Step size is too large, reset to STPMAX
                    DSTB = STPMAX
                FRSTSTP = False
    
            if (DSTB < STPMIN):  #Step size is too small, reset to STPMIN
                DSTB = STPMIN
    
    #**********************************
    #     REINTRANT PLACE FOR SUBSEQUENT BRACKETING STEPS
    #**********************************
    #     CALCULATE E AND GRDPRJ AT NEW POINT DSTB ON PATH
    
            bracketMin = False
            while not bracketMin:  # 100
    
                BMA = DSTB-DSTA
    
    #     TEST FOR SIZE OF STEP
                if (BMA < STPMIN):
    #
    #        STEP TOO SMALL, NOT BOTHER WITH POINT B
    #
    #        IF RCURV=.001 THEN dE=(dX)**2/RCURV=1.0E-9
    #              (IN ROUND OFF REGION)
    #              AND dYP=dX/RCURV=1.0E-3 WHICH SHOULD BE CONVERGED
    #              THUS STOP NOW TO AVOID POSSIBLE ROUND OFF PROBLEMS IN
    #              PREDICTING NEW MIN BASED ON A AND DSTB
    #              SINCE POINT B WILL NOT BE CALCULATED, STORE POINT A
    #              INFO IN B
                    ENRB = ENRA
                    DSTB = DSTA
                    ABM = DSTB
                    GRDPRJB = GRDPRJA
                    GRDRMS = GRDRMSA
                    GRDPRJM = GRDPRJB
                    if (DSTA != 0.):
                        ENRA = ENR0
                        DSTA = 0.  
                        GRDRMSA = GRDRMS0
                        GRDPRJA = GRDPRJ0
                    # Go to 198, then 200 in original code
                    # Here we don't follow original flow which is to do SD from the beginning again (80). 
                    # Instead, we exit simply because step is small (< STPMIN). If this is a concern, 
                    # we can either reduce STPMIN or restart minimization using the last geometry.
                    BETA = 0.
                    CNTCG = 0 
                    #     TAKE FINAL POINT CALCULATED IN CG PATH (STORED IN NEWX)
                    #           AND MOVE TO curX
                    GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                    CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    print "%s %i, %12.6f \n" % ("Exit because step BMA is too small \
                        ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS)
    
                    return
    
    #*****************************************************************
    #     NOW DO POINT B, WANT A AND B TO BRACKET THE MINIMUM
    #********************************************************************
                BTERM= DSTB / PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, BTERM) # NEWX(I) are updated
                ELAST = molecule.getPotentialEnergy()
                PTHSTP = PTHSTP + 1
    
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                #Cal. RMS force and coordinate 
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)  #yi
    
                Ecur = molecule.getPotentialEnergy()
                ECHNG = ELAST - Ecur 
    
                # Check for convergence
                if (GRDRMS <= TOLGRD):
                    STOPMIN = True
                    GRDPRJM = -GRDRMS * SQRTMOV3
                    ABM = DSTB
                    # MUST NOW MOVE NEWX INTO X
                    # GO TO 200
                    #
                    #     TAKE FINAL POINT CALCULATED IN CG PATH (STORED IN NEWX)
                    #           AND MOVE TO curX
                    #
                    #Cal. energy difference
                    EDIF = ENR0 - Ecur  #yi
                    DIFE = -EDIF
    
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    CGoutput.write("%s %i, %12.6f \n" % \
                       ("Minimization is converged (2) ==> PTHNUM, GRDRMS = ", PTHNUM, GRDRMS)) 
    
                    PTHNUM = PTHNUM + 1  #yi
    
                    writeCGoutput() #yi
    
                    return
    
                ENRB = Ecur
                GRDRMSB = GRDRMS
                # Find slope at B
                GRDPRJB = 0. #yi 
                GRDPRJB = self.gradientProjectCG(molecule, GRDPRJB, pathXYZ, PTHNRM)
                
                #
                # DETERMINE WHETHER HAVE BRACKETED MIN
                #
                if (GRDPRJB > 0.):
                    #
                    # HAVE BRACKETED MINIMUM, MIN IS PREDICTED AT ABM
                    # GO TO INTERPOLATION SECTION AT 130 TO GET FINAL VALUE
                    #
                    RCURV= BMA/(GRDPRJB-GRDPRJA)
                    ABM= DSTA - GRDPRJA * RCURV
                    #go to 130
                    bracketMin = True #Jump out of while loop
                    break
                else:
                    #
                    # DID NOT BRACKET MINIMUM, BOTH SLOPES NEGATIVE
                    #
                    NXTSTEP=GOLD*BMA
                    ABM=DSTB+NXTSTEP
                    # OLD B BECOMES NEW A
                    ENRA=ENRB
                    GRDPRJA=GRDPRJB
                    GRDRMSA=GRDRMSB
                    DSTA=DSTB
                    DSTB=ABM
                    if (PTHSTP <= PTHSTPMX):
                        #go to 100
                        bracketMin = False
                        continue
                    else:
                        # DID NOT CONVERGE, START NEW SD PATH
                        ABM=DSTB
                        # GO TO 197
                        ABMTEMP = ABM/PTHNRM
                        self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                        self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                        if Control.printLevel > 1:
                            forceStart = datetime.datetime.now()
                        forceEngine.downloadCoords(molecule)
                        forceEngine.calcEnergyForce()
                        forceEngine.uploadEnergyForce(molecule)
                        if Control.printLevel > 1:
                            forceEnd = datetime.datetime.now()
                            logFile = open(molName+'.log', 'a')
                            logFile.write('CG force timing:\n'); logFile.flush()
                            UTI.timer(molName, forceStart, forceEnd)

    
                        GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                        CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                        #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
                        #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                        GRDPRJM = 0. #yi
                        GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
                        BETA = 0.
                        CNTCG = -1
                        for i in range(1, numatoms+1):
                            curX[i] = NEWX[i]
                            curY[i] = NEWY[i]
                            curZ[i] = NEWZ[i]
                        CNTCG = CNTCG + 1
                        Ecur = molecule.getPotentialEnergy()
                        EDIF = ENR0 - Ecur 
                        DIFE = -EDIF
                        STEPAV = STEPAV + ABM
                        GRADAV = GRADAV + GRDRMS
                        if (STEEPDSSAV):
                            STEEPDS = True
                            CNTCG = 0     
                        else:
                            STEEPDS = False
                        #Exit from here. If it is not good, start it over again by using final geometry.
                        GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                        print "%s %i, %i, %12.6f \n" % \
                          ("Exit because PTHSTP is too large, please restart from SD ==> PTHNUM, PTHSTP, GRDRMS = ", PTHNUM, PTHSTP, GRDRMS) 
    
                        return
    
    # End of 2nd while loop (bracketMin)
    #
    #**************************************
    #     HAVE BRACKETED MINIMUM,
    #           INTERPOLATE TO FIND A BETTER MINIMUM ALONG CURRENT PATH
    #*************************************
            if (PTHSTP > PTHSTPMX): #GO TO 197
                ABMTEMP = ABM/PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
                #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                GRDPRJM = 0.  #yi
                GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
                BETA = 0.
                CNTCG = -1
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                Ecur = molecule.getPotentialEnergy()
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
    
                continue  #go to next CG step 
    
            ABMTEMP=ABM/PTHNRM
            self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
            ELAST = molecule.getPotentialEnergy()
            PTHSTP = PTHSTP + 1
    
            self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
            if Control.printLevel > 1:
                forceStart = datetime.datetime.now()
            forceEngine.downloadCoords(molecule)
            forceEngine.calcEnergyForce()
            forceEngine.uploadEnergyForce(molecule)
            if Control.printLevel > 1:
                forceEnd = datetime.datetime.now()
                logFile = open(molName+'.log', 'a')
                logFile.write('CG force timing:\n'); logFile.flush()
                UTI.timer(molName, forceStart, forceEnd)
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
            CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
            Ecur = molecule.getPotentialEnergy()
            ECHNG = ELAST - Ecur 
            ENRM = Ecur 
    
            if (GRDRMS <= TOLGRD): 
                STOPMIN = True 
                GRDPRJM = -GRDRMS*SQRTMOV3
                # GO TO 200
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                continue
    #
    #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
            GRDPRJM = 0.
            GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
            RCURV=ABM/(GRDPRJM-GRDPRJ0)
    
            if (PTHSTP > PTHSTPMX): #GO TO 198
                BETA = 0.
                CNTCG = -1
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                #EDIF = ENRO - Ecur 
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False

                continue #go to next CG step
    
    #     CHECK TO SEE IF ENERGY HAS INCREASED
    #        EABMIN = min(ENRA,ENRB)+MINDLTE
    #        if ( ENRM > ENRA+MINDLTE and ENRM > ENRB+MINDLTE and (not LASYMSTR)):
            if (ENRM > ENRA and ENRM > ENRB):  #yi
                print "Problem: in line search the middle point lies above \
    the two bracketing points, will do SD next." 
                #go to 198
                BETA = 0.
                CNTCG = -1
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                for i in range(1, numatoms+1):
                    curX[i] = NEWX[i]
                    curY[i] = NEWY[i]
                    curZ[i] = NEWZ[i]
                CNTCG = CNTCG + 1
                EDIF =ENR0- Ecur
                DIFE = -EDIF
                STEPAV = STEPAV + ABM
                GRADAV = GRADAV + GRDRMS
                if (STEEPDSSAV):
                    STEEPDS = True
                    CNTCG = 0     
                else:
                    STEEPDS = False
    #yi            if (not STOPMIN and (PTHNUM < ISTOP) and (PTHNUM > 1) and (PTHNUM % NCYCLE == 1)):
                if (not STOPMIN and (PTHNUM < ISTOP) and (PTHNUM > 1)):
                    PTHNUM = PTHNUM + 1
                    STEEPDS = True
                    CNTCG = 0
                    # DO ENERGY OVER BECAUSE MOLECULES MAY HAVE MOVED 
                    if Control.printLevel > 1:
                        forceStart = datetime.datetime.now()
                    forceEngine.downloadCoords(molecule)
                    forceEngine.calcEnergyForce()
                    forceEngine.uploadEnergyForce(molecule)
                    if Control.printLevel > 1:
                        forceEnd = datetime.datetime.now()
                        logFile = open(molName+'.log', 'a')
                        logFile.write('CG force timing:\n'); logFile.flush()
                        UTI.timer(molName, forceStart, forceEnd)

                    continue #Jump to the top of the 1st while loop to do SD again 
            else:
    
    #       ENERGY AT ENRM IS LOWER THAN BOTH ENDPOINTS
    #*******************************************************
    #       DO FINAL CUBIC FIT USING SLOPES AT 3 POINTS
    #         (DSTA,ABM,DSTB)
    #         RETURN OPT DISTANCE AS DSTNEW AND NEW RCURV
    #******************************************************
                DSTNEW = 0.  #yi
                RCURV = 0.   #yi
                DSTNEW,RCURV = self.CUBIC03(DSTA,GRDPRJA,ABM,GRDPRJM,DSTB,GRDPRJB,DSTNEW,RCURV)
    
                OLDABM=ABM
                OLDGRDPRJM=GRDPRJM
                ABM=DSTNEW
    #       DO FINAL CALCULATION AT THIS ENERGY
                SECONDTRY=0
                ABMTEMP=ABM/PTHNRM
                self.moveAtomCG(molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, ABMTEMP) # NEWX(I) are updated
                PTHSTP = PTHSTP + 1
    
                self.setAtomXYZ(molecule, NEWX, NEWY, NEWZ) #set NEWX to data model
                if Control.printLevel > 1:
                    forceStart = datetime.datetime.now()
                forceEngine.downloadCoords(molecule)
                forceEngine.calcEnergyForce()
                forceEngine.uploadEnergyForce(molecule)
                if Control.printLevel > 1:
                    forceEnd = datetime.datetime.now()
                    logFile = open(molName+'.log', 'a')
                    logFile.write('CG force timing:\n'); logFile.flush()
                    UTI.timer(molName, forceStart, forceEnd)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
                ENRM = molecule.getPotentialEnergy()
                Ecur = ENRM         #yi
                EDIF = ENR0 - Ecur  #yi
                DIFE = -EDIF        #yi
    
    #       CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
                GRDPRJM = 0.
                GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
     
                if (GRDRMS <= TOLGRD): 
                    STOPMIN = True  
                    #GO TO 200
                    for i in range(1, numatoms+1):
                        curX[i] = NEWX[i]
                        curY[i] = NEWY[i]
                        curZ[i] = NEWZ[i]
                    CNTCG = CNTCG + 1
                    EDIF = ENRO - molecule.getPotentialEnergy()
                    DIFE = -EDIF
                    CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
                    STEPAV = STEPAV + ABM
                    GRADAV = GRADAV + GRDRMS
                    if (STEEPDSSAV):
                        STEEPDS = True
                        CNTCG = 0     
                    else:
                        STEEPDS = False

                    continue
    
    #
    #EXTRA ITERATION SECTION
    #       CHECK SLOPE OF FINAL POINT, IF NOT GOOD ENOUGH DO ONE MORE
    #         ITERATION
    #            ERR=GRDPRJM-TOLGRD
    #       IF GRDPRJM NOT NEARLY ZERO, THEN TRY AGAIN
    #       FIRST TIME SECONDTRY=0, THEN 1, THEN 2. STOP IF 2
    #            if (SECONDTRY >= 2): GO TO 197
    #       GENERALLY TOLGRD=.1 (.2 TO .01), I FIND THAT GRDPRJM OFTEN
    #           LARGER
    #            if (GRDPRJM<TOLGRD): GO TO 199
    #       PICK FINAL POINT BASED ON OLDABM AND ABM WITH GRADIENTS OF
    #       OLDGRDPRJM AND GRDPRJM
    #            if (GRDPRJM == OLDGRDPRJM): GO TO 199
    #                RCURV=(ABM-OLDABM)/(GRDPRJM-OLDGRDPRJM)
    #            if (RCURV <= 0.0): GO TO 199
    #                NXTSTEP=-GRDPRJM*RCURV
    #            if (abs(NXTSTEP)>BMA): GO TO 199
    #                ABM=ABM+NXTSTEP
    #                SECONDTRY=SECONDTRY+1
    #
    
    #**************************************
    #     END OF CONJUGATE GRADIENT SEQUENCE
    #           WILL START NEW PATH AT POINT WITH DST=ABM ON OLD PATH
    #*******************************************
    #     SPECIAL TERMINATION OF PATH OPTIMIZATION, DO STEEPDS NEXT
    #           ITER
    #
    #     NEED E,DX... AT POINT ABM
    
            GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
    
            #Cal. RMS coordinate
            CORDRMS = UTI.calcRMScoordinate(numatoms, NEWX, NEWY, NEWZ, curX, curY, curZ)
    
    #     NEED GRDPRJM HERE ONLY FOR WRITE OUT
    #     CALC SLOPE (ALONG P) AT PREDICTED MINIMUM
            GRDPRJM = 0.
            GRDPRJM = self.gradientProjectCG(molecule, GRDPRJM, pathXYZ, PTHNRM)
    #
    #     ALREADY HAVE E,DX AT POINT ABM
    #        BETA=0.0
    #        CNTCG=-1
            #GO TO 200
    
    #***************************************
    #   NORMAL TERMINATION OF PATH OPTIMIZATION
    #***************************************
            for i in range(1, numatoms+1):
                curX[i] = NEWX[i]
                curY[i] = NEWY[i]
                curZ[i] = NEWZ[i]
    #***************************************
    #     FINISHED CG PATH
    #*****************************************
            CNTCG=CNTCG+1
            EDIF =  ENR0 - molecule.getPotentialEnergy()
            DIFE = -EDIF  #for print
    
            STEPAV = STEPAV + ABM
            GRADAV = GRADAV + GRDRMS
    #yi        if(not lquenc): 
    #yi            EPERC[PTHNUM] = molecule.getPotentialEnergy()
    #
    #     RESET STEEPDS IN CASE HAS BEEN CHANGED
            if (STEEPDSSAV):
                STEEPDS = True 
                CNTCG = 0
            else:
                STEEPDS = False  
    
    #*******************************************
    #     HAVE NOW FINISHED CURRENT PATH
    #     DECIDE WHETHER TO DO NEW ONE
    #******************************************
    #     CHECK FOR ABORT IN INTERACTIVE MODE ON KEY 12
    #
    #        if( not BTCH ):
    #            CALL CABORT(ABORT)
    #            ABORT = False
    #            if( ABORT ):
    #                ISTOP = PTHNUM
    #                print ' Minimization is aborted (CONJGR)\n'
                    #GO TO 21
    #
    #     CHECK CONVERGENCE AND NUMBER OF ITERATIONS
    #
            if (STOPMIN): 
                CGoutput.write("<<< Minimization is converged  >>> Final RMS force: %20.10e\n" % (GRDRMS)) 
            else:
    #    if ( PTHNUM < ISTOP): 
    #         MORE ITERATIONS TO DO
                PTHNUM=PTHNUM+1
    #         FOR LONG RUNS MAY NEED TO UPDATE NBHBLST (AND CHECK FOR
    #           MOLECULES WITHIN UNIT CELL
    #yi          IF (.NOT.CELOPT) THEN
    #           FOR CELOPT, CELLOPT CONTROLS NBHBLST CALL
    #           NOT DO IF FIRST ITERATION OR NEARLY THE LAST
    #           KEY ON .EQ.1 SO THAT DO NCYCLE BEFORE NEW ONE
    #yi            if (PTHNUM>1 and PTHNUM % NCYCLE == 1): 
    #            if (PTHNUM > 1): #yi 
    #                STEEPDS = True 
    #                CNTCG=0
    #             REINITIALIZE CM
    #             DO ENERGY OVER BECAUSE MOLECULES MAY HAVE MOVED AND
    #               NB LIMITS MAY HAVE CHANGED
    #            forceEngine.calcEnergyForce(molecule)
    
                GRDRMS = UTI.calcRMSforce(molecule) # get GRDRMS
                Ecur = molecule.getPotentialEnergy()
    #              CALL TOTFRC(GRDRMS,CELLRMS)
    
    #          GO TO 80
    #End of while loop at 80
    #    else:
    #         FINISHED ITERATIONS
    
        writeCGoutput()
    
        CGoutput.write("<<< Minimization not converged >>> Final RMS force: %20.10e\n" % (GRDRMS)) 
    
    #**********************************************
    #     FINISHED CG, STORE CONVERGENCE INFO
    #*********************************************
    #     THESE QUANTITIES ARE USED FOR CONTROLLING BATCH OPTIMIZATIONS
    #
        NSTP = PTHNUM - ISTART + 1
        if ( NSTP >  1 ):
            STEPAV = STEPAV/NSTP
            GRADAV = GRADAV/NSTP
        CONVRG = 0
    #yi    if( EDIF <= TOLENR ): CONVRG = 1 + CONVRG
        if( ABM <= 1.0E-4 ):  CONVRG = 2 + CONVRG
        if(GRDRMS <= TOLGRD): CONVRG = 4 + CONVRG
    #
    #     CHANGE SIGN OF EDIF FOR PRINT OUT
    #
        DIFE=-EDIF
    
    #*********************
    #     PRINT RESULTS FOR INFLVL=0 OPTION (IF NOT CELOPT)
    #*********************
    #    if (not CELOPT):
    #    finaliter=1
    #    newcnte=cnte-oldcnte
    #    call WRTMINITR(inflvl,pthnum,grdrms,cellrms,abm,dstcel, \
    #         newcnte,finaliter)
    #    oldcnte=cnte
    #*************************
    #     FINAL RESTORING
    #**************************
    #12190 CONTINUE
    
        ISTOP = PTHNUM
    
        return
    
    #
    # The following functions are called in above minimizerConjugateGradient function.
    #
    
    def CUBIC03(self,DSTA,GRDA,DSTM,GRDM,DSTB,GRDB,DSTNEW,RCURV):
    # 22/SEP/87 WAG CUBIC FIT USING GRADIENT AT 3 POINTS
    #     RETURNS NEW POINT DSTNEW AND RCURV=1/2ND DERIV AT DSTNEW
    #     THIS ONLY CALLED WHEN ENERGY IS BRACKETED
    #
    #     DSTNEW and RCURV are output at new point. Others are input of three points.
    #
        #from math import sqrt
    
        DLTM=DSTM-DSTA
        if (abs(DLTM) < 1.e-6): #GO TO 101  !POINTS 1 AND 2 THE SAME
            # NO SOLUTION, PROGRAM SHOULD NOT GET HERE
            print "SERIOUS PROBLEM IN CUBIC03, WILL USE QUADRATIC."
            # USE POINTS 2 AND 3
            RCURV=(DSTB-DSTM)/(GRDB-GRDM)
            if (RCURV<=0.0): 
                print "NEGATIVE CURVATURE IN CUBIC03, RCURV = %12.6f \n" % (RCURV)
                RCURV=-RCURV
                # SHOULD USE RCURVDEF/100
                if (RCURV<0.001): RCURV=0.001
                DSTNEW=DSTA+3.0*(DSTB-DSTA)
            else:
                DSTNEW=DSTA-GRDA*RCURV
            return (DSTNEW, RCURV)
    
        if (abs(DSTB-DSTM)<1.0e-6):     
    #       POINTS 2 AND 3 THE SAME
            RCURV=(DSTB-DSTA)/(GRDB-GRDA)
            if (RCURV<=0.0): 
                RCURV=-RCURV
    #         SHOULD USE RCURVDEF/100
                if (RCURV<0.001): RCURV=0.001
                DSTNEW=DSTA+3.0*(DSTB-DSTA)
            else:
                DSTNEW=DSTA-GRDA*RCURV
            return (DSTNEW, RCURV)    
    
        DLTB=DSTB-DSTA
        EPDLTM=GRDM-GRDA
        EPDLTB=GRDB-GRDA
        EPM=EPDLTM/DLTM
        EPB=EPDLTB/DLTB
        EPPPA=2.0*(EPB-EPM)/(DLTB-DLTM)
        EPPA=(EPM*DLTB-EPB*DLTM)/(DLTB-DLTM)
        RADICAL=EPPA*EPPA-2.0*EPPPA*GRDA
        if (RADICAL>0.0):     
    #       REAL MINIMUM
            RADICAL=sqrt(RADICAL)
            if (EPPPA==0.0): 
    #         THIS ACTUALLY HAPPENED FOR A NON TRIVIAL CASE
                DSTNEW=DSTM
            else:
                DSTNEW=DSTA+(RADICAL-EPPA)/EPPPA
            RCURV=1./RADICAL
            return (DSTNEW, RCURV)
    
        return (DSTNEW, RCURV)
    
    def gradientProjectCG(self, molecule, GRDPRJ, pathXYZ, PTHNRM):
    # Calc slope along p
    # Called by CG
        IND = 0
        NUMBK = 3
        GRD= {} 
    
        numatoms = molecule.numAtoms()
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
            #yi Note that CMDF force has opposite direction from MEE gradient, so added negative sign here. 
    
            GRD[1] = -atom.getForceX()
            GRD[2] = -atom.getForceY()
            GRD[3] = -atom.getForceZ()
            for k in range(1, NUMBK+1):
                GRDPRJ += pathXYZ[k+IND] * GRD[k]
            IND += NUMBK
        GRDPRJ = GRDPRJ / PTHNRM
    
        return (GRDPRJ) 
    
    def moveAtomCG(self, molecule, NEWX, NEWY, NEWZ, curX, curY, curZ, pathXYZ, tm):
    # This function moves atoms to new positions along p direction during minimization 
    # NEWX(I) = X(I) + TM * PXYZ(I)
        NUMBK = 3
        IND = 0
        numatoms = molecule.numAtoms()
    
        for i in range(1, numatoms+1):
            NEWX[i] = curX[i] + tm * pathXYZ[1+IND]
            NEWY[i] = curY[i] + tm * pathXYZ[2+IND]
            NEWZ[i] = curZ[i] + tm * pathXYZ[3+IND]
            IND += NUMBK
    
        return
    
    def setAtomXYZ(self, molecule, newx, newy, newz):
        numatoms = molecule.numAtoms()
    
        for i in range(1, numatoms+1): 
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            atom.setPosition(newx[i], newy[i], newz[i])
    
        return
    
    def newPath(self, molecule, pathXYZ, BETA, PTHNRM, GRDPRJ):
        #from math import sqrt
    
        numatoms = molecule.numAtoms()
    
    # Initialize pathXYZ (NEEDED IN CASE PXYZ HAVE BECOME INDEFINITE) 
    
    #    if (BETA == 0.):
    #        IND = 3 * numatoms
    #        pathXYZ = [0.]*(IND+1)
    #
    #  Construct new path pXYZ using beta and old path
    #  P[i+1] = beta[i]*P[i] - g[i+1]
    #
        PTHNRM = 0.
        GRDPRJ = 0.
        IND = 0
    
        GRD={}
    
        NUMBK = 3
        for i in range(1, numatoms+1):
            atom = molecule.getAtomWithNumber(i)
    
    #yi Note that CMDF force has opposite direction from MEE gradient. So a negative sign was added. 
    
            GRD[1] = -atom.getForceX()
            GRD[2] = -atom.getForceY()
            GRD[3] = -atom.getForceZ()
            for k in range(1, NUMBK+1):
                pathXYZ[k+IND] = BETA * pathXYZ[k+IND] - GRD[k]
                PTHNRM += pathXYZ[k+IND]**2 
                GRDPRJ += pathXYZ[k+IND]*GRD[k]
            IND += NUMBK
        PTHNRM = sqrt(PTHNRM)
        GRDPRJ = GRDPRJ/PTHNRM
    
        return (PTHNRM, GRDPRJ)

"""
# Simulated annealing minimization via MD.
class CoolSchedule:

    def __init__(self, numSteps):
        self.numSteps = numSteps

        return            

    def initialization(self):

        return

    def run(self, iStep):

        return

class Linear(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)

        return scaleFactor

class Exponent(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        #from math import exp

        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = 1. - exp(-5. * scaleFactor)

        return scaleFactor

class Sigmoid(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = self.sigmoid(5., scaleFactor) 

        return scaleFactor

    def sigmoid(self, beta, x):
    #
    # Compute a normalized sigmoidal function on the interval [0, 1];
    # The curves connect (0, 0) and (1, 1) and have a cooperativity 
    # controlled by beta: they approach a straight line as beta approaches
    # zero, and become more nonlinear as beta increase.
    #
        #from math import exp

        if beta == 0.:
            sigm = x
        else:
            expmax = 1. / (exp(-beta) + 1.)
            expmin = 1. / (exp(beta) + 1.)
            expterm = 1. / (exp(beta * (2. * x - 1.)) + 1.)
            sigm = (expmax - expterm) / (expmax - expmin)

        return sigm

class SimulatedAnnealing(Minimizer):
# Simulated annealing minimization via MD.
# Avaliable cooling schedules include Linear, Exponent, and Sigmoid.

    def __init__(self, coolSchedule=Linear, integrator=LeapFrog, thermostat=BerendsenThermostat,  \
                barostat=BerendsenBarostat, gaussian=Gaussian3, initTemp=1000., finalTemp=0.,  \
                numSteps=1000, equSteps=500, timeStep=0.001, threshold=0.01, freqOutputMD=10, freqOutputTrj=10): 
        Minimizer.__init__(self, numSteps, threshold, freqOutputMD)
        self.freqOutputTrj = freqOutputTrj
        self.coolSchedule = coolSchedule
        self.integrator = integrator
        # Note that only BerendsenThermostat is used in SA.
        # Thermostat will be explictly created again in run. 
        self.thermostat = thermostat
        self.barostat = barostat
        self.gaussian = gaussian
        self.timeStep = timeStep
        self.annSteps = numSteps
        self.equSteps = equSteps 
        self.initTemp = initTemp
        self.finalTemp = finalTemp
        self.relaxSteps = 1  
        self.scaleMass = 0. 

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        def outputSA(num, file):
            file.write("%6i  %5f  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                        (num, scaleFactor, potEnergy, diffEnergy, RMSforce, RMScoord))
            return

        #from utility import Utility
        UTI = Utility()

        # Setup parameters.
        initTemp = self.initTemp  # Initial temperature  
        finalTemp = self.finalTemp  # Final temperature
        coolSchedule = self.coolSchedule  # Cooling schedule 
        dt = self.timeStep   # Time step in MD
        weakTau = 100. * dt  # Coupling time in Berendsen thermostat
        strongTau = 10. * dt
        equSteps = self.equSteps  # Equilibration MD Steps     
        annSteps = self.annSteps  # Annealing MD steps 
        freqOutputMD = self.freqOutput  # Output interval
        freqOutputTrj = self.freqOutputTrj  # Output interval
        relaxSteps = self.relaxSteps  # Relax steps during annealing.
        threshold = self.threshold  # RMS force convergence criterion
        scaleMass = self.scaleMass  # scale mass by a factor of 10^scaleMass
        scaleMass = 10. ** scaleMass 

        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        mass = [0.] * numAtoms
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            mass = atom.getAtomicMass()
            mass *= scaleMass
            atom.setAtomicMass(mass)

        molName = molecule.getName() 
        SAoutput = open(molName+'.min', 'a')
        MDoutput = open(molName+'.dyn', 'a')
        xyzFile = open(molName+'.trj', 'a')
        rstName = molName+'.rst'

        SAoutput.write("%25s<<< CMDF minimization with Simulated Annealing method >>>\n" % (' '))
        SAoutput.write("N_Iter.   Scale             Pot_E                Diff_E               RMS_Grad.            RMS_Coord.\n")  

        #MDoutput.write("%16s <<< CMDF Simulated Annealing via MD integration >>>\n" % (' '))
        MDoutput.write("%12s<< Equilibrium phase at initial temperature %16.7f K >>\n" % (' ', initTemp))
        MDoutput.flush()

        # Equilibration phase at initial temperature. 
        # One can choose different starting configurations via setting different equSteps.
        equilibriumThermostat = BerendsenThermostat(initTemp, dt, weakTau)
        equilibriumMD = MDEngine(self.integrator, equilibriumThermostat, self.barostat,  \
                            self.gaussian, equSteps, freqOutputMD, freqOutputTrj, initTemp)
        equilibriumMD.run(system, forceEngine)

        # Annealing phase according to the cooling schedule.
        MDoutput.write("%12s<< Annealing phase toward final temperature %16.7f K >>\n" % (' ', finalTemp))
        MDoutput.flush()
        # Note that the following instance name has no meaning. I just borrow its output method.
        equilibriumMD.outputMD(system, -1, MDoutput)
        equilibriumMD.outputMD(system, 0, MDoutput)

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            atom.setOldPosition(0., 0., 0.)
        molecule.setOldPotentialEnergy(0.)         
        convergence = False
        # Create cooling schedule.
        coolSchedule = self.coolSchedule(annSteps)
        self.integrator.initialize(system)  # Initialize integrator.
        for iStep in range(1, annSteps+1):

            self.integrator.run(system, forceEngine)  # MD integration.

            if (iStep-1) % relaxSteps == 0: 
                # Compute scaling factor according to cooling schedule.
                scaleFactor = coolSchedule.run(iStep)
                scaleFactor1 = 1. - scaleFactor
                targetTemp = scaleFactor1 * initTemp + scaleFactor * finalTemp
                tauTemp = scaleFactor1 * weakTau + scaleFactor * strongTau
                # Create new thermostat.
                annealThermostat = BerendsenThermostat(targetTemp, dt, tauTemp)
            annealThermostat.run(molecule)  # Thermostat

            if self.barostat:  # Barostat
                self.barostat.run(system, self.integrator)

            RMScoord = UTI.calcRMScoord(molecule)
            RMSforce = UTI.calcRMSforce(molecule)
            potEnergy = molecule.getPotentialEnergy()
            oldPotEnergy = molecule.getOldPotentialEnergy()
            diffEnergy = potEnergy - oldPotEnergy

            if iStep % freqOutputMD == 0: 
                outputSA(iStep, SAoutput)
                equilibriumMD.outputMD(system, iStep, MDoutput)

            if iStep % freqOutputTrj == 0: 
                UTI.outputTrj(molecule, xyzFile, iStep)
                equilibriumMD.writeMDrestart(system, rstName)

            if (RMSforce <= threshold):
                convergence = True
                if iStep % freqOutputMD != 0: 
                    outputSA(iStep, SAoutput)
                SAoutput.write("%52s %20.10e \n" % ("<<< Minimization is converged >>> Final RMS force: ", \
                                 RMSforce))
                break
            else:
                for i in range(1, numAtoms1):
                    atom = molecule.getAtomWithNumber(i)
                    atom.setOldPosition(atom.getX(), atom.getY(), atom.getZ())
                molecule.setOldPotentialEnergy(potEnergy)         
    
        if not convergence:
            SAoutput.write("%50s %20.10e \n" % ("<<< Minimization not converged >>> Final RMS force: ", \
                                RMSforce))

        SAoutput.close()
        MDoutput.close()
        xyzFile.close()
        
        return 

"""
