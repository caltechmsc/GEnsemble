#!/usr/bin/env python

from numpy import zeros, Float, pi, sin, cos, sqrt, exp
import cmdf.eam.IMD_EAM_noshift as IMD_EAM
from cmdf.eam.imdTools import checkOpen, Rec, Exp, Sqrt
                                                                                                                              
                                                                                                                                   
##############################################################
# generic energy engine interface functions to be
# implemented by all energy engines so they can be called
# from various dynamics and minimization routines.
# __init__(natoms, cellDim, deflen=40., paths=':/ul/peng/cmdf/FFmaker/no_spline/')              initializes the energy engine
# setupEnergyExpression(coords, masses, elements, FFflavor, cutoff=[], spacing=.004, ffFile='PARAMS.FF')
# energy, force = calcEnergy(coords)                                                            calculates energy and forces
# energy = getEngery()                                                                          return potential energy
# force = getForces()                                                                           return forces
##############################################################


class IMDForceEngine_noshift:
    def __init__(self, natoms, cellDim, deflen=40., paths=':/ul/peng/cmdf/FFmaker/no_spline/'):
        self.natoms = natoms
        self.edges = cellDim[:3]
        self.angles = cellDim[-3:]/180*pi
        self.deflen = deflen
        self.defpaths = paths
        self.elementlist = []
#                 FFflavor: mix, cutoff, section, intFuncs,           intParams,      rhoFuncs, rhoParam
#                    RGL  :                                 r, p, D    r, q, gsi 
        self.FF = { 'RGL' : [0, [4.5,.0], '39', [Exp]*2, [[-5,-2,-4],[-5,-1,-3]], [Sqrt], [[  ]]],\
                    'QSC2': [0, [7.5,.6], '47', [Rec]*2, [[-5,-1,-4],[-5,-2,-3]], [Sqrt], [[  ]]],\
                    'QSC' : [1, [7.5,.6], '17', [Rec]*2, [[-5,-1,-4],[-5,-2]   ], [Sqrt], [[-3]]]  }
#                   QSC(2):                                 r, n, D    r, m,(c)              c
        self.files = ['_Phi_r2.dat','_Rho_r2.dat','_F_Rho.dat']
        self.exprs = ['Core-core Pair Potential','Electron Density','Embedding Energy Function']
        self.__energy = 0.0
        self.__forces = zeros(3*self.natoms, Float)
        return

    def addDefaultPaths(self, paths, delimiter=':'):
        pathlist = paths.split(delimiter)
        defpathlist = self.defpaths.split(':')
        for path in pathlist:
            if path not in defpathlist:
                defpathlist.append(path)
        self.defpaths = ':'.join(defpathlist)
        return


    def readForceField(self, FFflavor, ffFile):
# check and open Force Field file to read
        self.ffp = checkOpen(self.defpaths, ffFile)
        print ' to read', FFflavor, 'Force Field Parameters...'
# read Force Field parameters
        paramlist = []
        found = 0
        section = self.FF[FFflavor][2]
        for eachLine in self.ffp.readlines():
            if not found:
                if eachLine[:7]=='SECTION' and section in eachLine:
                    found = 1
            elif eachLine[:7]=='ENDSECT':
                if paramlist ==[]:
                    raise LookupError, 'No parameters found in Force Field SECTION!'
                else:
                    break
            elif eachLine[:7]=='SECTION':
                raise AssertionError, "Force Field SECTION doesn't end normally!"
            else:
                words = eachLine.split()
                keyword = words[-1]
                assert keyword.isalpha(), 'Wrong keyword format!'
                if keyword.isupper():
                    keyA = keyword[:1]
                    keyB = keyword[-1:]
                elif keyword[:2].isupper():
                    keyA = keyword[:1]
                    keyB = keyword[-2:]
                else:
                    keyA = keyword[:2]
                    if keyword[-1].isupper():
                        keyB = keyword[-1]
                    else:
                        keyB = keyword[-2:]
                if keyA in self.elementlist and keyB in self.elementlist:
                    paramlist += [words[:-1]+[keyA,keyB]]
        else:
            raise LookupError, 'No Force Field SECTION in Force Field file!'
        self.ffp.close()
        mix = self.FF[FFflavor][0]
        numElem = len(self.elementlist)
        numInter = len(paramlist)
        assert not mix and numInter==numElem*(numElem+1)/2 or mix and numInter==numElem,\
              "Force Field parameters don't have the right interactions for elements in system"

# generate parameters array from parameter list
        numParam = len(paramlist[0])-2
        paramArray = zeros([numParam, numElem, numElem], Float)
        for i in range(numInter):
            for p in range(numParam):
                m = self.elementlist.index(paramlist[i][-2])
                n = self.elementlist.index(paramlist[i][-1])
                paramArray[p,m,n]=paramArray[p,n,m]= float(paramlist[i][p])
# apply combination rule for non-explicit
        if mix==1:
            for n in range(numElem):
                for m in range(n):
                    for p in (-4,):
                        paramArray[p,m,n]=paramArray[p,n,m] = sqrt(paramArray[p,m,m]*paramArray[p,n,n])
                    for p in (-1,-2,-5):
                        paramArray[p,m,n]=paramArray[p,n,m] = (paramArray[p,m,m]+paramArray[p,n,n])/2

# parameters unification
        if 'QSC' in FFflavor:
            # D(10-2 eV)->D(eV)
            paramArray[-4] *= .01
            # c->c^2*D^2
            paramArray[-3] *= paramArray[-3] * paramArray[-4]**2
        if 'RGL' in FFflavor:
            # gsi->gsi^2
            paramArray[-3] *= paramArray[-3]
            # q->2q   to use the same simple exponetial decay
            paramArray[-1] *= 2

        return paramArray

    def writeTables1(self, paramArray, FFflavor, cutoff, spacing, shift=0):
# Make Force Field Tables using format 1 from the parameter Array
# initialization
        fps = []
        numFunc = len(self.files)
        section = self.FF[FFflavor][2]
        for i in range(numFunc):
            f = open(self.files[i], 'w')
            f.write('## %s for %s Force Field of System %s\n' % (self.exprs[i], FFflavor, '-'.join(self.elementlist)))
            f.write('## Generated by CMDF IMDForceEngine from parameters in SECTION %s of %s\n' % (section, self.ffp.name))
            f.write('## Using Format 1\n')
            fps.append(f)
                                                                                                                              
        intFunc = self.FF[FFflavor][3]
        numIntFunc = len(intFunc)
        numElem = len(self.elementlist)
        maxRho = 0
        for i in range(numIntFunc):
            fps[i].write('#F 1 %d\n#E\n' % (numElem*numElem))
            rr0 = cutoff[1]**2
            i2max = int((cutoff[0]**2-rr0)/spacing)+1
            rr1 = rr0+i2max*spacing
            intParam = [rr1]
            for p in range(len(self.FF[FFflavor][4][i])):
                intParam.append(paramArray[self.FF[FFflavor][4][i][p]])
            if shift:
                delta = intFunc[i](intParam)
            else:
                delta = 0
            for i2 in xrange(i2max+1):
                rr = rr0+i2*spacing
                intParam[0] = sqrt(rr)
                func = intFunc[i](intParam) - delta
                fps[i].write('%.16f' % rr)
                for m in range(numElem):
                   for n in range(numElem):
                        fps[i].write('\t%.16f' % func[m,n])
                maxFunc = func.max()
                if (i==1) and (maxRho<maxFunc):
                    maxRho = maxFunc
                fps[i].write('\n')
            fps[i].close()
                                                                                                                              
        rhoFunc = self.FF[FFflavor][5]
        numRhoFunc = len(rhoFunc)
        assert numIntFunc+numRhoFunc==numFunc, 'EAM-type Function numbers unconsistent!'
        for i in range(numRhoFunc):
            j = i + numIntFunc
            fps[j].write('#F 1 %d\n#E\n' % numElem)
            d0 = 0
            spacing *=10
            i2max = int((maxRho-d0)/spacing)+1
            rhoParam = [0]
            for p in range(len(self.FF[FFflavor][6][i])):
                rhoParam.append(paramArray[self.FF[FFflavor][6][i][p]].diagonal())
            for i2 in xrange(i2max+1):
                d = d0+i2*spacing
                rhoParam[0] = d
                func = rhoFunc[i](rhoParam)
                fps[j].write('%.16f' % d)
                for n in range(numElem):
                    fps[j].write('\t%.16f' % func[n])
                fps[j].write('\n')
            fps[j].close()
                                                                                                                              
        return fps


    def writeTables2(self, paramArray, FFflavor, cutoff, spacing):
# Make Force Field Tables using format 2 from the parameter Array
# initialization
        fps = []
        numFunc = len(self.files)
        section = self.FF[FFflavor][2]
        for i in range(numFunc):
            f = open(self.files[i], 'w')
            f.write('## %s for %s Force Field of System %s\n' % (self.exprs[i], FFflavor, '-'.join(self.elementlist)))
            f.write('## Generated by CMDF IMDForceEngine from parameters in SECTION %s of %s\n' % (section, self.ffp.name))
            f.write('## Using Format 2\n')
            fps.append(f)

        intFunc = self.FF[FFflavor][3]
        numIntFunc = len(intFunc)
        numElem = len(self.elementlist)
        maxRho = 0
        for i in range(numIntFunc):
            fps[i].write('#F 2 %d\n#E\n' % (numElem*numElem))
            rr0 = cutoff[1]**2
            i2max = int((cutoff[0]**2-rr0)/spacing)+1
            rr1 = rr0+i2max*spacing
            for n in range(numElem*numElem):
                fps[i].write(('%.16f '*3+'\n') % (rr0, rr1, spacing))
            for m in range(numElem):
                for n in range(numElem):
                    intParam = [0]
                    for p in range(len(self.FF[FFflavor][4][i])):
                        intParam.append(paramArray[self.FF[FFflavor][4][i][p]][m][n])
                    for i2 in xrange(i2max+1):
                        intParam[0] = sqrt(rr0+i2*spacing)
                        func = intFunc[i](intParam)
                        fps[i].write('%.16f\n' % func)
                        if (i==1) and (maxRho<func):
                            maxRho = func
            fps[i].close()

        rhoFunc = self.FF[FFflavor][5]
        numRhoFunc = len(rhoFunc)
        assert numIntFunc+numRhoFunc==numFunc, 'EAM-type Function numbers unconsistent!'
        for i in range(numRhoFunc):
            j = i + numIntFunc
            fps[j].write('#F 2 %d\n#E\n' % numElem)
            d0 = 0
            i2max = int((maxRho-d0)/spacing)+1
            d1 = d0+i2max*spacing
            for n in range(numElem):
                fps[j].write(('%.16f '*3+'\n') % (d0, d1, spacing))
            for n in range(numElem):
                rhoParam = [0]
                for p in range(len(self.FF[FFflavor][6][i])):
                    rhoParam.append(paramArray[self.FF[FFflavor][6][i][p]][n][n])
                for i2 in xrange(i2max+1):
                    rhoParam[0] = d0+i2*spacing
                    func = rhoFunc[i](rhoParam)
                    fps[j].write('%.16f\n' % func)
            fps[j].close()
                                                                                                                              
        return fps


    def checkElements(self, elements):
                                                                                                                             
# create sorted element list
        for i in range(self.natoms):
            element = elements[i]
            if element not in self.elementlist:
                self.elementlist.append(element)
        self.elementlist.sort()
        return


    def setupEnergyExpression(self, coords, masses, elements, FFflavor, cutoff=[], spacing=.004, ffFile='PARAMS.FF'):
        """
        Setup force field and copy all atoms from molecule to IMD
        """
        
        self.checkElements(elements)
        numElem = len(self.elementlist)

# move possible periodic axes to x/x,y
        if self.edges[0] == 0 and self.edges[1] != 0:
            self.edges = [self.edges[1],self.edges[2],self.edges[0]]
            self.angles = [self.angles[1],self.angles[2],self.angles[0]]
        elif self.edges[1] == 0 and self.edges[2] != 0:
            self.edges = [self.edges[2],self.edges[0],self.edges[1]]
            self.angles = [self.angles[2],self.angles[0],self.angles[1]]
# determine periodic conditions
        if self.edges[1] == 0:
            pbc = [self.edges[0]!=0, 0, 0]
            for i in range(3):
                if not pbc[i]:
                    self.edges[i] = self.deflen
                self.angles[i] = pi/2
        elif self.edges[2] == 0:
            pbc = [1,1,0]
            self.edges[2] = self.deflen
            self.angles[:2] = [pi/2]*2
        else:
            pbc = [1,1,1]
# calculate cell vectors
        cellxx = self.edges[0]
        cellyx = self.edges[1]*cos(self.angles[2])
        cellyy = self.edges[1]*sin(self.angles[2])
        cellzx = self.edges[2]*cos(self.angles[1])
        cellzy = self.edges[2]*(cos(self.angles[0])-cos(self.angles[1])*cos(self.angles[2]))/sin(self.angles[2])
        cellzz = sqrt(self.edges[2]**2-cellzx**2-cellzy**2)

# prepare file names to set up force field
        FFname = FFflavor + '_' + ''.join(self.elementlist)
        for i in range(len(self.files)):
            self.files[i] = FFname + self.files[i]
# check current path and default path for tabulated force field files
        fps = []
        try:
            for i in range(3):
                fp = checkOpen(self.defpaths, self.files[i])
                print ' to read tabulated', FFflavor, self.exprs[i], '...'
                fps.append(fp)
                fp.close()
        except IOError:
            print 'No tabulated %s force field found in current or default directory.' % FFname
            paramArray = self.readForceField(FFflavor, ffFile)
            if not cutoff:
                cutoff = self.FF[FFflavor][1]
            fps = self.writeTables2(paramArray, FFflavor, cutoff, spacing)

# initialize IMD
        IMD_EAM.SetupFF_EAM_Gen (fps[0].name, fps[2].name, fps[1].name, numElem, numElem, cellxx, 0, 0, cellyx, cellyy, 0, cellzx, cellzy, cellzz, pbc[0], pbc[1], pbc[2])

# typing all atoms into IMD data model
        IMD_EAM.PyToIMDSetup ()

        for i in range(self.natoms):
            
            x = coords[3*i]
            y = coords[3*i+1]
            z = coords[3*i+2]
            mass = masses[i]
            s = self.elementlist.index(elements[i])                                                                                                                                     
            IMD_EAM.PyToIMDAddatom (x,y,z,0,0,0,0,0,0, mass, i, s)

        IMD_EAM.PyToIMDFinal ()

        print "IMD for EAM loading done."
        return 

                                                                                                                                     
    def writeChkpt(self, filename):
        IMD_EAM.WriteChkpt(filename+'.chkpt')
        return
                                                                                                                                  
                                                                                                                                  
    def calcEnergyForce(self, coords):
        """
        Calculate forces and P.E. using imd from coords
        """
#        Copy positions from modbabel to imd.
        if IMD_EAM.GetNAtoms ()!=self.natoms:
            print "Error. Number of atoms in OBMol object and IMD data structure not identical", IMD_EAM.GetNAtoms (), self.natoms
        # here loop over all atoms in the IMD data structure
        for k in range(IMD_EAM.getncells ()):
            for i in range(IMD_EAM.getninp (k)):

                id=IMD_EAM.getNumber(k,i)
                x = float(coords[3*id])
                y = float(coords[3*id+1])
                z = float(coords[3*id+2])
                IMD_EAM.setX_x(k,i, x)
                IMD_EAM.setX_y(k,i, y)
                IMD_EAM.setX_z(k,i, z)

        IMD_EAM.ApplyPBCs ()
#        self.writeChkpt('frame')

        IMD_EAM.GetForces()

#        unit = Unit()
        assert IMD_EAM.GetNAtoms () == self.natoms, \
        "Error. Number of atoms in OBMol object and IMD data structure not identical %d!=%d" % (IMD_EAM.GetNAtoms (), natoms)
        # here loop over all atoms in the IMD data structure
        self.__energy = 0.0
        for k in range(IMD_EAM.getncells ()):
            for i in range(IMD_EAM.getninp (k)):

                id = IMD_EAM.getNumber(k,i)
                self.__forces[3*id]   = IMD_EAM.getX2_x(k,i)
                self.__forces[3*id+1] = IMD_EAM.getX2_y(k,i)
                self.__forces[3*id+2] = IMD_EAM.getX2_z(k,i)
                                                                                
                estr = IMD_EAM.getpoteng(k,i)
                self.__energy += estr

        return self.__energy, self.__forces 
    

    def cleanup(self):
        IMD_EAM.Cleanup()
        self.files = ['_Phi_r2.dat','_Rho_r2.dat','_F_Rho.dat']
        return


    def getEngery(self):
        return self.__energy


    def getForces(self):
        return self.__forces



if __name__ == '__main__':
    import sys
    import cmdf.utility.bgfio as bgfio
    from cmdf.utility.communication import systemToArrays,arraysToSystem_md

    filename = sys.argv[1]
    system = bgfio.read(filename+'.bgf')

# get arrays
    cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges, masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)
                                                                                                                              
# create imd force engine
    natoms = len(masses)
    imd = IMDForceEngine(natoms,cellDim)

    FFflavor = sys.argv[2]
    imd.setupEnergyExpression(coords, masses, elements, FFflavor)
    imd.writeChkpt(filename)
    energy,forces=imd.calcEnergyForce(coords)
    print energy
#    IMD_EAM.PrintEnergies()
    arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)
    print 'energy = %f' % system.getMolecule(0).getPotentialEnergy()

    paramArray = imd.readForceField(FFflavor, 'PARAMS.FF')
    cutoff = imd.FF[FFflavor][1]
    imd.writeTables1(paramArray, FFflavor, cutoff, .004)
                                                                                                                              
    imd.cleanup()
    imd.setupEnergyExpression(coords, masses, elements, FFflavor)
    imd.writeChkpt(filename)
    energy,forces=imd.calcEnergyForce(coords)
    print energy
    IMD_EAM.PrintEnergies()
    arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)
    print 'energy = %f' % system.getMolecule(0).getPotentialEnergy()

    imd.writeTables2(paramArray, FFflavor, cutoff, .004)
                                                                                                                             
                                                                                                                             
    imd.cleanup()
    imd.setupEnergyExpression(coords, masses, elements, FFflavor)
    imd.writeChkpt(filename)
    energy,forces=imd.calcEnergyForce(coords)
    print energy
    IMD_EAM.PrintEnergies()
    arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)
    print 'energy = %f' % system.getMolecule(0).getPotentialEnergy()


