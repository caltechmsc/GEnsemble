#
# AmberConvert by Krzysztof Murzyn
# last modification: 30.08.2001
#


#from mdconvert import AmberReader
import string, os.path,string
from Numeric import *
from MMTK import *
from MMTK.Proteins import PeptideChain, Residue, Protein
from mdconvert import misc, AmberReader
from Scientific.IO.NetCDF import NetCDFFile

# --- beggining of ParmTop related stuff ---

def getResidues(parm):
    info = parm._tup2dict(parm.info)
    #
    # Let's find the number of residues
    # with different labels
    #
    diffres = {}
    for i in parm.labres:
        try: diffres[i] = diffres[i] + 1
        except KeyError:  diffres[i] = 1
    info['INUMRES'] = len(diffres)
    if diffres.has_key('WAT '):
        info['IWATMOL'] = diffres['WAT ']
    elif diffres.has_key('HOH '):
        info['IWATMOL'] = diffres['HOH ']
    else:
        info['IWATMOL'] = 0 
    #
    # Find the number of atoms in every unique residue
    # (terminal AA should be handled correctly);
    # in general it's possible that more then one residue
    # with the same name has diffrent number of atoms
    # (terminal AAs are a typical example). Basing on ATOMRES
    # we thus will update the number of REALLY different residues
    # in DIFFRES.
    #
    atomres = {}
    unique  = {}
    for i in range(len(parm.ipres)):
        try: ires = tuple(range(parm.ipres[i],parm.ipres[i+1])) 
        except: 
             ires = tuple(range(parm.ipres[i],parm.getInfo()['NATOM']+1))
        iname = parm.labres[i]
        if not atomres.has_key(iname):
            atomres[iname] = [ires,]
            unique[iname]  = [iname,]
        else:
            hit = None
            for ia in range(len(unique[iname])):
                if len(atomres[unique[iname][ia]][0]) == len(ires):
                    hit = unique[iname][ia]
            if not hit: hit = iname+str(len(unique[iname]))
            try: atomres[hit].append(ires)
            except KeyError:
                atomres[hit] = [ires,]
                unique[iname].append(hit)
    for ia in atomres.keys(): diffres[ia] = len(atomres[ia])
    # parm.diffres = diffres
    # parm.atomres = atomres
    # return parm._dict2tup(diffres),\
    #        parm._dict2tup(atomres)
    return diffres, atomres

def getResidueTopology(parm,res_name,res_numb=0,
                       diffres=None,atomres=None):
    """
    define topology for a residue with
    given name (res_name) and number (res_numb)
    (resnumb varies between 0 and the number of res_name
    residues in the system)
    """

    if diffres is None or atomres is None: diffres, atomres = getResidues(parm)
    try:
        bona = array(parm.bona)  # non-hydrogen atoms
        bona[:,0] = bona[:,0]/3 + 1      # the "true" indices
        bona[:,1] = bona[:,1]/3 + 1
    except IndexError: pass
    try:
        bonh = array(parm.bonh)  # hydrogen ones
        bonh[:,0] = bonh[:,0]/3 + 1
        bonh[:,1] = bonh[:,1]/3 + 1
    except IndexError: pass
    try: atomlst = atomres[res_name][res_numb]
    except IndexError: return 0
    intra_bonds = []
    inter_bonds = []
    for ib in atomlst:
        try:
            bona_hit = where(equal(bona,ib),bona,0)
            row_hita = nonzero(bona_hit[:,0])
            for ic in range(len(row_hita)):
                bond = bona[row_hita[ic]][:2]
                if bond[1] <= atomlst[-1]: intra_bonds.append(bond)
                else: inter_bonds.append(bond)
        except: pass
        try:
            bonh_hit = where(equal(bonh,ib),bonh,0)
            row_hith = nonzero(bonh_hit[:,0])
            for ic in range(len(row_hith)):
                bond = bonh[row_hith[ic]][:2]
                if bond[1] <= atomlst[-1]: intra_bonds.append(bond)
                else: inter_bonds.append(bond)
        except: pass
    intra_bonds = map(lambda v: v.tolist(),intra_bonds) # obvious...
    inter_bonds = map(lambda v: v.tolist(),inter_bonds) # with others
                                                        # residues
    return intra_bonds, inter_bonds

def getAADefinition(parm,res_name,bonds,res_numb=0):
    """ MMTK style: protein (for a backbone) and
    sidechain (for the rest)
    """
    pass

def getResidueDefinition(parm,res_name,bonds,res_numb=0,
                         diffres=None,atomres=None):
    """
    get the MMTK definition of a given residue and
    return it as a list which can be printed or
    easily transformed into evaluable Python code
    """
    definition = []
    if diffres is None or atomres is None: diffres, atomres = getResidues(parm)
    try: atoms = atomres[res_name][res_numb]
    except IndexError: return 0
    for ia in atoms:
        line = string.strip(parm.igraph[ia-1])+' = Atom(\''+\
               parm.isymbl[ia-1][0]+'\')'
        definition.append(line)
    line = 'bonds = ['
    for ia in bonds:
        line = line + 'Bond('+string.strip(parm.igraph[ia[0]-1])+\
               ','+string.strip(parm.igraph[ia[1]-1])+'), '
    line = line + ']'
    definition.append(line)
    line = 'name = \''+string.strip(res_name)+'\''
    definition.append(line)
    line = 'pdbmap = [(\''+res_name[:3]+'\', {'
    for ia in atoms:
        aname = string.strip(parm.igraph[ia-1])
        if len(aname)>3: aname = aname[-1] + aname[:3]
        line = line + '\''+aname+'\': ' +\
               string.strip(parm.igraph[ia-1])+', '
    line = line + ' }, ), ]'
    definition.append(line)
    line = 'amber_atom_type = {'
    for ia in atoms:
        line = line + string.strip(parm.igraph[ia-1])+': \''+\
               string.strip(parm.isymbl[ia-1])+'\', '
    line = line + ' }'
    definition.append(line)
    line = 'amber_charge = {'        # opls_charge ?
    for ia in atoms:
        line = line + string.strip(parm.igraph[ia-1])+\
               ': '+str(round(parm.chrg[ia-1]/18.2223,5))+', '
    line = line + ' }'
    definition.append(line)
    return len(atoms),definition

def getMoleculeDefinition(parm,resseq,resdefnames,interbonds,\
                          symbol,molname):
    """
    get the MMTK definition of a molecule which is defined
    by a list of residues RESSEQ (filenames with Group
    definitions which match these to be saved in a MMTK Database)
    """
    # the name scheme is that an underscore and the sequential number
    # is added, this is however required only to avoid ambiguity,
    # else stripped names of residues should be enough
    gj = {}
    for i in resseq:
        try: gj[i] = gj[i]+1
        except KeyError: gj[i] = 1
    definition = []
    bond = {}
    for i in range(1,len(resseq)): # it's assumed ONE inter bond
        name = resseq[i-1]
        snameA = string.replace(string.strip(name[:4]),' ','_')
        snameB = string.replace(string.strip(resseq[i][:4]),' ','_')
        if len(gj) != len(resseq):
            # there are residues in the sequence
            # which have the same name
            snameA = snameA + "_" + str(i)
            snameB = snameB + "_" + str(i+1)
        atomA = snameA + "." +\
                string.strip(parm.igraph[interbonds[name][0][0]-1])
        atomB = snameB + "." +\
                string.strip(parm.igraph[interbonds[name][0][1]-1])
         # (i,i+1) ? should be checked to which residue a given atom
         # atomB belongs (on the other hand, we are processing
         # SEQUENCE so the only information to be checked is
         # which atom of the first residue is connected to which atom of
         # the second residue
        bond[name] = 'Bond(' + atomA + ',' + atomB +'), '
        line = snameA + ' = Group(\'' + resdefnames[name] + '\')'
        definition.append(line)
    name = string.replace(string.strip(resseq[-1][:4])," ","_")
    if len(gj) != len(resseq):
        # there are residues in the sequence
        # which has the same name
        name = name + "_" + str(len(resseq))
    definition.append(name+' = Group(\''+ resdefnames[resseq[-1]]+'\')')
    line = 'bonds = ['
    for i in bond.keys(): line = line + bond[i] # sequence unimportant?
    line = line + ']'
    definition.append(line)
    definition.append('symbol = \''+symbol+'\'')
    definition.append('name = \''+molname+'\'')
    return len(resseq),definition

def getMolecules(parm,inter,
                 diffres=None,atomres=None):
    """
    find the number of molecules and their topology,
    inter is a dict containing all inter_bonds
    (thus it requires prior evaluating getResidueTopology
    for all unique residues and (!!!) res_numb = 0)
    """
    info = parm.getInfo()
    if diffres is None or atomres is None: diffres, atomres = getResidues(parm)
    molname = ""; crosslink = {}; molecules = {}; molorder = []; res1st = 0
    # --- mapping between atom numbers and residue numbers
    result = {}
    for res in range(info['NRES']-1):
        for at in range(parm.ipres[res],parm.ipres[res+1]):
            result[at] = [res,parm.labres[res]]
    for at in range(parm.ipres[info['NRES']-1],info['NATOM']+1):
            result[at] = [res,parm.labres[res]]
    _atomresmap = result
    # ---
    for ia in range(info['NRES']):
        try: natom = parm.ipres[ia+1] - parm.ipres[ia]
        except: natom = info['NATOM'] - parm.ipres[ia] + 1 # last
        name = parm.labres[ia]
        ix = 0
        while len(atomres[name][0]) != natom:
           ix = ix+1
           name = '%s%d' % (name,ix)
           try: natom = len(atomres[name][0])
           except KeyError: return 0
        molname = molname + "&" + name
         # len(inter):
         #      0 - a terminal residue or an isolated molecule
         #      1 - a residue in a sequence
         #      2 - a cross-linked residue in a sequence
         #      what about 3 or more?
        if len(inter[name]) == 2:
            if crosslink.has_key(name): crosslink[name].append(ia)
            else: crosslink[name] = [ia]
        if len(inter[name]) == 0:
            # CYY -- PAL: PAL is after NHE (inter=0)
            # multichains proteins ?
            if len(crosslink) > 0:
                for namres in crosslink.keys():
                    for ires in range(len(crosslink[namres])):
                        bondres = getResidueTopology(parm,namres,ires,
                                                     diffres,atomres)[1]
                        for at1, at2 in bondres:
                            gj = max(at1,at2)
                            print crosslink[namres][ires], namres,
                            if _atomresmap[gj][0] > ia:
                                print 'cross (extra res)',
                            else: print 'cross (intra prot)',
                            print _atomresmap[gj][0],
                            print _atomresmap[gj][1]
            if 1:
                try: molecules[molname] = molecules[molname] + 1
                except KeyError: molecules[molname] = 1
                mn_gj = tuple(string.split(molname[1:],"&"))
                try:
                    if molorder[-1][0] != mn_gj: molorder.append([mn_gj,1])
                    else: molorder[-1][1] = molorder[-1][1] + 1
                except IndexError: molorder.append([mn_gj,1])
            molname = ""; crosslink = {}; res1st = ia+1
    result = []
    for ia in molecules.keys():
        res = string.split(ia[1:],"&")
        result.append((res,molecules[ia]))
    return result, molorder #, _atomresmap

# --- end of ParmTop related stuff ---


def getMolInfo(parm):

    diffres, atomres = getResidues(parm)
    bter  = {}; btra = {}
    for i in atomres.keys():
        btra[i], bter[i] = getResidueTopology(parm,i,
                                              diffres=diffres,atomres=atomres)
    mol, order = getMolecules(parm,bter,diffres,atomres)
    result = {'Residues':(diffres,atomres), 'Bonds':(bter,btra),
              'Molecules':mol, 'Order of molecules':order}
    return result

# by MMTK.Biopolymers
# including terminal caps
_valid_aminoacids = ['ALA','ARG','ASN','ASP','CYS','GLN','GLU','GLY','HIS',
                     'ILE','LEU','LYS','MET','PHE','PRO','SER','THR','TRP',
                     'TYR','VAL','CYX','HSD','HSE','HSP','HID','HIE','HIP',
                     'NHE','NME','ACE']

def getMolType(reslist):
    """ basing on the sequence of residues find the type of molecule;
    e.g. *Molecule* or *Protein* """

    s3 = map(lambda x: string.strip(x[:min(len(x),4)]),reslist)
    for r in s3:
        if _valid_aminoacids.count(r) == 0: return 'Molecule'
    return 'Protein'

_factor = 18.2223 # convertion of charges from amber units to SI units
_epsilon = 1e-6

def getMolMassAndCharge(reslist,resdict,parm):
    """ no coment """

    mass = charge = natom = 0
    for r in reslist:
        natom = natom + len(resdict[r][0])
        mass = mass + add.reduce(take(parm.amass,array(resdict[r][0])-1))
        charge = charge + add.reduce(take(parm.chrg,
                                     array(resdict[r][0])-1))/_factor
    if abs(charge) < _epsilon: charge = 0.0
    return mass, charge, natom


def addObjects(universe,system):

    for object in system:
        if object[0] == 'Molecule':
            for i in range(object[-1]):
                gj = Molecule(object[1])
                universe.addObject(gj)
        elif object[0] == 'Protein':
            prop = {}
            for i in range(object[-1]):
                # --- 23.03.2002
                if type(object[1]).__name__ == 'string':
                    gjp = Protein(object[1])
                else: # list assumed
                    if not object[2].has_key('c_terminus'):
                        prop['c_terminus'] = 1
                    else: prop['c_terminus'] = object[2]['c_terminus']
                    if not object[2].has_key('n_terminus'):
                        prop['n_terminus'] = 1
                    else: prop['n_terminus'] = object[2]['n_terminus']
                    if not object[2].has_key('circular'): prop['circular'] = 0
                    else: prop['circular'] = object[2]['circular']
                    if not object[2].has_key('model'): prop['model'] = 'all'
                    else: prop['model'] = object[2]['model']
                    gj = PeptideChain(object[1],model=prop['model'],
                                      c_terminus=prop['c_terminus'],
                                      n_terminus=prop['n_terminus'],
                                      circular=prop['circular'])
                    gjp = Protein(gj)
                universe.addObject(gjp)
    return universe

        
def assignIndices(universe,parm):

    resseq = []
    logfile = []
    for i in universe:
        if i.__class__.__name__ == 'Protein':
            for ia in i.chains:
                for ib in ia[0].groups:
                    try: altmap = ib.pdb_alternative
                    except: altmap = None
                    for ic in ib.pdbmap:
                        atomlist = []
                        for id in ic[1].keys():
                            name = [id]
                            if altmap:
                                for ie in altmap.keys():
                                    if altmap[ie] == id: name.append(ie)
                            atomlist.append((name,ib.atomList()\
                                             [ic[1][id].number]))
                        resseq.append((ic[0],atomlist))
        elif i.__class__.__name__ == 'Molecule':
            for ia in i.pdbmap: # who cares for pdb_alternative...
                atomlist = []
                for ib in ia[1].keys():
                    atomlist.append(([ib],i.atomList()[ia[1][ib].number]))
                resseq.append((ia[0],atomlist))
        else:
            print i.__class__.__name__,' is unsupported ... yet'
            return # fix
    logfile.append(str(len(resseq))+' <-> in amber: '+str(len(parm.labres)))
    natom = parm._tup2dict(parm.info)['NATOM']
    for i in range(len(resseq)):
        logi = []
        first = parm.ipres[i]
        try: last = parm.ipres[i+1]
        except: last = natom + 1
        anum = last - first
        logi.append([i,resseq[i][0],first-1,last-2])
        names = map(string.strip,parm.igraph[first-1:last-1])
        names = map(string.upper,names)
        logi.append(names)
        for ia in resseq[i][1]:
            logi.append([ia[0]])
            index = None
            ibul = map(string.upper,ia[0])
            for ib in ibul: # ia[0]
                try: index = names.index(ib)
                except ValueError:
                    if isdigit(ib[-1]): gj = ib[-1] + ib[:-1]
                    else: gj = None
                    if names.count(gj) == 0:
                        if isdigit(ib[0]): gj = ib[1:] + ib[0]
                        else: gj = ib # added on 22.2.01
                    logi[-1].append([ib,gj])
                    try: # accept
                        index = names.index(gj)
                        logi[-1].append(gj)
                    except: pass # reject
                if index: break
            if index is None:
                print 'atom names do not match'
                logfile.append(logi)
                return None,logfile
            index = index + first
            ia[1].setIndex(index-1)
            logi.append([ia[1],ia[1].index])
        if len(resseq[i][1]) != anum:
            print 'AmberConver.assignIndices:'
            print resseq[i][1]
            print len(resseq[i][1])
            print 'oops'
            logfile.append(logi)
            universe = None
            break
    return universe,logfile


def isdigit(char):

    try: return string.atoi(char)
    except ValueError: return None

_extbase = {'xyz': 'configuration',
            'vel': 'velocities',
            'rst': 'configuration', # velocities omitted
                                    # due to sparse sampling
            'ene': 'custom'} # todo

def validateTrajectory(traj,kind):

    ext = filter(lambda x,y=kind: x == y[-3:],_extbase.keys())[0]
    nc = NetCDFFile(traj.filename,'a')
    vars = ['step','time',_extbase[ext]]
    if nc.dimensions.has_key('box_size_length') and ext != 'vel':
        vars.append('box_size')
    crate = Crate(nc,vars)
    crate.ext = ext
    
    return crate #,block_size,len(nc.variables['step']),ext


def appendNetCDFXYZ(item,traj,stbar,wrap_flag=0,frame_start=0,
                    frame_in=(1,1,None),time_set=(0.,1.)):

    crate = validateTrajectory(traj,item.label)
    fin1, finS, finN = frame_in

    block_size = crate.bs
    nclen = len(crate.nc.variables['step'])
    if block_size > 0: lstep = min(frame_start,nclen*block_size)
    else: lstep = min(frame_start,nclen)
    if item.data.dimensions.has_key('minor_step_number'):
        bs = item.data.dimensions['minor_step_number']
    else: bs = 1
    finN = min(finN,len(item.data.variables['step'][:])*bs)

    frame_it = 0
    chunk = mmtkTrajectoryFile(item.data)
    for frame_it in range(fin1,finN,finS):
        stbar.set('Reading frame %d ( %d )' % (frame_it,crate.index['step']))
        chunk.getChunk(frame_it,kind=_extbase[crate.ext])
        info = chunk.getInfo()
        crate.append('step',lstep)
        if info['TIME'] is None: ctim = time_set[0] + time_set[1]*frame_it
        else: ctim = info['TIME']
        crate.append('time',ctim)
        crate.append('box_size',info['BOX'])
        if crate.ext == 'xyz':
            if wrap_flag == 1 and info['BOX']:
                conf = Configuration(traj.universe,
                               chunk.traj,array(info['BOX'])) # nm assumed
                traj.universe.setConfiguration(conf)
                traj.universe.scaleSize(1.0)
                xyz = traj.universe.configuration().array
            else: xyz = chunk.traj
            crate.append('configuration',xyz)
        elif ext == 'vel': crate.append('velocities',chunk.traj)
        if crate.index['step'] == crate.itemsize['step'][1]:
            crate.writeToFile(lstep)
            crate.reset()
        lstep = lstep+1
        
    if not crate.empty: # there's date to write to disk
        crate.writeToFile(lstep)
    crate.cleanup()
    del(crate)
    

def appendAmberTraj(amber_traj,traj,stbar,wrap_flag=0,frame_start=0,
                    frame_in=(1,1,None),time_set=(0.,1.),
                    natom=None,AmberCaux=0):

    crate = validateTrajectory(traj,amber_traj.label)
    fin1, finS, finN = frame_in

    block_size = crate.bs
    nclen = len(crate.nc.variables['step'])

    nfl = len(amber_traj.filelist)
    # wczesniej: np. dla minor=100, dopisz ostatnie 73
    if block_size > 0: lstep = min(frame_start,nclen*block_size)
    else: lstep = min(frame_start,nclen)

    fac = {'box_size': Units.Ang, 'configuration': Units.Ang,
           'velocities': sqrt(4.184)}
    # internal Amber Units of vel are Ang/(1/20.455)ps
    # we're storing in MMTK units: nm/ps

    frame_it = 0
    frame_appended = 0
    for file in range(nfl):
        if frame_it > finN: break
        filename = amber_traj.filelist[file]
        stbar.set('Reading: %s ( %d / %d ) frame: %d ( %d )' % (
            os.path.basename(filename),file,nfl,frame_it,crate.index['step']))
        chunk = AmberReader.AmberTrajectoryFile(\
            filename, skip=(frame_it-fin1) % finS or frame_it < fin1,
            natom=natom,AmberCaux=AmberCaux)
        if natom is None: natom = chunk.getInfo()['NATOM']
        while 1:
            info = chunk.getInfo()
            status = 'Frame %d ' % frame_it
            if frame_it >= fin1 and (frame_it-fin1) % finS == 0:
                status = status + 'saved with index %d' % lstep
                stbar.set(status)
                crate.append('step',lstep)
                if info['TIME'] is None:
                    ctim = time_set[0] + time_set[1]*frame_appended
                else: ctim = info['TIME']
                crate.append('time',ctim)
                print frame_it, frame_appended, ctim, info['BOX']
                if crate.ext == 'xyz':
                    try:
                        crate.append('box_size',
                                     fac['box_size']*array(info['BOX']))
                    except: pass # nonperiodic ?
                    xyz = fac[_extbase[crate.ext]]*chunk.traj
                    if wrap_flag == 1 and info['BOX']:
                        conf = Configuration(traj.universe,xyz,
                                          fac['box_size']*array(info['BOX']))
                        traj.universe.setConfiguration(conf)
                        traj.universe.scaleSize(1.0)
                        xyz = traj.universe.configuration().array
                    crate.append('configuration',xyz)
                elif crate.ext == 'vel':
                    xyz = fac[_extbase[crate.ext]]*chunk.traj
                    crate.append('velocities',xyz)

                if crate.index['step'] == crate.itemsize['step'][1]:
                    crate.writeToFile(lstep)
                    crate.reset()
                lstep = lstep+1
                frame_appended = frame_appended + 1
            else:
                status = status + 'skipped'
                stbar.set(status)
            frame_it = frame_it + 1
            if chunk.file is None or frame_it > finN: break
            stbar.set('Reading: %s ( %d / %d ) frame: %d ( %d )' % (
                os.path.basename(filename),file,nfl,frame_it,
                crate.index['step']))
            chunk.getChunk(skip=(frame_it-fin1)%finS or frame_it<fin1,
                           AmberCaux=AmberCaux)

    if not crate.empty: # there's date to write to disk
        print 'Warning: flushing incomplete block data (%d frames)' % lstep
        crate.writeToFile(lstep)
    crate.cleanup()
    del(crate)

def appendAmberEne(amber_ene,traj,stbar,wrap_flag=0,frame_start=0,
                   frame_in=(1,1,None),time_set=(0.,1.),what='box_size'):

    #crate = validateTrajectory(traj,amber_ene.label)
    fin1, finS, finN = frame_in

    block_size = crate.bs
    nclen = len(crate.nc.variables['step'])

## def getProfile(item='Density',pattern='pr2u*.ene',entrysize=None):

##     enefiles = glob.glob(pattern)
##     enefiles.sort()
##     print len(enefiles),' energy files found'

##     res = {}
##     ow = 0
##     for file in enefiles:
##         gj = AmberReader.AmberEneFile(file).ene
##         if len(gj[item]) != entrysize:
##             print file,len(gj[item]),'ignored'
##         else:
##             for t in range(len(gj['time(ps)'])):
##                 time = gj['time(ps)'][t]
##                 if res.has_key(time):
##                     print time,'overwritten',file
##                     ow = ow+1
##                 res[time] = gj[item][t]

##     print ow,'time frames were overwritten'
##     data = map(lambda x, r=res: (x,r[x]),res.keys())
##     data.sort()
##     res = array(data)
##     return res, gj.keys()



class mmtkTrajectoryFile:

    def __init__(self,nc):

        self.nc = nc
        if nc.dimensions.has_key('minor_step_number'):
            self.bs = nc.dimensions['minor_step_number']
        else: self.bs = 0
        self.info = {'NATOM':0,'BOX':None,'TIME':None}
        self.info['TITLE'] = self.molMakeUp()

    def getChunk(self,index,kind='configuration'):

        # self.traj, self.file, info['BOX'], info['TIME']
        vars = self.nc.variables
        if self.bs > 0: ix1,ix2 = int(index/self.bs),index % self.bs
        else: ix1,ix2 = index, None
        if vars.has_key('box_size'):
            if self.bs > 0: self.info['BOX'] = vars['box_size'][ix1,...,ix2]
            else: self.info['BOX'] = vars['box_size'][ix1]
        if self.bs > 0:
            self.info['TIME'] = vars['time'][ix1,ix2][0]
            self.traj = vars[kind][ix1,...,ix2]
        else:
            self.info['TIME'] = vars['time'][ix1]
            self.traj = vars[kind][ix1]

    def getInfo(self):

        return self.info

    def molMakeUp(self):

        desc = self.nc.variables['description'][:].tostring()
        self.info['NATOM'] = string.count(desc,'A(')
        nmol = string.count(desc,'M(')
        gj = 0; mols = {}
        for i in range(nmol):
            gj = gj+string.find(desc[gj:],'M(')+3
            name = desc[gj:gj+string.find(desc[gj:],"'")]
            try: mols[name] = mols[name] + 1
            except: mols[name] = 1
            gj = gj + len(name)+1
        nprot = string.count(desc,"l('Protein'")
        if nprot > 0: title = '%d: Protein, ' % nprot
        else: title = ''
        for key in mols.keys():
            title = title + '%s: %d, ' % (key,mols[key])
        return title

        

class Crate:

    def __init__(self,nc,vars):

        self.itemsize = {}
        self.index = {}
        if nc.dimensions.has_key('minor_step_number'):
            dims = ['minor_step_number']
            self.bs = nc.dimensions['minor_step_number']
        else: dims = []; self.bs = 0

        for var in vars:
            temp = self._trajTemplate[var]
            shape = tuple(temp[1]+dims)
            if not nc.variables.has_key(var):
                gj = nc.createVariable(var,temp[0],shape)
            shape = map(lambda x,nc=nc: nc.dimensions[x],
                        filter(lambda x: x != 'step_number',shape))
            print var,shape,
            if len(shape) > 1: # and self.bs > 0:
                if self.bs > 0: shape = tuple([shape[-1]]+shape[:-1])
                else: shape = tuple([1]+shape)
            else:
                if self.bs > 0: shape = (shape[0],) # [1]+shape
                elif len(shape) == 1: shape = tuple([1]+shape)
                else: shape = tuple([1])
            print shape
            setattr(self,var,zeros(shape,temp[0]))
            gj = getattr(self,var)
            self.index[var] = 0
            self.itemsize[var] = [getattr(self,var).itemsize(),
                                  multiply.reduce(shape)]

        self.empty = 1
        self.nc = nc
        self.totsize = add.reduce(map(lambda x,i=self.itemsize: \
                           multiply.reduce(i[x]),self.itemsize.keys()))
        self.maxmem = misc.getMemoryInfo()
        print self.totsize, self.maxmem
        # limit size of arrays if totsize exceeds maxmem

    _trajTemplate = {'configuration': ['f',['step_number',
                                            'atom_number','xyz']],
                     'velocities': ['f',['step_number',
                                         'atom_number','xyz']],
                     'box_size': ['f',['step_number',
                                       'box_size_length']],
                     'time': ['f',['step_number']],
                     'step': ['i',['step_number']],
                     'custom': ['f',['step_number']]}

    def append(self,kind,value):

        if value is None: return
        gj = getattr(self,kind)
        if type(value).__name__ == 'array':
            gj[self.index[kind]] = value.astype(gj.typecode())
        else: gj[self.index[kind]] = value
        #else: setattr(self,kind,value)
        self.index[kind] = self.index[kind]+1
        if self.index[kind] > self.itemsize[kind][1]: raise "Crate is full"
        self.empty = 0

    def reset(self):

        for var in self.index.keys():
            gj = getattr(self,var)
            setattr(self,var,zeros(gj.shape,gj.typecode()))
            self.index[var] = 0
            del gj
        self.empty = 1

    def cleanup(self):

        self.nc.close()

    def writeToFile(self,ix,offset=0,length=None):
        """ offset, length: write a part of data TO DO """

        if self.bs > 0: ix = ix/self.bs - (ix % self.bs == 0)
        for var in self.index.keys():
            shape = getattr(self,var).shape
            if self.bs > 0:
                if len(shape) > 1: 
                    shape = tuple(range(len(shape))[1:]+[0])
                    self.nc.variables[var][ix] = transpose(\
                        getattr(self,var),shape)
                else: self.nc.variables[var][ix] = getattr(self,var)
            else:
                gj = getattr(self,var)[0] # [0]
                temp = self._trajTemplate[var]
                self.nc.variables[var][ix] = array(gj).astype(temp[0])
            self.nc.sync()





