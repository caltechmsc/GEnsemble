#
# AmberReader by Krzysztof Murzyn
# last revision: 03.06.2002
#
# 29.08.01 A buglet in getResidueTopology was fixed. It was wrongly assumed
#          that in the system there's at least one atom which is NOT connected
#          with hydrogen (self.bona > 0)
#
# 05.09.02 Speeding up AmberTrajectoryFile.getChunk method. If AmberCaux
#          module (written in C) is present, Amber trajectories are read
#          over 100 times than in the previous version. Otherwise, the old
#          and slow Python stuff is used
#

from Scientific.IO.TextFile import TextFile
from Scientific.IO.FortranFormat import *
import string
import Numeric
import sys

try: import amber_caux
except ImportError: amber_caux = None

if amber_caux is not None:
    print 'Module amber_caux successfully imported'

format_a80 = FortranFormat('A80')
format_20a4 = FortranFormat('20A4')
format_12i6 = FortranFormat('12I6')
format_5e16_8 = FortranFormat('5E16.8')
format_i5__5e15_7 = FortranFormat('I5,5E15.7')
format_6f12_7 = FortranFormat('6F12.7')
format_10f8_3 = FortranFormat('10F8.3')
format_f8_3 = FortranFormat('F8.3')
format_i10 = FortranFormat('I10')
format_a19a2f20_10 = FortranFormat('A19,A2,F20.10')
format_a8i11 = FortranFormat('A8,I11')

def eatMe(self,file,format,nmax,dim=1):

    nfields = len(format)
    l2eat = divmod(dim*nmax,nfields)
    if l2eat[1] != 0: nline = l2eat[0]+1
    else:             nline = l2eat[0]
    nline = nline-1
    parmbuf = ()
    for i in range(nline):
        parmbuf = parmbuf + tuple(FortranLine(file.readline(),format))
    gj = list(FortranLine(file.readline(),format))
    if l2eat[1] > 0: parmbuf = parmbuf + tuple(gj[:l2eat[1]])
    else: parmbuf = parmbuf + tuple(gj)

    i = 0 
    result = []
    nitem = len(parmbuf) 
    while i < nitem and nmax > 0:
        if dim == 1: result.append(parmbuf[i])
        else:
            gj = []
            for j in range(dim): gj.append(parmbuf[i+j])
            gj = tuple(gj)
            result.append(gj)
        i = i+dim

    result = tuple(result)

    return result

def dict2tup(self,dict):
    tuple(dict.items())
    return tuple(dict.items())

def tup2dict(self,tup):
    result = {}
    for i in range(len(tup)):
        result[tup[i][0]] = tup[i][1]
    return result

#####################################################
#
# class AmberParmTopFile handles parm topology files
#
#####################################################
class AmberParmTopFile:
 
    def __init__(self,filename):
        file = TextFile(filename)
        self._procParmTop(file)
        file.close()

    def _procParmTop(self,file):
        parmbuf = []
        self.info = {}
        nline = 4
        for i in range(nline):
            parmbuf.append(file.readline())
        header = FortranLine(parmbuf[0],format_a80)
        iset1  = FortranLine(parmbuf[1],format_12i6)
        iset2  = FortranLine(parmbuf[2],format_12i6)
        iset3  = FortranLine(parmbuf[3],format_12i6)
        if header[0][-1] == '\n': header[0] = header[0][:-1]
        title = string.strip(header[0])
        self.info = { 'title':title, \
            'NATOM':iset1[0],'NTYPES':iset1[1],'NBONH':iset1[2], \
            'MBONA':iset1[3],'NTHETH':iset1[4],'MTHETA':iset1[5], \
            'NPHIH':iset1[6],'MPHIA':iset1[7],'NEXT':iset1[10], \
            'NRES':iset1[11], \
            'NBONA':iset2[0],'NTHETA':iset2[1],'NPHIA':iset2[2], \
            'NUMBND':iset2[3],'NUMANG':iset2[4],'NPTRA':iset2[5], \
            'NATYP':iset2[6],'NPHB':iset2[7],'IFPERT':iset2[8], \
            'NBPER':iset2[9],'NGPER':iset2[10],'NDPER':iset2[11], \
            'MBPER':iset3[0],'MGPER':iset3[1],'MDPER':iset3[2], \
            'IFBOX':iset3[3],'NMXRS':iset3[4],'IFCAP':iset3[5] }
            # Eeeh... I know!
        self.igraph = self._eatMe(file,format_20a4,self.info['NATOM'])
            # The user atoms names
        self.chrg = self._eatMe(file,format_5e16_8,self.info['NATOM'])
            # The atom charges
        self.amass = self._eatMe(file,format_5e16_8,self.info['NATOM'])
            # The atom masses
        self.iac = self._eatMe(file,format_12i6,self.info['NATOM'])
            # index for the atom types involved in Lennard Jones (6-12)
            # interactions. See ICO below.
        self.numex = self._eatMe(file,format_12i6,self.info['NATOM'])
            # total number of excluded atoms for atom 'i'.
            # See NATEX bellow.
        self.ico = self._eatMe(file,format_12i6, \
                                 self.info['NTYPES']*self.info['NTYPES'])
            # provides the index to the nonbon parameter arrays CN1,
            # CN2 and ASOL, BSOL. All possible 6-12 or 10-12 atoms type
            # interactions are represented.
            # NOTE: A particular atom type can have either a 10-12 or
            # a 6-12 interaction, but not both. The index is
            # calculated as follows:
            #
            #   index = ICO(NTYPES*(IAC(i)-1) + IAC(j))
            # 
            # If index is positive, this is an index into the 6-12
            # parameter arrays (CN1 and CN2) otherwise it is
            # an index into the 10-12 parameter arrays (ASOL & BSOL)
        self.labres = self._eatMe(file,format_20a4,self.info['NRES'])
            # the residue labels
        self.ipres = self._eatMe(file,format_12i6,self.info['NRES'])
            # atoms in each residue are listed for atom i in IPRES(i)
            # to IPRES(i+1)-1 ... (e.g. ipres[0]=ipres(1)=1,
            # ipres[1]=ipres(2)=9 ... 1st res has 8 atoms). In other words,
            # for each residue the index of first atom is given.
        self.rk = self._eatMe(file,format_5e16_8,self.info['NUMBND'])
            # force constant for the bonds of each type, kcal/mol
        self.req = self._eatMe(file,format_5e16_8,self.info['NUMBND'])
            # equilibrium bond length for the bonfs of each type,
            # angstroms
        self.tk = self._eatMe(file,format_5e16_8,self.info['NUMANG'])
            # force constant for angles of each type, kcal/mol A**2
        self.teq = self._eatMe(file,format_5e16_8,self.info['NUMANG'])
            # equilibrium angle for the angles of each type, degrees
        self.pk = self._eatMe(file,format_5e16_8,self.info['NPTRA'])
            # force constant for the dihedrals of each type, kcal/mol
        self.pn = self._eatMe(file,format_5e16_8,self.info['NPTRA'])
            # periodicity of the dihedral of a given type
        self.phase = self._eatMe(file,format_5e16_8,self.info['NPTRA'])
            # phase of the dihedral of a given type
        self.solty = self._eatMe(file,format_5e16_8,self.info['NATYP'])
            # currently unused Av5 (anyway must be read)
        self.cn1 = self._eatMe(file,format_5e16_8, \
                                 self.info['NTYPES']*(self.info['NTYPES']+1)/2)
            # Lennard Jones r**12 terms for all possible atom type
            # interactions, indexed by ICO and IAC; for atom i and j where
            # i<j, the index into this array is as follows 
            # (assuming in index is positive):
            # cn1(ico(ntypes*iac(i)-1+iac(j)))
        self.cn2 = self._eatMe(file,format_5e16_8, \
                                 self.info['NTYPES']*(self.info['NTYPES']+1)/2)
            # Lennard Jones r**6 terms for all possible atom type
            # interactions. Indexed like CN1 above.
            # -----------------------------------------------------------------
            # NOTE: the atom numbers in the arrays which follow that describe
            # bonds, angles, and dihedrals are obfuscated by the following 
            # formula (for runtime speed in indexing arrays and to make the 
            # user confused...). The true atom number equals the absolute value
            # of the number divided by three, plus one. In the case of
            # dihedrals, if the third atom is negative, this implies an
            # impropor torsion and if the fourth atom is negative, this implies
            # that end group interactions are to be ignored.
            # End group interactions are ignored, for example,
            # in dihedrals of various ring systems (to prevent
            # double counting) and in multiterm dihedrals.
            # ----------------------------------------------------------------
        self.bonh = self._eatMe(file,format_12i6,self.info['NBONH'],dim=3)
            # indexes of atoms (one of them is hydrogen) forming a covalent 
            # bond; data are orgenised as follows: each single tuple
            # consists of indexes of atom i, atom j and an index into parameter
            # arrays RK and REQ
        self.bona = self._eatMe(file,format_12i6,self.info['NBONA'],dim=3)
            # as above but neither of atoms is hydrogen
        self.theth = self._eatMe(file,format_12i6,self.info['NTHETH'],dim=4)
            # tuple[i]: [0] atom involved in angle i, angle contains hydrogen;
            # [1] atom involved in angle i; [2] atom involved in angle i; 
            # [3] index into parameter arrays TK and TEQ for angle [0]-[1]-[2]
        self.theta = self._eatMe(file,format_12i6,self.info['NTHETA'],dim=4)
            # as above but neither of atoms is hydrogen
        self.phih = self._eatMe(file,format_12i6,self.info['NPHIH'],dim=5)
            # tuple[i]: [0]-[1]-[2]-[3] atoms involved in dihedral i,
            # angle contains hydrogen; [4] index into parameter arrays PK, PN,
            # and PHASE for this dihedral
        self.phia = self._eatMe(file,format_12i6,self.info['NPHIA'],dim=5)
            # as above but neither of atoms is hydrogen. NOTE: if the 
            # periodicity (PN) is negative, this implies the following entry
            # in the PK, PN, and PHASE arrays is another term in a multitermed
            # dihedral.
        self.natex = self._eatMe(file,format_12i6,self.info['NEXT'])
            # the excluded atom list. To get the excluded list for atom i
            # you need to traverse the NUMEX list, adding up all the previous
            # NUMEX values, since NUMEX(i) holds the number of excluded atoms
            # for atom i, not the index into the NATEX list.
            # Let IEXCL = SUM(NUMEX(j),j=1,i-1), then excluded atoms are
            # NATEX(IEXCL) to NATEX(IEXCL+NUMEX(i)).
        self.asol = self._eatMe(file,format_5e16_8,self.info['NPHB'])
            # the value for r**12 term for hydrogen bonds of all possible
            # types. Index into these arrays is equivalent to the CN1 and
            # CN2 arrays, however the index is negative. For example,
            # for atoms i and j, with i<j, the index is:
            # -(NTYPES*IAC(i)-1+IAC(j))
        self.bsol = self._eatMe(file,format_5e16_8,self.info['NPHB'])
            # the value for r**10 term for hydrogen bonds of all possible
            # types. Indexed like ASOL.
        self.hbcut = self._eatMe(file,format_5e16_8,self.info['NPHB'])
            # no longer in use but read anyway
        self.isymbl = self._eatMe(file,format_20a4,self.info['NATOM'])
            # the AMBER atom types for each atom
        self.itree = self._eatMe(file,format_20a4,self.info['NATOM'])
            # the list of tree joining information, classified into five
            # types. M -- main chain, S -- side chain, B -- branch point,
            # 3 -- branch into three chains, E -- end of the chain.
            # M can have 1,2,3 or 4 atoms connected to it; E can have 1
            # atom connected; S - 2 atoms; B - 3 atoms; 3 - 4 atoms...
            # In A5 there are additionally types 4,5,6...
        self.join = self._eatMe(file,format_12i6,self.info['NATOM'])
            # tree joining information, potentially used in ancient
            # analysis programs (MMTK is quite young, though).
            # It can be used to extract information about, for example,
            # the number of molecules and the topology of each of them.
            # This is valid for nonperiodic systems. If IFBOX==1 this
            # this information is given explicitly below (NSPM,NSP).
        self.irotat = self._eatMe(file,format_12i6,self.info['NATOM'])
            # apparently the last atom that would move if atom i was
            # rotated, however the meaning has been lost over time.
        if self.info['IFBOX'] == 1:
            iset1 = FortranLine(file.readline(),format_12i6) 
            self.info['IPTRES'],self.info['NSPM'],self.info['NSPSOL'] = \
                      iset1[0],iset1[1],iset1[2]
            self.nsp = self._eatMe(file,format_12i6,self.info['NSPM'])
            iset1 = FortranLine(file.readline(),format_5e16_8)
            self.info['BETA'],self.info['BOX'] = iset1[0], \
                      (iset1[1],iset1[2],iset1[3])
        if self.info['IFCAP'] == 1:
            iset1 = FortranLine(file.readline(),format_12i6)
            self.info['NATCAP'] = iset1[0]
            iset1 = FortranLine(file.readline(),format_5e16_8)
            self.info['CUTCAP'],self.info['CAP_XYZ'] = iset1[0], \
                      (iset1[1],iset1[2],iset1[3])
            # the remaining part of ParmTopFile is not important
            # (at the moment...)
        self.info = self._dict2tup(self.info)    

    _dict2tup = dict2tup
    _tup2dict = tup2dict
    _eatMe = eatMe

    def getInfo(self):
        return self._tup2dict(self.info)

        
##########################################################
#
# class AmberRestartFile handles BOX, CRD etc.
#
##########################################################
class AmberRestartFile:
 
    def __init__(self,filename):
        file = TextFile(filename)
        self._procRestart(file)
        file.close()

    def _procRestart(self,file):
        header = FortranLine(file.readline(),format_a80)
        iset1 = FortranLine(file.readline(),format_i5__5e15_7)
        if header[0][-1] == "\n": header[0] = header[0][:-1]
        title = string.strip(header[0])
        self.info = {'TITLE':title,'NATOM':iset1[0],'TIME':iset1[1]}
        self.xyz = self._eatMe(file,format_6f12_7, \
                            self.info['NATOM'],dim=3)
            # X,Y,Z coordinates
        self.info['XYZ'] = len(self.xyz)
        try:
            self.vel = self._eatMe(file,format_6f12_7, \
                            self.info['NATOM'],dim=3)
            # velocities (if dynamics)
        except EOFError:
            self.info['VEL'] = 0
        else:
            self.info['VEL'] = len(self.vel) 
        try:
            iset1 = FortranLine(file.readline(),format_6f12_7)
                # size of the periodic box
            self.info['BOX'] = (iset1[0],iset1[1],iset1[2])     
        except EOFError:
            self.info['BOX'] = 0
        self.info = self._dict2tup(self.info)

    _tup2dict = tup2dict
    _dict2tup = dict2tup
    _eatMe = eatMe

    def getInfo(self):
        return self._tup2dict(self.info)
        
#######################################################
#
# both coordinates and velocity files
# share the same class
#
# units: Amber: Ang, Ang/(1/20.455)ps
#        MMTK :  nm,  nm/ps
#
#######################################################

class AmberTrajectoryFile:
 
    def __init__(self,filename,skip=0,natom=None,AmberCaux=0):
        self.line = None
        self.info = None
        # format: 10f8.3
        self._nfields = 10
        self._fieldwidth = 8

        def _findNumberOfAtoms(self):
            """an attemt to establish the number of atoms in a trajectory"""
            _total = self._nfields*self._fieldwidth
            f = TextFile(self.filename)
            title = f.readline()
            line = f.readline()
            nlines = 0
            while len(line) > _total:
                line = f.readline()
                nlines = nlines + 1
            natom = nlines*10/3
            natpot = nlines*10%3
            if natpot > 0:
                if len(line)/self._fieldwidth >= (3 - natpot):
                    natom = natom + (len(line)/self._fieldwidth + natpot)/3 # +1
            elif len(line)/self._fieldwidth >= 3 and\
                 len(f.readline())/self._fieldwidth == 3: # box dims
                    natom = natom + 1
            else: natom = None
            gj = f.close()
            return natom

        file = TextFile(filename)
        self.file = file
        self.filename = filename
        header = FortranLine(file.readline(),format_a80)
        if header[0][-1] == "\n": header[0] = header[0][:-1]
        title = string.strip(header[0])
        if natom is None: natom = _findNumberOfAtoms(self)
        self.info = {'NATOM': natom}
        self.line = None
        if self.info['NATOM'] is None:
            a.file.close()
            raise NameError, 'You must give the number of atoms'
        self.info['BOX'],self.info['TIME'],self.info['#FRAMES'] = None,None,0
        self.framebuf = Numeric.zeros((natom*3,),'d')
        self.info['TITLE'] = title
        self.getChunk(skip,AmberCaux)

    _tup2dict = tup2dict
    _dict2tup = dict2tup

    def getChunk(self,skip=0,AmberCaux=0):

        def _eatMe(self,skip,AmberCaux):

            natom = self.info['NATOM']
            nlines = natom*3/self._nfields - 1
            linelen = self._nfields*self._fieldwidth
            if self.line is None: line = self.file.readline()
            else: line = self.line
            if skip != 0:
                while nlines >= 0:
                    line = self.file.readline()
                    nlines = nlines - 1
                result = None
            elif AmberCaux:
                result = []
                for i in range(0,linelen,self._fieldwidth):
                    result.append(float(line[i:i+self._fieldwidth]))
                self.framebuf[:self._nfields] = result
                amber_caux.readframe(self.file.file,
                                     self.framebuf[self._nfields:],
                                     (nlines,linelen,self._fieldwidth))
                gj = natom*3%self._nfields
                last = (nlines+1)*self._nfields #?
                if gj > 0: # last line
                    result = []
                    line = self.file.readline()
                    for i in range(0,gj*self._fieldwidth,self._fieldwidth):
                        result.append(float(line[i:i+self._fieldwidth]))
                    self.framebuf[last:last+len(result)] = result
            else: # slooow reading, AmberCaux module (in C) not present
                framebuf = ()
                while nlines >= 0:
                    fl = []
                    for i in range(self._nfields):
                        fl.append(float(line[self._fieldwidth*i:\
                                             self._fieldwidth*(i+1)]))
                    framebuf = framebuf + tuple(fl)
                    line = self.file.readline()
                    nlines = nlines - 1
                gj = natom*3%self._nfields
                if gj > 0: # last line
                    fl = []
                    for i in range(gj):
                        fl.append(float(line[self._fieldwidth*i:\
                                             self._fieldwidth*(i+1)]))
                    framebuf = framebuf + tuple(fl)
                self.framebuf = Numeric.array(framebuf,'d')
            if skip == 0:
                if AmberCaux: nitem = last + gj
                else: nitem = len(framebuf) 
                n3 = divmod(nitem,3)
                nitem = nitem - n3[1]
                result = Numeric.reshape(self.framebuf[n3[1]:nitem],(n3[0],3))
            else: result = None
    #
    # end skip
    # -----------------------------------------------------------------------
    
    #
    # pack each triplet (x,y,z) into tuple, and add to INFO time of frame read
    # (if it exists...)
    # ----------------------------------------------------------------------- 
            try:
                line = self.file.readline()
                # is info about PBC present? if no, keep up appearances... 
                if len(line[:-1]) == 3*self._fieldwidth:
                    self.info['BOX'] = tuple(\
                        FortranLine(line,FortranFormat('3F8.3')))
                    self.line = None
                else: self.line = line
            except EOFError: pass
            # done ...
            if self.info['NATOM'] == 0: 
                self.info['NATOM'] = nitem
            return result

        if self.file is None: return None
        frame = _eatMe(self,skip,AmberCaux)
        self.info['#FRAMES'] = self.info['#FRAMES'] + 1
        if frame: self.traj = frame
        else: self.traj = None
        if not self.line:
	    line = self.file.readline()
            if line == '': # EOF
                self.file.close()
                self.file = None
            else: self.line = line


    def getInfo(self):
        #return self._tup2dict(self.info)
        return self.info


########################################################################
#
# class AmberEneFile handles ENE files
#
########################################################################
class AmberEneFile:

    def __init__(self,filename):
        file = TextFile(filename)
        self._procEne(file)
        file.close()

    def _procEne(self,file):
        self.ene = []
        lines = file.readlines()
        mark = lines[1][:6]
        if mark == 'L1  Te':    # Amber 5 like...
            self.info = {'VERSION':5}
            lframe = divmod(len(lines),10)
    # ----------------------------------------------------
    # let's process header first and prepare data struct.
    # ----------------------------------------------------
            for i in range(10): # there are 10 lines L[0-9]
                                # and 40 numbers to read in
                                # in a single frame
                iset1 = string.split(lines[i][2:])
                for j in iset1:
                    self.ene.append([j,[]])
    # ----------------------------------------------------
    # completing data ...
    # ----------------------------------------------------
            for i in range(lframe[0]-1):      # header first
                self._eatMe5(file,i+1,lines)
        elif mark == 'Nsteps':  # Amber 4 like...
            self.info = {'VERSION':4,\
                         'TITLE':string.strip(lines[0][:-1])}
            lframe = divmod(len(lines),41)    # 40 numbers
                                              # & a bar
    # ----------------------------------------------------
    # let's read the 1st frame to prepere data struct
    # ----------------------------------------------------
            iset1 = FortranLine(lines[1],format_a8i11)
            self.ene.append([iset1[0][:-2],[iset1[1]]])
            for i in range(39): # 40 numbers in 40 lines
                iset1 = FortranLine(lines[i+2],format_a19a2f20_10)
                self.ene.append([string.strip(iset1[0]),[iset1[2]]])
    # ----------------------------------------------------
    # completing data ...
    # ----------------------------------------------------
            for i in range(lframe[0]-1):
                self._eatMe4(file,i+1,lines)
        self.info = self._dict2tup(self.info)
        for i in range(len(self.ene)):
            self.ene[i][1] = tuple(self.ene[i][1]) 
            self.ene[i] = tuple(self.ene[i])
        self.ene = self._tup2dict(tuple(self.ene))

    def _eatMe5(self,file,frame,lines):
        for i in range(10):
            iset1 = string.split(lines[i+frame*10][2:])
            if i == 0:
               self.ene[i*4+0][1].append(int(iset1[0]))
               self.ene[i*4+1][1].append(float(iset1[1]))
               self.ene[i*4+2][1].append(float(iset1[2]))
               self.ene[i*4+3][1].append(float(iset1[3]))
            else:
               for j in range(len(iset1)):
                   self.ene[i*4+j][1].append(float(iset1[j]))

    def _eatMe4(self,file,frame,lines):
        for i in range(40):
            if i == 0:
               iset1 = FortranLine(lines[i+frame*40+frame+1],\
                                   format_a8i11)
               self.ene[i][1].append(iset1[1])
            else:
               iset1 = FortranLine(lines[i+frame*40+frame+1],\
                                   format_a19a2f20_10)
               self.ene[i][1].append(iset1[2])

    _dict2tup = dict2tup
    _tup2dict = tup2dict

    def getInfo(self):
        return self._tup2dict(self.info)

#
# tests, blood, sweat and tears ...
# to be implemented:
#    AMBER BOX -> PDB
#    extraction of time frames from trajectory
#    AMBER Parm -> MMTK Database
#               -> TINKER key/xyz
#    and much, much more ...
#
def _test():
    print """

 This is AmberIO module (in fact only I from IO is implemented).
 You can read parm-topology, box-restart, trajectory (either vel
 or xyz) and energy files:

    ftop = AmberParmTopFile(filename)
    frst = AmberRestartFile(filename)
    ftrj = AmberTrajectoryFile(filename)
    fene = AmberEneFile(filename)

 The information read is accessible by different atributes and
 methods (see source). For all objects, there is a common method
 called getInfo() which provides (Eeeh..) various pieces of 
 information about data read.

 """

if __name__ == '__main__':
    _test()

