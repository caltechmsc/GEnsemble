#!/usr/bin/env python
#########################################################################################
#                                                                                       #
#  Thermostat class contains methods of controlling temperature in MD simulations       #
#                                                                                       #
#  berensenT: Berensen thermostat via velocity scaling                                  #
#  andersenT: Andersen thermostat via stochastic collision with thermal bath            #
#  noseHoover: Nose-Hoover thermostat via extended system method                        #
#                                                                                       #
#  Created on 02/01/06, last revision on 06/04/06. yi                                   #
#                                                                                       #
#########################################################################################
    
import numpy
from math import sqrt
from unit import *
from utility_pf import * 
from distribution import *

class Thermostat:

    def __init__(self, targetTemp):
        self.targetTemp = targetTemp

        return

    def initialize(self):

        return

    def run(self, energy, degFree, v):

        return

class BerendsenThermostat(Thermostat):
#        
#    Berendsen thermostat:
#    rmd = sqrt(1 + dt/tau * (Tbath/Tcurrent-1)), where rmd is a scaling factor 
#    Vscal/Vcurrent = sqrt(Tscal/Tcurrent). 
#    This scheme reduces to simple velocity scaling method when tau = dt (time step).
#       
    def __init__(self, targetTemp=300., timeStep=0.1, tauTemp = 10., mass=numpy.ones(1, numpy.Float)):
        Thermostat.__init__(self, targetTemp)
        self.timeStep = timeStep 
        self.tauTemp = tauTemp
        self.mass = mass

        return

    def initialize(self):

        return

    def run(self, energy, degFree, v):
        #from math import sqrt
        from utility_pf import Utility
        util = Utility()

        mass = self.mass
        currentTemp = util.calcTemp(degFree, mass, v)
        if currentTemp == 0.:
            currentTemp = 1.e-10
            print "Warning! BerendsenThermostat: Current temperature is zero, reset to a small value!" 

        scale = sqrt(1. + self.timeStep / self.tauTemp * (self.targetTemp / currentTemp - 1.))
        # Simple velocity rescaling. It can be obtained from above expression when timeStep = tauTemp.
        #scale = sqrt(self.targetTemp / currentTemp)

        # Scale velocities according to target temperature.
        v = v * scale

        return v
    
class AndersenThermostat(Thermostat):
#
#    Andersen thermostat via stochastic collision with a heat bath.
#
    def __init__(self, targetTemp=300., timeStep=0.1, niuTemp=0.01, gaussian=Gaussian3, imove=numpy.zeros(1, numpy.Int), mass=numpy.ones(1, numpy.Float)):
        Thermostat.__init__(self, targetTemp)
        self.timeStep = timeStep
        self.niuTemp = niuTemp
        self.gaussian = gaussian
        self.imove = imove
        self.mass = mass

        return

    def initialize(self):

        return

    def run(self, energy, degFree, v):
        # Choose random number generators.
        if self.gaussian is Gaussian1:
            ran = Random1()
            ranum = ran.run()
        elif self.gaussian is Gaussian2:
            ran = Random2()
            ranum = ran.run()
        elif self.gaussian is Gaussian3:
            ran = Random3()
            ranum = ran.run(1)[0]

        if ranum < (self.niuTemp * self.timeStep):  # Rate of collison with bath 
            from utility_pf import Utility
            util = Utility()
            util.setMBvelocity(self.imove, self.mass, v, self.targetTemp, self.gaussian) 
             
        return v

class NoseHooverThermostat(Thermostat):

    def __init__(self, molName='CMDF', targetTemp=300., timeStep=0.1, numNose=4, freqNose=0.1, numSuz=3, mass=numpy.ones(1, numpy.Float)):
        self.molName = molName
        Thermostat.__init__(self, targetTemp)
        self.timeStep = timeStep
        self.numNose = numNose    # Maximum length of Nose-Hoover chain
        self.freqNose = freqNose  # Frequency of NH thermostats
        self.numSuz = numSuz      # The number of multiple time steps in Suzuki iteration
        self.mass = mass

        self.xnh = [0.0] * self.numNose  # Positions of NH thermostat.
        self.vnh = [0.0] * self.numNose  # Velocites of NH thermostat.
        self.qnh = [0.1] * self.numNose  # Masses of NH thermostat.
        self.gnh = [0.0] * self.numNose  # Forces of NH thermostat.
        self.count = 0

        return

    def initialize(self):

        return

    #UNIT = Unit()
    #xnh = [0.0] * self.numNose  # Positions of NH thermostat.
    #vnh = [0.0] * self.numNose  # Velocites of NH thermostat.
    #qnh = [0.1] * self.numNose  # Masses of NH thermostat.
    #gnh = [0.0] * self.numNose  # Forces of NH thermostat.
    #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
    #qnh[0] = UNIT.degFree * massNose
    #for i in range(1,self.numNose):
    #    qnh[i] = massNose
    #count = 0

    #UNIT = Unit()
    #xnh = [0.0] * 10  # Positions of NH thermostat.
    #vnh = [0.0] * 10  # Velocites of NH thermostat.
    #qnh = [0.1] * 10  # Masses of NH thermostat.
    #gnh = [0.0] * 10  # Forces of NH thermostat.
    #massNose = UNIT.KB * self.targetTemp / (self.freqNose ** 2.)
    #qnh[0] = degFree * massNose
    #for i in range(1, self.numNose):
    #    qnh[i] = massNose
    #count = 0

    def run(self, energy, degFree, v):
    #
    # Nose-Hoover chain thermostat
    #
    # This function updates the particle velocities, 
    # thermostat velocities, and thermostates positions.
    # It does the Nose-Hoover part of the integration
    # from t = 0 to t = dt/2. Thus it should be called twice
    # before and after the VV integration.
    #
    # S. Nose, "A unified formulation of the constant temperature     
    # molecular dynamics methods", J. Chem. Phys. 81, 511 (1984)
    #
    # W. G. Hoover, "Canonical dynamics: Equilibrium phase-space distributions",
    # Phys. Rev. A 31, 1695 (1985)
    #
    # G. J. Martyna, M. E. Tuckerman, D. J. Tobias and M. L. Klein,
    # "Explicit Reversible Integrators for Extended Systems Dynamics",
    #  Molecular Physics, 87, 1117-1157 (1996)
    #
        from math import exp
        from utility_pf import Utility

        unit = Unit()
        util = Utility()
        dt = self.timeStep
        nnose = self.numNose
        nnose1 = nnose - 1
        nc = self.numSuz  
        mass = self.mass

        xnh = self.xnh
        vnh = self.vnh
        qnh = self.qnh
        gnh = self.gnh

        massNose = unit.KB * self.targetTemp / (self.freqNose ** 2.)
        qnh[0] = degFree * massNose
        for i in range(1, self.numNose):
            qnh[i] = massNose

        scale = 1.0

        # Compute k*T and Nf*k*T .
        gkt = unit.KB * self.targetTemp
        gnkt = degFree * gkt 

        # Get kinetic energy.
        kinEnergy = util.calcKinEnergy(mass, v)
        kinEnergy2 = 2. * kinEnergy 

        # Set Yoshida-Suzuki weights. 
        nys = 3  # Order of Yoshida-Suzuki iteration 
        #nys = 5
        w = [1.] * nys
        if (nys == 3):
            #w[0] = 1. / (2. - 2. ** (1. / 3.))
            #w[1] = 1. - 2. * w[0]
            #w[2] = w[0] 
            w[0] = 1.351207192
            w[1] = -1.702414384
            w[2] = w[0]
        elif (nys == 5):
            #w[0] = 1. / (4. - 4. ** (1. / 3.))
            #w[1] = w[3] = w[4] = w[0]
            #w[2] = 1. - 4. * w[0]
            w[0] = 0.414490772
            w[1] = w[3] = w[4] = w[0]
            w[2] = -0.657963087
        else:
            nys = 1
            w = [1.] * nys

        wdti2 = [0.] * nys
        wdti4 = [0.] * nys
        wdti8 = [0.] * nys
        for i in range(nys):
            wdti = w[i] * dt / nc
            wdti2[i] = wdti / 2.
            wdti4[i] = wdti / 4.
            wdti8[i] = wdti / 8.

        # Update the forces.
        gnh[0] = (kinEnergy2 - gnkt) / qnh[0]
        # Start the multiple time step procedure
        for i in range(nc):
            for j in range(nys):
                # Update the thermostat velocities
                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j]
                for k in range(1, nnose):
                    aa = exp(-wdti8[j] * vnh[nnose - k])
                    vnh[nnose1 - k] = vnh[nnose1 - k] * aa * aa  \
                            + wdti4[j] * gnh[nnose1 - k] * aa

                # Update the particle velocities
                aa = exp(-wdti2[j] * vnh[0])
                scale = scale * aa

                # Update the forces
                gnh[0] = (scale * scale * kinEnergy2 - gnkt) / qnh[0]

                # Update the thermostat positions
                for m in range(nnose):
                    xnh[m] = xnh[m] + vnh[m] * wdti2[j]

                # Update the thermostat velocities
                for n in range(nnose1):
                    aa = exp(-wdti8[j] * vnh[n + 1])
                    vnh[n] = vnh[n] * aa * aa  \
                             + wdti4[j] * gnh[n] * aa
                    gnh[n + 1] = (qnh[n] * vnh[n] * vnh[n] - gkt)  \
                                / qnh[n + 1]

                vnh[nnose1] = vnh[nnose1] + gnh[nnose1] * wdti4[j] 

        # Update the particle velocities
        v = v * scale

        # Upload the thermostat parameters.
        self.xnh = xnh
        self.vnh = vnh
        self.qnh = qnh
        self.gnh = gnh

        # Compute the conserved quantity for the Nose-Hoover NVT dynamics.
        kepart = util.calcKinEnergy(mass, v)
        kenh = 0.
        for i in range(nnose):
            kenh += qnh[i] * vnh[i] * vnh[i] 

        kenh = 0.5 * kenh  
        pepart = energy 
        penh0 = gnkt * xnh[0] 
        penhi = 0.
        for i in range(1,nnose):
            penhi += xnh[i]

        penhi = gkt * penhi
        penh = penh0 + penhi
        hnh = kepart + kenh + pepart + penh 

        count = self.count 
        count += 1
        if (count % 2 == 0.):
            num = count / 2
            nhFile = open(self.molName+'.nh', 'a')
            for i in range(self.numNose):
                varstr = str(num) + '  ' + str(xnh[i]) + '  ' + str(vnh[i]) + '  ' + str(qnh[i]) + '  ' + str(gnh[i]) +'\n'
                nhFile.write(varstr)
                #nhFile.write("$8i %18.10e %18.10e %18.10e %18.10e %18.10e\n" % (num, hnh, xnh[i], vnh[i], qnh[i], gnh[i])) 
            nhFile.close()    
        self.count = count

        return v

