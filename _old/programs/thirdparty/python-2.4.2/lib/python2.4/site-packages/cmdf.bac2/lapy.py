#!/usr/bin/env python
##############################################################################
#                                                                            #
#  LAPy class: Linear Algebra methods in Python.                             #
#                                                                            #
#  Created on 02/08/06, last revision on 03/27/06. yi                        #
#                                                                            #
##############################################################################
    
import sys

class LAPy:
    
    def vecAdd(self, v1, v2):
    # Sum of two vectors (lists): v1 + v2.
        l1 = len(v1)
        l2 = len(v2)
        if (l1 != l2):
            print "Warning! vecAdd: trancated as two vectors have different lengths." 
            if (l1 < l2): 
                imax = l1
                #v3 = v2[:]  # Make a copy of the longer list.
                v3 = [0.] * l1
            else: 
                imax = l2
                #v3 = v1[:]
                v3 = [0.] * l2
        else:
            imax = l1
            #v3 = v1[:]
            v3 = [0.] * l1
        for i in range(imax):
            v3[i] = v1[i] + v2[i]
    
        return v3
    
    def vecSub(self, v1, v2):
    # Substraction of two vectors (lists): v1 - v2.
        l1 = len(v1)
        l2 = len(v2)
        if (l1 != l2):
            print "Warning! vecSub: trancated as two vectors have different lengths." 
            if (l1 < l2): 
                imax = l1
                #v3 = v2[:]  # Make a copy of the longer list.
                v3 = [0.] * l1
            else: 
                imax = l2
                #v3 = v1[:]
                v3 = [0.] * l2
        else:
            imax = l1
            #v3 = v1[:]
            v3 = [0.] * l1
        for i in range(imax):
            v3[i] = v1[i] - v2[i]
    
        return v3
    
    def vecInnerProduct(self, v1, v2):
    # Inner product of two vectors (lists).    
        l1 = len(v1)
        l2 = len(v2)
        if (l1 != l2):
            print "Warning! vecInnerProduct: trancated as two vectors have different lengths." 
            if (l1 < l2): 
                imax = l1
                #v3 = v2[:]  # Make a copy of the longer list.
                v3 = [0.] * l1
            else: 
                imax = l2
                #v3 = v1[:]
                v3 = [0.] * l2
        else:
            imax = l1
            #v3 = v1[:]
            v3 = [0.] * l1
        for i in range(imax):
            v3[i] = v1[i] * v2[i]
    
        return v3
    
    def vecOuterProduct(self, v1, v2):
    # Outer product of two vectors (lists).    
        m = {}
        l1 = len(v1)
        l2 = len(v2)
        if (l1 != l2):
            print "Warning! vecOuterProduct: trancated as two vectors have different lengths." 
            if (l1 < l2): 
                imax = l1
                v3 = v1[:]
                v4 = v2[:l1]  # Trancate the longer list.
            else: 
                imax = l2
                v3 = v1[:l2]
                v4 = v2[:]
        else:
            imax = l1
            v3 = v1[:]
            v4 = v2[:]
        for i in range(imax):
            for j in range(imax):
                m[(i, j)] = v3[i] * v4[j]
    
        return m 
    
    def vecCross(self, v1, v2):
    # Compute cross product of two vectores: v3 = v1 x v2
        v3 = [0.] * 3
        v3[0] = v1[1] * v2[2] - v1[2] * v2[1]
        v3[1] = v1[2] * v2[0] - v1[0] * v2[2]
        v3[2] = v1[0] * v2[1] - v1[1] * v2[0]
    
        return v3
    
    def tripleVecProduct(self, v1, v2, v3):
    # Compute triple vector product: v4 = v1 x (v2 x v3) = (v1 . v3)v2 - (v1 . v2)v3
        v4 = [0.] * 3    
        c13 = v1[0] * v3[0] + v1[1] * v3[1] + v1[2] * v3[2]
        c12 = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
        v4[0] = c13 * v2[0] - c12 * v3[0]
        v4[1] = c13 * v2[1] - c12 * v3[1]
        v4[2] = c13 * v2[2] - c12 * v3[2]
    
        return v4
    
    def vecNorm(self, v1, v2):
    # Norm of a vector v1 - v2.    
        from math import sqrt
    
        l1 = len(v1)
        l2 = len(v2)
        if (l1 != l2):
            print "Warning! vecNorm: trancated as two vectors have different lengths." 
            if (l1 < l2): 
                imax = l1
                #v3 = v2[:]  # Make a copy of the longer list.
            else: 
                imax = l2
                #v3 = v1[:]
        else:
            imax = l1
            #v3 = v1[:]
    
        norm = 0.
        for i in range(imax):
            norm += (v1[i] - v2[i]) ** 2
    
        norm = sqrt(norm)
    
        return norm
    
    def matAdd(self, m1, m2):
    # Matrix sum 
    # Assume square matrix n * n 
        from math import sqrt
    
        n = int(sqrt(len(m1)))
        m3 = {}     
        for i in range(n):
            for j in range(n):
                m3[(i, j)] = m1[(i, j)] + m2[(i, j)]
    
        return m3
    
    def matSub(self, m1, m2):
    # Matrix substraction 
    # Assume square matrix n * n 
        from math import sqrt
    
        n = int(sqrt(len(m1)))
        m3 = {}     
        for i in range(n):
            for j in range(n):
                m3[(i, j)] = m1[(i, j)] - m2[(i, j)]
    
        return m3
    
    def matMultiNum(self, m1, f):
    # Matrix multiplication
    # Assume square matrix n * n 
        from math import sqrt
    
        n = int(sqrt(len(m1)))
        m2 = {}     
        for i in range(n):
            for j in range(n):
                m2[(i, j)] = m1[(i, j)] * f
    
        return m2
    
    def matMulti(self, m1, m2):
    # Matrix multiplication
    # Assume square matrix n * n 
        from math import sqrt
    
        if (len(m1) != len(m2)):
            print 'Warning! matMulti: two matrices have different dimensions.'
            return
    
        n = int(sqrt(len(m1)))
        m3 = {}     
        for i in range(n):
            for j in range(n):
                m3[(i, j)] = 0.
    
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    m3[(i, j)] += m1[(i, k)] * m2[(k, j)]
    
        return m3
    
    def matDet(self, m1):
    # Compute the determinant of a 2 * 2 or 3 * 3 matrix.
        from math import sqrt

        n = int(sqrt(len(m1)))
        if (n == 2):
            det = m1[(1, 1)] * m1[(2, 2)] - m1[(1, 2)] * m1[(2, 1)]
        elif (n == 3):
            det = m1[(1, 1)] * (m1[(2, 2)] * m1[(3, 3)] - m1[(2, 3)] * m1[(3, 2)])  \
                - m1[(2, 1)] * (m1[(1, 2)] * m1[(3, 3)] - m1[(1, 3)] * m1[(3, 2)])  \
                + m1[(3, 1)] * (m1[(1, 2)] * m1[(2, 3)] - m1[(1, 3)] * m1[(2, 2)])    
        else:
            print 'Warning! matDet: matrix dimention is neither 2 nor 3.'
            return

        return det

    def jacobi(self, a, n, np, d, v, nrot):    
    #
    # Jacobi transformations of a symmetric matrix based on "Numerical Recipes" 
    # (p. 346) consists of a sequence of orthogonal similarity transformations.
    # Computes all eigenvalues and eigenvectors of a real symmetric matrix A,
    # which is of size N by N, stored in a physical NP by NP array. On output,
    # elements of A above the diagonal are destroyed. D returns the eigenvalues 
    # of A in its first N elements. V is a matrix with the same logical and 
    # physical dimensions as A whose columns contain, on output, the normalized
    # eigenvectors of A. NROT returns the number of Jacobi rotations which were 
    # required.
    #
    # Jacobi algorithm is suitable for matries of moderate order (say, N < 10).
    #
        from math import sqrt
    
        #nmax = 100
        #a = {}  # (NP * NP)
        #d = {}  # NP
        #v = {}  # (NP * NP)
        b = {}  # NMAX
        z = {}  # NMAX
    
        n1 = n + 1
        # Initialize to the identity matrix.
        for ip in range(1, n1):
            for iq in range(1, n1):
                v[(ip, iq)] = 0.
            v[(ip, ip)] = 1.
        # Initialize B and D to the diagonal of A.
        for ip in range(1, n1):
            b[ip] = a[(ip, ip)]
            d[ip] = b[ip]
            z[ip] = 0.
        nrot = 0
        # Maximal number of sweeps is set to be 50. 
        for i in range(1, 51):
            # Sum off-diagonal elements.
            sm = 0.
            for ip in range(1, n):
                for iq in range(ip+1, n1):
                    sm = sm + abs(a[ip, iq])
            if (sm == 0.): 
            # Normal return, which relies on quadratic convergence to machine underflow.
                return nrot
            # In the first three sweeps, carry out the pq rotation 
            # only if a(p, q) > tresh (threshold value).
            if (i < 4):
                tresh = 0.2 * sm / (n ** 2)
            else:
                tresh = 0.
            for ip in range(1, n):
                for iq in range(ip+1, n1):
                    g = 100. * abs(a[(ip, iq)])
                    # After four sweeps, skip the rotation if the off-diagonal element is small.
                    if (i > 4 and (abs(d[ip])+g) == abs(d[ip]) and (abs(d[iq])+g) == abs(d[iq])):
                        a[(ip, iq)] = 0.
                    elif (abs(a[(ip, iq)]) > tresh):
                        h = d[iq] - d[ip]
                        if (abs(h)+g == abs(h)):
                            t = a[(ip, iq)] / h
                        else:
                            theta = 0.5 * h / a[(ip, iq)]
                            t = 1. / (abs(theta) + sqrt(1. + theta**2))
                            if (theta < 0.): t = -t
                        c = 1. / sqrt(1. + t ** 2) 
                        s = t * c
                        tau = s / (1. + c)
                        h = t * a[(ip, iq)]
                        z[ip] = z[ip] - h
                        z[iq] = z[iq] + h
                        d[ip] = d[ip] - h
                        d[iq] = d[iq] + h
                        a[(ip, iq)] = 0.
                        for j in range(1, ip):
                            g = a[(j, ip)]
                            h = a[(j, iq)]
                            a[(j, ip)] = g - s * (h + g * tau)
                            a[(j, iq)] = h + s * (g - h * tau)
                        for j in range(ip+1, iq):
                            g = a[(ip, j)] 
                            h = a[(j, iq)]
                            a[(ip, j)] = g - s * (h + g * tau) 
                            a[(j, iq)] = h + s * (g - h * tau)
                        for j in range(iq+1, n1):
                            g = a[(ip, j)]
                            h = a[(iq, j)]
                            a[(ip, j)] = g - s * (h + g * tau)
                            a[(iq, j)] = h + s * (g - h * tau)
                        for j in range(1, n1):
                            g = v[(j, ip)]
                            h = v[(j, iq)]
                            v[(j, ip)] = g - s * (h + g * tau)
                            v[(j, iq)] = h + s * (g - h * tau)
                        nrot = nrot + 1
    
            for ip in range(1, n1):
                b[ip] = b[ip] + z[ip]
                d[ip] = b[ip]
                z[ip] = 0.
    
        print 'Warning! jacobi: too many iterations (> 50).'
    
        return 
    
    def gaussJordan(self, a):
    #
    # Matrix inversion using Gauss-Jordan elimination.
    # n is the dimension of matrix a which is to be inverted.
    # The inverted matrix is stored in a on exit.
    #
        from sys import exit
        from math import sqrt
    
        # Compute matrix dimension.
        n = int(sqrt(len(a)))
    
        # Increase dimension limit if needed. 
        maxinv = 500  
        ipivot = [0.] * maxinv
        indxc = [0.] * maxinv
        indxr = [0.] * maxinv
    
        # Check matrix dimension. 
        if n > maxinv:
            print 'Error! matInvert: Matrix dimension exceed 500.'
            exit(1)
    
        # Start Gauss-Jordan algorithm to do matrix inversion.
        for i in range(n):
            big = 0. 
            for j in range(n):
                if ipivot[j] != 1:
                #if ipivot[j] != 0:
                    for k in range(n):
                        if ipivot[k] == 0:
                            if abs(a[(j, k)]) >= big:
                                big = abs(a[(j, k)])
                                irow = j
                                icol = k
                        elif ipivot[k] > 1:
                            print 'Error! matInvert: Singular matrix not invertable.' 
                            exit(1)
            ipivot[icol] += 1
            if irow != icol:
                for j in range(n):
                    temp = a[(irow, j)]
                    a[(irow, j)] = a[(icol, j)]
                    a[(icol, j)] = temp
            indxr[i] = irow
            indxc[i] = icol
            if a[(icol, icol)] == 0.:
                print 'Error! matInvert: Singular matrix not invertable.'
                exit(1)
            pivot = a[(icol, icol)]
            a[(icol, icol)] = 1.
            for j in range(n):
                a[(icol, j)] = a[(icol, j)] / pivot
            for j in range(n):
                if j != icol:
                    temp = a[(j, icol)]
                    a[(j, icol)] = 0.
                    for k in range(n):
                        a[(j, k)] = a[(j, k)] - a[(icol, k)] * temp
    
        for i in range(n-1, -1, -1):
            if indxr[i] != indxc[i]:
                for k in range(n):
                    temp = a[(k, indxr[i])]
                    a[(k, indxr[i])] = a[(k, indxc[i])]
                    a[(k, indxc[i])] = temp
    
        return

    def gaussJordan2(self, a):
    # This method is the same as above except to use numpy array for a.
    #
    # Matrix inversion using Gauss-Jordan elimination.
    # n is the dimension of matrix a which is to be inverted.
    # The inverted matrix is stored in a on exit.
    #
        from sys import exit
        from math import sqrt
    
        # Compute matrix dimension.
        n = int(sqrt(a.size))
    
        # Increase dimension limit if needed. 
        maxinv = 500  
        ipivot = [0.] * maxinv
        indxc = [0.] * maxinv
        indxr = [0.] * maxinv
    
        # Check matrix dimension. 
        if n > maxinv:
            print 'Error! matInvert: Matrix dimension exceed 500.'
            exit(1)
    
        # Start Gauss-Jordan algorithm to do matrix inversion.
        for i in range(n):
            big = 0. 
            for j in range(n):
                if ipivot[j] != 1:
                #if ipivot[j] != 0:
                    for k in range(n):
                        if ipivot[k] == 0:
                            if abs(a[j, k]) >= big:
                                big = abs(a[j, k])
                                irow = j
                                icol = k
                        elif ipivot[k] > 1:
                            print 'Error! matInvert: Singular matrix not invertable.' 
                            exit(1)
            ipivot[icol] += 1
            if irow != icol:
                for j in range(n):
                    temp = a[irow, j]
                    a[irow, j] = a[icol, j]
                    a[icol, j] = temp
            indxr[i] = irow
            indxc[i] = icol
            if a[icol, icol] == 0.:
                print 'Error! matInvert: Singular matrix not invertable.'
                exit(1)
            pivot = a[icol, icol]
            a[icol, icol] = 1.
            for j in range(n):
                a[icol, j] = a[icol, j] / pivot
            for j in range(n):
                if j != icol:
                    temp = a[j, icol]
                    a[j, icol] = 0.
                    for k in range(n):
                        a[j, k] = a[j, k] - a[icol, k] * temp
    
        for i in range(n-1, -1, -1):
            if indxr[i] != indxc[i]:
                for k in range(n):
                    temp = a[(k, indxr[i])]
                    a[k, indxr[i]] = a[k, indxc[i]]
                    a[k, indxc[i]] = temp
    
        return

