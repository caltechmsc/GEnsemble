#!usr/bin/env python
#########################################################################################################
# simulatedAnnealing.py: minimization drivers via Simulated Annealing MD methods: including             # 
#   different cooling schedules: Linear, Exponent, and Sigmoid. 
#                                                                                                       # 
# Created on 01/19/06, last revision on 06/05/06. yi                                                    #
#                                                                                                       # 
#########################################################################################################

import numpy
#import modMulti
from utility_pf import *
from integrator_pf import * 
from distribution import *
from mdEngine import *
from thermostat_pf import *
from control import *          
from communication import *
import shannoPhua_f 

# Cooling schedules used in simulated annealing minimization.
class CoolSchedule:

    def __init__(self, numSteps):
        self.numSteps = numSteps

        return            

    def initialization(self):

        return

    def run(self, iStep):

        return

class Linear(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)

        return scaleFactor

class Exponent(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        from math import exp

        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = 1. - exp(-5. * scaleFactor)

        return scaleFactor

class Sigmoid(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = self.sigmoid(5., scaleFactor) 

        return scaleFactor

    def sigmoid(self, beta, x):
    #
    # Compute a normalized sigmoidal function on the interval [0, 1];
    # The curves connect (0, 0) and (1, 1) and have a cooperativity 
    # controlled by beta: they approach a straight line as beta approaches
    # zero, and become more nonlinear as beta increase.
    #
        from math import exp

        if beta == 0.:
            sigm = x
        else:
            expmax = 1. / (exp(-beta) + 1.)
            expmin = 1. / (exp(beta) + 1.)
            expterm = 1. / (exp(beta * (2. * x - 1.)) + 1.)
            sigm = (expmax - expterm) / (expmax - expmin)

        return sigm

class SimulatedAnnealing:

    def __init__(self, numSteps, threshold, freqOutput):
        self.numSteps = numSteps
        self.threshold = threshold
        self.freqOutput = freqOutput

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        return


class SimulatedAnnealing_MD(SimulatedAnnealing):
# Simulated annealing minimization via MD.
# Avaliable cooling schedules include Linear, Exponent, and Sigmoid.

    def __init__(self, coolSchedule=Linear, integrator=VelocityVerlet_f, thermostat=BerendsenThermostat,  \
                barostat=BerendsenBarostat, gaussian=Gaussian3, initTemp=1000., finalTemp=0.,  \
                numSteps=1000, equSteps=500, timeStep=0.001, threshold=0.1, freqOutputMD=10,  \
                freqOutputTrj=50, masses=numpy.ones([1], numpy.Float64)):

        SimulatedAnnealing.__init__(self, numSteps, threshold, freqOutputMD)
        self.freqOutputTrj = freqOutputTrj
        self.coolSchedule = coolSchedule
        self.integrator = integrator
        # Note that only BerendsenThermostat is used in SA.
        # Thermostat will be explictly created again in run. 
        self.thermostat = thermostat
        self.barostat = barostat
        self.gaussian = gaussian
        self.timeStep = timeStep
        self.annSteps = numSteps
        self.equSteps = equSteps 
        self.initTemp = initTemp
        self.finalTemp = finalTemp
        self.relaxSteps = 1  
        self.scaleMass = 0. 
        self.masses = masses
        #self.cellDim = cellDim
        #self.coords = coords
        #self.vels = vels
        #self.forces = forces

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        from control import Control
        from utility_pf import Utility
        util = Utility()

        # Setup parameters.
        initTemp = self.initTemp  # Initial temperature  
        finalTemp = self.finalTemp  # Final temperature
        coolSchedule = self.coolSchedule  # Cooling schedule 
        dt = self.timeStep   # Time step in MD
        weakTau = 100. * dt  # Coupling time in Berendsen thermostat
        strongTau = 10. * dt
        equSteps = self.equSteps  # Equilibration MD Steps     
        annSteps = self.annSteps  # Annealing MD steps 
        freqOutputMD = self.freqOutput  # Output interval
        freqOutputTrj = self.freqOutputTrj  # Output interval
        relaxSteps = self.relaxSteps  # Relax steps during annealing.
        threshold = self.threshold  # RMS force convergence criterion
        scaleMass = self.scaleMass  # scale mass by a factor of 10^scaleMass
        scaleMass = 10. ** scaleMass 

        masses = self.masses
        #cellDim = self.cellDim
        #coords = self.coords
        #vels = self.vels
        #forces = self.forces

        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        degFree = molecule.getDegFree()
        masses *= scaleMass 
        #mass = [0.] * numAtoms
        #for i in range(numAtoms):
        #    atom = molecule.getAtomWithNumber(i+1)
        #    mass = atom.getAtomicMass()
        #    mass *= scaleMass
        #    atom.setAtomicMass(mass)

        molName = molecule.getName() 
        SAoutput = open(molName+'.min', 'a')
        MDoutput = open(molName+'.dyn', 'a')
        xyzFile = open(molName+'.trj', 'a')
        rstName = molName+'.rst'

        SAoutput.write("%25s<<< CMDF minimization with Simulated Annealing method >>>\n" % (' '))
        SAoutput.write("N_Iter. ScaleFact           Pot_E                Diff_E               RMS_Coord            RMS_Force \n")  

        #MDoutput.write("%16s <<< CMDF Simulated Annealing via MD integration >>>\n" % (' '))
        MDoutput.write("%12s<< Equilibrium phase at initial temperature %16.7f K >>\n" % (' ', initTemp))
        MDoutput.flush()

        # Equilibration phase at initial temperature. 
        # One can choose different starting configurations via setting different equSteps.
        equilibriumThermostat = BerendsenThermostat(initTemp, dt, weakTau, masses)
        equilibriumMD = MDEngine(self.integrator, equilibriumThermostat, self.barostat,  \
                            self.gaussian, equSteps, freqOutputMD, freqOutputTrj, initTemp) 

        equilibriumMD.run(system, forceEngine)

        # Annealing phase according to the cooling schedule.
        MDoutput.write("%12s<< Annealing phase toward final temperature %16.7f K >>\n" % (' ', finalTemp))
        MDoutput.flush()
        # Note that the following instance name has no meaning. I just borrow its output method.
        #equilibriumMD.outputMD(system, -1, MDoutput)
        #equilibriumMD.outputMD(system, 0, MDoutput)

        cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges,  \
            masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)

        masses *= scaleMass 
        equilibriumMD.outputMD(-1, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)
        equilibriumMD.outputMD(0, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)
        util.outputTrj(xyzFile, elements, coords, vels, forces, 0)

        #for i in range(1, numAtoms1):
        #    atom = molecule.getAtomWithNumber(i)
        #    atom.setOldPosition(0., 0., 0.)
        #molecule.setOldPotentialEnergy(0.)         
        oldCoords = coords.copy() 
        oldEnergy = energy
        convergence = False
        # Create cooling schedule.
        coolSchedule = self.coolSchedule(annSteps)
        self.integrator.initialize(system)  # Initialize integrator.
        for iStep in range(1, annSteps+1):
            #self.integrator.run(system, forceEngine)  # MD integration.
            coords, vels, energy, forces = self.integrator.run(forceEngine, coords, vels, forces)  # MD integration. 

            if (iStep-1) % relaxSteps == 0: 
                # Compute scaling factor according to cooling schedule.
                scaleFactor = coolSchedule.run(iStep)
                scaleFactor1 = 1. - scaleFactor
                targetTemp = scaleFactor1 * initTemp + scaleFactor * finalTemp
                tauTemp = scaleFactor1 * weakTau + scaleFactor * strongTau
                # Create new thermostat.
                annealThermostat = BerendsenThermostat(targetTemp, dt, tauTemp, masses)
            vels = annealThermostat.run(energy, degFree, vels)  # Thermostat

            if self.barostat:  # Barostat
                cellDim, coords = self.barostat.run(cellDim, coords, vels, forces, self.integrator)

            #RMScoord = util.calcRMScoord(molecule)
            RMScoord = shannoPhua_f.rmscoords(coords, oldCoords)
            #RMSforce = util.calcRMSforce(molecule)
            RMSforce = shannoPhua_f.rmsforces(forces) 
            diffEnergy = energy - oldEnergy

            if iStep % freqOutputMD == 0: 
                self.outputSA(SAoutput, iStep, scaleFactor, energy, diffEnergy, RMScoord, RMSforce)
                equilibriumMD.outputMD(iStep, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)

            if iStep % freqOutputTrj == 0: 
                util.outputTrj(xyzFile, elements, coords, vels, forces, iStep)
                equilibriumMD.writeMDrestart(rstName, molName, cellDim, coords, vels, forces, oldForces)

            if (RMSforce <= threshold):
                convergence = True
                if iStep % freqOutputMD != 0: 
                    self.outputSA(SAoutput, iStep, scaleFactor, energy, diffEnergy, RMScoord, RMSforce)
                SAoutput.write("%17s %20.10e %10s\n" % ("Final energy = ", energy / Control.printEnergyUnit, Control.printEnergyFlag))
                SAoutput.write("%17s %20.10e\n" % ("Final RMS force= ", RMSforce / Control.printEnergyUnit))
                SAoutput.write("%30s \n" % ("<< Minimization converged >> "))  
                break
            else:
                #for i in range(1, numAtoms1):
                #    atom = molecule.getAtomWithNumber(i)
                #    atom.setOldPosition(atom.getX(), atom.getY(), atom.getZ())
                #molecule.setOldPotentialEnergy(potEnergy)         
                oldCoords = coords.copy() 
                oldEnergy = energy
    
        arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)  # Update system information.

        if not convergence:
            SAoutput.write("%17s %20.10e %10s\n" % ("Final energy = ", energy / Control.printEnergyUnit, Control.printEnergyFlag))
            SAoutput.write("%17s %20.10e\n" % ("Final RMS force= ", RMSforce / Control.printEnergyUnit))
            SAoutput.write("%58s \n" % ("<< Maximal steps reached, minimization NOT converged >>")) 

        SAoutput.close()
        MDoutput.close()
        xyzFile.close()
        
        return 

    def outputSA(self, file, num, scaleFactor, energy, diffEnergy, RMScoord, RMSforce):
        from control import Control
        energy /= Control.printEnergyUnit
        diffEnergy /= Control.printEnergyUnit
        RMSforce /= Control.printEnergyUnit
        file.write("%6i  %5f  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                    (num, scaleFactor, energy, diffEnergy, RMScoord, RMSforce))
        return

