#####################################################################################
#                                                                                   #
#  Distribution class constitutes various distribution generators.                  #
#                                                                                   #
#  Random  : Random distribution(number) generators.                                #
#  Gaussian: Gaussian distribution generators.                                      #
#                                                                                   #
#  Created on 03/08/06, last revision on 03/27/06. yi                               #
#                                                                                   #
#####################################################################################

class Distribution:

    def __init__(self):

        return

    def initialize(self):

        return

    def run(self):

        return

    #
    # Random number generators and Gaussian distribution generators.
    #
    # See Park & Miller, Comm. ACM 31:1192, 1988.
    # also, "Molecular Modeling and Simulation: An interdisciplinary guide"
    # Tamar Schlick, Springer 2002, p. 364. ran3 and gauss3 are based on
    # ranuv and rannv1 subroutines.
    #
    # ran3 is a corrected implementation of SURAND MLCG (multiplicative linear 
    # congruential generator), which based on the recursion relation:
    #  x(i+1) = (a*x(i) + c) mod M,   (i = 0, 1,...), it is called MLCG when c=0.
    #
    # Assume M = a * q  
    # a x mod M = a x mod (a q) = a(x mod q)
    # a = 16807, M = 2^31-1, 
    # M = a * q + r, where q = 127773, r = 2836.
    #
    # The period of this random number vector is 2,147,483,646.
    #
    # Note: Despite the good performance, LCG is known to have sequential correlation
    # on successive calls. So it is not recommended for direct use in cases where the 
    # high quality of random numbers is important. It is better to use separate calls
    # for every random number instead of a vector of many pieces. Additional shuffling
    # procedure based on LCG can break up sequential correlations. ran1 and ran2 adapted 
    # from "Numerical Recipes" (p.196) are much better because they have infinite period
    # and no sensible sequential correlations. ran1 is superior than ran2 but slower. ran2
    # returns one of only 714025 possible values, equally spaced in the interval [0,1).  
    # ran2 is faster and adequate if the discreteness of random numbers is not important.
    # 
    # For Gaussian distribution, gauss1 and gauss2 are both based on GASDEV (Box-Muller method)
    # in Numerical Recipes (p.203). The only difference is gauss1 uses ran1 whereas gauss2 
    # uses ran2. gauss3 uses ran3 and Odeh-Evans method.
    #
    # The reasons to have more than one random number generators and gaussian distributions
    # are two folds. One can choose appropriate functions between accuracy and efficiency.
    # Also, it is always good to compare the results from different generators for the same 
    # system to check if the quality of random numbers leads to unphysical results.  
    #
    # ranor generates random vector on a unit sphere.
    # See "Understanding Molecular Simulation: From Alogorithms to Applications"
    # by Daan Frenkel and Berend Smit
    #
    
class Random1(Distribution):

    def __init__(self):

        return

    def initialize(self):

        return

    IDUM1 = -1
    IX1 = 1; IX2 = 1; IX3 = 1
    IR1 = [0.5] * 98

    def run(self):  
    # Returns a uniform random deviate between 0. and 1. Set IDUM1 to any negative value
    # to initialize or reinitialize the sequence.
    # This function must be initialized once before first call.
    # The following 3 lines should be placed before first call outside this function
    #    IDUM1 = -1
    #    IX1 = 1; IX2 = 1; IX3 = 1
    #    IR1 = [0.5] * 98
    
        M1 = 259200; IA1 = 7141; IC1 = 54773; RM1 = 1./M1
        M2 = 134456; IA2 = 8121; IC2 = 28411; RM2 = 1./M2
        M3 = 243000; IA3 = 4561; IC3 = 51349
        if (Random1.IDUM1 < 0):  # Initialize on first call
            Random1.IX1 = (IC1 - Random1.IDUM1) % M1
            Random1.IX1 = (IA1 * Random1.IX1 + IC1) % M1
            Random1.IX2 = Random1.IX1 % M2
            Random1.IX1 = (IA1 * Random1.IX1 + IC1) % M1
            Random1.IX3 = Random1.IX1 % M3
            for j in range(1, 98):
                Random1.IX1 = (IA1 * Random1.IX1 + IC1) % M1
                Random1.IX2 = (IA2 * Random1.IX2 + IC2) % M2
                Random1.IR1[j] = (Random1.IX1 + Random1.IX2 * RM2) * RM1 
            Random1.IDUM1 = 1
        Random1.IX1 = (IA1 * Random1.IX1 + IC1) % M1
        Random1.IX2 = (IA2 * Random1.IX2 + IC2) % M2
        Random1.IX3 = (IA3 * Random1.IX3 + IC3) % M3
        j = 1 + (97 * Random1.IX3) / M3
        if (j > 97 or j < 1): 
            print "ran1 failed: list index out of range!"
            return
        ranum = Random1.IR1[j]
        Random1.IR1[j] = (Random1.IX1 + Random1.IX2 * RM2) * RM1
    
        return ranum
    
class Gaussian1(Distribution):

    def __init__(self, sigma, miu):
        self.sigma = sigma
        self.miu = miu

        return

    def initialize(self):

        return

    GSET = 0.5    # Stored Gaussian
    ISET = False  # Flag for choosing stored Gaussian

    def run(self):
    # Returns a Gaussian distribution with mean miu and standard deviation sigma,
    # using ran1 as the source of uniform deviates.
    #
    # The following lines should be placed outside before first call to this function.
    # Initialization of Gaussian1 and Random1.
    #        sigma = 1.0  # standard deviation
    #        miu = 0.  # mean
    #        ISET = False
    #        GSET = 0.5
    #        IDUM1 = -1  
    #        IX1 = 1; IX2 = 1; IX3 = 1
    #        IR1 = [0.5] * 98
    
        from math import sqrt, log

        RAN = Random1()
        sigma = self.sigma
        miu = self.miu

        if (Gaussian1.ISET == False):
            norm = 1
            while (norm >= 1):
                ranum1 = RAN.run()   
                ranum2 = RAN.run()   
                V1 = 2. * ranum1 - 1.
                V2 = 2. * ranum2 - 1.
                norm = V1 * V1 + V2 * V2
            FAC = sqrt(-2. * log(norm) / norm)
            Gaussian1.GSET = sigma * V1 * FAC + miu    # Gaussian distribution with standard 
            GASDEV = sigma * V2 * FAC + miu       # deviation sigma and mean miu.
            Gaussian1.ISET = True
        else:
            GASDEV = Gaussian1.GSET  # Use stored Gaussian
            Gaussian1.ISET = False
    
        return GASDEV
    
class Random2(Distribution):

    def __init__(self):

        return

    def initialize(self):

        return

    IDUM2 = -1
    IY = 1
    IR2 = [0.5] * 98

    def run(self):
    # Returns a uniform random deviate between 0. and 1. Set IDUM2 to any negative value
    # to initialize or reinitialize the sequence.
    # This function must be initialized once before first call.
    # The following 3 lines should be placed before first call outside this function
    #    IDUM2 = -1
    #    IY = 1
    #    IR2 = [0.5] * 98    
    
        M = 714025; IA = 1366; IC = 150889; RM = 1./M
        if (Random2.IDUM2 < 0):
            Random2.IDUM2 = (IC - Random2.IDUM2) % M
            for j in range(1, 98):
                Random2.IDUM2 = (IA * Random2.IDUM2 + IC) % M
                Random2.IR2[j] = Random2.IDUM2
            Random2.IDUM2 = (IA * Random2.IDUM2 + IC) % M
            Random2.IY = Random2.IDUM2
        j = 1 + (97 * Random2.IY) / M
        if (j > 97 or j < 1):
            print "ran2 failed: list index out of range!"
            return
        Random2.IY = Random2.IR2[j] 
        ranum = Random2.IY * RM
        Random2.IDUM2 = (IA * Random2.IDUM2 + IC) % M 
        Random2.IR2[j] = Random2.IDUM2
    
        return ranum
    
class Gaussian2(Distribution):

    def __init__(self, sigma, miu):
        self.sigma = sigma
        self.miu = miu

        return

    def initialize(self):

        return

    GSET = 0.5    # Stored Gaussian
    ISET = False  # Flag for choosing stored Gaussian

    def run(self):
    # Returns a Gaussian distribution with mean miu and standard deviation sigma,
    # using ran2 as the source of uniform deviates.
    #
    # The following lines should be placed outside before first call to this function.
    # Initialization of Gaussian2 and Random2. 
    #        sigma = 1.0  # standard deviation
    #        miu = 0.  # mean
    #        ISET = False
    #        GSET = 0.5
    #        IDUM2 = -1  
    #        IY = 1
    #        IR2 = [0.5] * 98
    
        from math import sqrt, log

        RAN = Random2()
        sigma = self.sigma
        miu = self.miu

        if (Gaussian2.ISET == False):
            norm = 1
            while (norm >= 1):
                ranum1 = RAN.run()   
                ranum2 = RAN.run()   
                V1 = 2. * ranum1 - 1.
                V2 = 2. * ranum2 - 1.
                norm = V1 * V1 + V2 * V2
            FAC = sqrt(-2. * log(norm) / norm)
            Gaussian2.GSET = sigma * V1 * FAC + miu    # Gaussian distribution with standard 
            GASDEV = sigma * V2 * FAC + miu  # deviation sigma and mean miu.
            Gaussian2.ISET = True
        else:
            GASDEV = Gaussian2.GSET
            Gaussian2.ISET = False
    
        return GASDEV
    
class Random3(Distribution):

    def __init__(self):

        return

    def initialize(self):

        return

    seed = 1

    def run(self, n):
    # Gererate a vector of n pseudorandom uniform variates [0, 1]

        vec = [0.] * n
        a = 16807; m = 2147483647  
        q = 127773; r = 2836; rm = 1.0 / m
        if Random3.seed < 0: 
            Random3.seed = 1
            print "seed should not be negative in ran3, reset to 1."
        if (n < 1): 
            n = 1
            print "n should not be less than 1 in ran3, reset to 1."
        for i in range(n):
            Random3.seed = a * (Random3.seed % q) - r * (Random3.seed / q)
            if (Random3.seed <= 0): Random3.seed += m
            vec[i] = Random3.seed * rm
    
            #print 'Random vec[%3i]= %15.6f' % (i, vec[i])
    
        return vec
    
class Gaussian3(Distribution):
# Returns a Gaussian distribution with mean miu and standard deviation sigma,

    def __init__(self, sigma, miu):
        self.sigma = sigma
        self.miu = miu

        return

    def initialize(self):

        return

    def run(self, n):
    #
    # A vector of n pseudorandom numbers is generated from a
    # standard normal distribution (mean zero, variance one),
    # based on Odeh and Evans, App. Stat. 23: 96 (1974).
    # For a nonzero mean MU and/or non unity variance,
    # set vec(i) = miu + sigma(i)*vec(i).
    # Here I changed variance (sigma^2) to sigma for consistency.
    #
        from math import sqrt, log
    
        sigma = self.sigma
        miu = self.miu

        p0 = -0.322232431088e0; p1 = -1.e0
        p2 = -0.342242088547e0; p3 = -0.204231210245e-1
        p4 = -0.453642210148e-4
        q0 = 0.99348462606e-1; q1 = 0.588581570495e0
        q2 = 0.531103462366e0; q3 = 0.10353775285e0
        q4 = 0.38560700634e-2
    
        if (n < 1): 
            print "n should not be less than 1 in gauss3, reset to 1!"
    
    # Generate n random numbers.
        RAN = Random3()
        vec = RAN.run(n)
    
        for i in range(n):
            temp = vec[i]
            if (temp > 0.5e0): vec[i] = 1.e0 - vec[i]
            vec[i] = sqrt(log(1.e0/vec[i]**2))
            vec[i] += (
                       ((((vec[i] * p4 + p3) * vec[i] + p2) *
                       vec[i] + p1) * vec[i] + p0) /
                       ((((vec[i] * q4 + q3) * vec[i] + q2) *
                       vec[i] + q1) * vec[i] + q0)
                       ) 
            if (temp < 0.5e0): vec[i] = -vec[i]
    
        for i in range(n):
            #vec[i] = sqrt(var[i]) * vec[i] + mean
            vec[i] = sigma[i] * vec[i] + miu  # standard deviation sigma and mean miu.
    
            #print 'Normal vec[%3i]= %15.6f' % (i, vec[i])
    
        return vec
    
