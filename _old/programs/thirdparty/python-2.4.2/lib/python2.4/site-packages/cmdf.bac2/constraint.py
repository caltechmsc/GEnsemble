####################################################################################
#                                                                                  #
#  Constraint class consists of methods used for constrained dynamics.             #
#                                                                                  #
#  rattle            : RATTLE algorithm for distance constraint                    #
#                                                                                  #
#  Created on 02/27/06, last revision on 03/27/06. yi                              #
#                                                                                  #
####################################################################################

from control import *

class Constraint:

    def __init__(self):

        return

    def initialize(self, molecule):

        return

    def run(self, molecule, forceEngine):

        return

class Rattle(Constraint):

    def __init__(self, timeStep, numRattle, constraintRattle):
        Constraint.__init__(self)
        self.timeStep = timeStep
        self.numRattle = numRattle
        self.constraintRattle  = constraintRattle

        return

    def initialize(self, molecule):

        return

    def run1(self, molecule, xold, yold, zold):
    #
    # run1 implements the first portion of the rattle algorithm
    # by correcting atomic positions and half-step velocities to
    # maintain interatomic distance constraints.
    #
    # literature reference:
    #
    # H. C. Andersen, "RATTLE: A Velocity Version of the SHAKE
    # Algorithm for Molecular Dynamics Calculations", Journal of
    # Computational Physics, 52, 24-34 (1983)
    #   

        numAtoms = molecule.numAtoms()
        dt = self.timeStep
        nrat = self.numRattle
        rat  = self.constraintRattle

        mass = [0.] * numAtoms
        x = [0.] * numAtoms; y = [0.] * numAtoms; z = [0.] * numAtoms
        vx = [0.] * numAtoms; vy = [0.] * numAtoms; vz = [0.] * numAtoms
        for i in range(nrat):
            ia = rat[i][0]
            ib = rat[i][1]
            atom1 = molecule.getAtomWithNumber(ia)    
            atom2 = molecule.getAtomWithNumber(ib)    

            mass[ia-1] = atom1.getAtomicMass()
            mass[ib-1] = atom2.getAtomicMass()

            x[ia-1] = atom1.getX() 
            y[ia-1] = atom1.getY() 
            z[ia-1] = atom1.getZ() 

            x[ib-1] = atom2.getX() 
            y[ib-1] = atom2.getY() 
            z[ib-1] = atom2.getZ() 

            vx[ia-1] = atom1.getVelocityX()
            vy[ia-1] = atom1.getVelocityY()
            vz[ia-1] = atom1.getVelocityZ()

            vx[ib-1] = atom2.getVelocityX()
            vy[ib-1] = atom2.getVelocityY()
            vz[ib-1] = atom2.getVelocityZ()

        moved = [0.] * numAtoms; update = [0.] * numAtoms
        for i in range(numAtoms):
            moved[i] = True
            update[i] = False

        # Set maximal iteration number, termination and tolerence
        maxiter = 100
        sor = 1.25
        eps = 1.e-6
        niter = 0
        done = False

        # Start RATTLE iterations for distances and half-step velocities
        while ( not done and niter < maxiter):
            niter += 1
            done = True
            for i in range(nrat):
                ia = rat[i][0]
                ib = rat[i][1]
                if (moved[ia] or moved[ib]):
                    xr = x[ib-1] - x[ia-1]
                    yr = y[ib-1] - y[ia-1]
                    zr = z[ib-1] - z[ia-1]
                    dist2 = xr ** 2 + yr ** 2 + zr ** 2
                    delta = rat[i][2] ** 2 - dist2
                    if (abs(delta) > eps):
                        done = False
                        update[ia] = True
                        update[ib] = True
                        xo = xold[ib-1] - xold[ia-1]
                        yo = yold[ib-1] - yold[ia-1]
                        zo = zold[ib-1] - zold[ia-1]
                        dot = xr * xo + yr * yo + zr * zo
                        rma = 1. / mass[ia-1]
                        rmb = 1. / mass[ib-1]
                        term = sor * delta / (2. * (rma + rmb) * dot)
                        xterm = xo * term
                        yterm = yo * term
                        zterm = zo * term
                        x[ia-1] = x[ia-1] - xterm * rma
                        y[ia-1] = y[ia-1] - yterm * rma
                        z[ia-1] = z[ia-1] - zterm * rma
                        x[ib-1] = x[ib-1] + xterm * rmb
                        y[ib-1] = y[ib-1] + yterm * rmb
                        z[ib-1] = z[ib-1] + zterm * rmb
                        rma = rma / dt
                        rmb = rmb / dt
                        vx[ia-1] = vx[ia-1] - xterm * rma
                        vy[ia-1] = vy[ia-1] - yterm * rma
                        vz[ia-1] = vz[ia-1] - zterm * rma
                        vx[ib-1] = vx[ib-1] + xterm * rmb
                        vy[ib-1] = vy[ib-1] + yterm * rmb
                        vz[ib-1] = vz[ib-1] + zterm * rmb

            for i in range(numAtoms):
                moved[i] = update[i]
                update[i] = False

        # Upload positions and velocities.
        for i in range(nrat):
            ia = rat[i][0]
            ib = rat[i][1]
            atom1 = molecule.getAtomWithNumber(ia)    
            atom2 = molecule.getAtomWithNumber(ib)    

            atom1.setPosition(x[ia-1], y[ia-1], z[ia-1])
            atom2.setPosition(x[ib-1], y[ib-1], z[ib-1])

            atom1.setVelocity(vx[ia-1], vy[ia-1], vz[ia-1])
            atom2.setVelocity(vx[ib-1], vy[ib-1], vz[ib-1])

        if (niter >= maxiter):
            print 'Warning! Rattle.run1: RATTLE iteration not converged.'
            return

        return niter

    def run2(self, molecule):
    #
    # run2 implements the second portion of the rattle algorithm
    # by correcting the full-step velocities in order to maintain
    # interatomic distance constraints.
    #   
        numAtoms = molecule.numAtoms()
        dt = self.timeStep
        nrat = self.numRattle
        rat  = self.constraintRattle

        mass = [0.] * numAtoms
        x = [0.] * numAtoms; y = [0.] * numAtoms; z = [0.] * numAtoms
        vx = [0.] * numAtoms; vy = [0.] * numAtoms; vz = [0.] * numAtoms
        for i in range(nrat):
            ia = rat[i][0]
            ib = rat[i][1]
            atom1 = molecule.getAtomWithNumber(ia)    
            atom2 = molecule.getAtomWithNumber(ib)    

            mass[ia-1] = atom1.getAtomicMass()
            mass[ib-1] = atom2.getAtomicMass()

            x[ia-1] = atom1.getX() 
            y[ia-1] = atom1.getY() 
            z[ia-1] = atom1.getZ() 

            x[ib-1] = atom2.getX() 
            y[ib-1] = atom2.getY() 
            z[ib-1] = atom2.getZ() 

            vx[ia-1] = atom1.getVelocityX()
            vy[ia-1] = atom1.getVelocityY()
            vz[ia-1] = atom1.getVelocityZ()

            vx[ib-1] = atom2.getVelocityX()
            vy[ib-1] = atom2.getVelocityY()
            vz[ib-1] = atom2.getVelocityZ()

        moved = [0.] * numAtoms; update = [0.] * numAtoms
        for i in range(numAtoms):
            moved[i] = True
            update[i] = False

        # Set maximal iteration number, termination and tolerence
        maxiter = 100
        sor = 1.25
        eps = 1.e-6 / dt
        niter = 0
        done = False

        # Start RATTLE iterations for full-step velocities
        while ( not done and niter < maxiter):
            niter += 1
            done = True
            for i in range(nrat):
                ia = rat[i][0]
                ib = rat[i][1]
                if (moved[ia] or moved[ib]):
                    xr = x[ib-1] - x[ia-1]
                    yr = y[ib-1] - y[ia-1]
                    zr = z[ib-1] - z[ia-1]
                    xv = vx[ib-1] - vx[ia-1]
                    yv = vy[ib-1] - vy[ia-1]
                    zv = vz[ib-1] - vz[ia-1]
                    dot = xr * xv + yr * yv + zr * zv
                    rma = 1. / mass[ia-1]
                    rmb = 1. / mass[ib-1]
                    term = -dot / ((rma + rmb) * rat[i][2] ** 2)
                    if (abs(term) > eps):
                        done = False
                        update[ia] = True
                        update[ib] = True
                        term = sor * term
                        xterm = xr * term
                        yterm = yr * term
                        zterm = zr * term
                        vx[ia-1] = vx[ia-1] - xterm * rma
                        vy[ia-1] = vy[ia-1] - yterm * rma
                        vz[ia-1] = vz[ia-1] - zterm * rma
                        vx[ib-1] = vx[ib-1] + xterm * rmb
                        vy[ib-1] = vy[ib-1] + yterm * rmb
                        vz[ib-1] = vz[ib-1] + zterm * rmb
        
            for i in range(numAtoms):
                moved[i] = update[i]
                update[i] = False

        # Upload velocities.
        for i in range(nrat):
            ia = rat[i][0]
            ib = rat[i][1]
            atom1 = molecule.getAtomWithNumber(ia)    
            atom2 = molecule.getAtomWithNumber(ib)    

            atom1.setVelocity(vx[ia-1], vy[ia-1], vz[ia-1])
            atom2.setVelocity(vx[ib-1], vy[ib-1], vz[ib-1])

        if (niter >= maxiter):
            print 'Warning! Rattle.run2: RATTLE iteration not converged.'
            return

        return niter

