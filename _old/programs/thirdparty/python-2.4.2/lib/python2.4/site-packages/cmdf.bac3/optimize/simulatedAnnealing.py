#!usr/bin/env python
#########################################################################################################
# simulatedAnnealing.py: minimization drivers via Simulated Annealing MD methods: including             # 
#   different cooling schedules: Linear, Exponent, and Sigmoid. 
#                                                                                                       # 
# Created on 01/19/06, last revision on 09/05/06. yi                                                    #
#                                                                                                       # 
#########################################################################################################

from math import exp
import numpy
from cmdf.utility.utility_pf import Utility
from cmdf.dynamics.integrator_pf import VelocityVerlet_f                                                
from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3
#from cmdf.dynamics.mdEngine import MDEngine
from cmdf.dynamics.thermostat_pf import BerendsenThermostat
from cmdf.dynamics.barostat_pf import BerendsenBarostat
#from cmdf.utility.control import Control    
from cmdf.utility.communication import systemToArrays, arraysToSystem_md, arraysToSystem_min
from cmdf.optimize.shannoPhua_f import rmscoords, rmsforces 
from cmdf.reaxFF.reaxForceEngine import ReaxForceEngine
from cmdf.reaxFF import reax

# Cooling schedules used in simulated annealing minimization.
class CoolSchedule:

    def __init__(self, numSteps):
        self.numSteps = numSteps

        return            

    def initialization(self):

        return

    def run(self, iStep):

        return

class Linear(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)

        return scaleFactor

class Exponent(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):

        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = 1. - exp(-5. * scaleFactor)

        return scaleFactor

class Sigmoid(CoolSchedule):

    def __init__(self, numSteps):
        CoolSchedule.__init__(self, numSteps)

        return

    def initialization(self):

        return

    def run(self, iStep):
        scaleFactor = float(iStep) / float(self.numSteps)
        scaleFactor = self.sigmoid(5., scaleFactor) 

        return scaleFactor

    def sigmoid(self, beta, x):
    #
    # Compute a normalized sigmoidal function on the interval [0, 1];
    # The curves connect (0, 0) and (1, 1) and have a cooperativity 
    # controlled by beta: they approach a straight line as beta approaches
    # zero, and become more nonlinear as beta increase.
    #
        #from math import exp

        if beta == 0.:
            sigm = x
        else:
            expmax = 1. / (exp(-beta) + 1.)
            expmin = 1. / (exp(beta) + 1.)
            expterm = 1. / (exp(beta * (2. * x - 1.)) + 1.)
            sigm = (expmax - expterm) / (expmax - expmin)

        return sigm

class SimulatedAnnealing:

    def __init__(self, numSteps, threshold, freqOutput):
        self.numSteps = numSteps
        self.threshold = threshold
        self.freqOutput = freqOutput

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):

        return


class SimulatedAnnealing_MD(SimulatedAnnealing):
# Simulated annealing minimization via MD.
# Avaliable cooling schedules include Linear, Exponent, and Sigmoid.
# SA can also be used to heat system when initTemp < finalTemp.

    def __init__(self, coolSchedule=Linear, integrator=VelocityVerlet_f, thermostat=BerendsenThermostat,  \
                barostat=BerendsenBarostat, gaussian=Gaussian3, initTemps=[1000.], finalTemps=[0.], thermoList=None, \
                numSteps=1000, equSteps=500, timeStep=0.001, threshold=0.1, freqOutputMD=10,  \
                freqOutputTrj=50, freqCheckThermoRegion=1, numRegions=0, masses=numpy.ones([1], numpy.Float64)):

        SimulatedAnnealing.__init__(self, numSteps, threshold, freqOutputMD)
        self.freqOutputTrj = freqOutputTrj
        self.coolSchedule = coolSchedule
        self.integrator = integrator
        # Note that only BerendsenThermostat is used in SA.
        # Thermostat will be explictly created again in run. 
        self.thermostat = thermostat  # Not used
        self.barostat = barostat
        self.gaussian = gaussian
        self.timeStep = timeStep
        self.annSteps = numSteps
        self.equSteps = equSteps 
        self.initTemps = initTemps
        self.finalTemps = finalTemps
        self.thermoList = thermoList
        self.numRegions = numRegions
        self.freqCheckThermoRegion = freqCheckThermoRegion
        self.relaxSteps = 1  
        self.scaleMass = 0. 
        self.masses = masses
        #self.cellDim = cellDim
        #self.coords = coords
        #self.vels = vels
        #self.forces = forces

        return

    def initialize(self):

        return

    def run(self, system, forceEngine):
        from cmdf.utility.control import Control    
        from cmdf.dynamics.mdEngine import MDEngine

        #from control import Control
        #from utility_pf import Utility
        util = Utility()

        # Setup parameters.
        numRegions = self.numRegions
        initTemps = self.initTemps  # Initial temperature  
        finalTemps = self.finalTemps  # Final temperature
        thermoList = self.thermoList
        freqCheckThermoRegion = self.freqCheckThermoRegion
        coolSchedule = self.coolSchedule  # Cooling schedule 
        dt = self.timeStep   # Time step in MD
        weakTau = 100. * dt  # Coupling time in Berendsen thermostat
        strongTau = 10. * dt
        equSteps = self.equSteps  # Equilibration MD Steps     
        annSteps = self.annSteps  # Annealing MD steps 
        freqOutputMD = self.freqOutput  # Output interval
        freqOutputTrj = self.freqOutputTrj  # Output interval
        relaxSteps = self.relaxSteps  # Relax steps during annealing.
        threshold = self.threshold  # RMS force convergence criterion
        scaleMass = self.scaleMass  # scale mass by a factor of 10^scaleMass
        scaleMass = 10. ** scaleMass 

        masses = self.masses
        #cellDim = self.cellDim
        #coords = self.coords
        #vels = self.vels
        #forces = self.forces

        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        degFree = molecule.getDegFree()
        masses *= scaleMass 
        #mass = [0.] * numAtoms
        #for i in range(numAtoms):
        #    atom = molecule.getAtomWithNumber(i+1)
        #    mass = atom.getAtomicMass()
        #    mass *= scaleMass
        #    atom.setAtomicMass(mass)

        molName = molecule.getName() 
        SAoutput = open(molName+'.min', 'a')
        MDoutput = open(molName+'.dyn', 'a')
        xyzFile = open(molName+'.trj', 'a')
        tRegionFile = open(molName+'.treg', 'a')
        rstName = molName+'.rst'

        SAoutput.write("%25s<<< CMDF minimization/heating with Simulated Annealing method >>>\n" % (' '))
        SAoutput.write("N_Iter. ScaleFact           Pot_E                Diff_E               RMS_Coord            RMS_Force \n")  

        #MDoutput.write("%16s <<< CMDF Simulated Annealing via MD integration >>>\n" % (' '))
        MDoutput.write("%12s<< Equilibrium phase at initial temperature %s K >>\n" % (' ', str(initTemps)))
        MDoutput.flush()

        # Equilibration phase at initial temperature. 
        # One can choose different starting configurations via setting different equSteps.
        equilibriumThermostats = []
        if numRegions > 0:
            for iRegion in range(numRegions):
                equilibriumThermostat = BerendsenThermostat(initTemps[iRegion], dt, weakTau)
                equilibriumThermostats.append(equilibriumThermostat) 
        elif numRegions == 0:
            equilibriumThermostat = BerendsenThermostat(initTemps[0], dt, weakTau)
            equilibriumThermostats.append(equilibriumThermostat) 

        equilibriumMD = MDEngine(self.integrator, equilibriumThermostats, thermoList, self.barostat,  \
                            self.gaussian, equSteps, freqOutputMD, freqOutputTrj, freqCheckThermoRegion, initTemps) 

        equilibriumMD.run(system, forceEngine)

        # Annealing phase according to the cooling schedule.
        MDoutput.write("%12s<< Annealing/heating phase toward final temperature %s K >>\n" % (' ', str(finalTemps)))
        MDoutput.flush()
        # Note that the following instance name has no meaning. I just borrow its output method.
        #equilibriumMD.outputMD(system, -1, MDoutput)
        #equilibriumMD.outputMD(system, 0, MDoutput)

        cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges,  \
            masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)

        masses *= scaleMass 
        equilibriumMD.outputMD(-1, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)
        equilibriumMD.outputMD(0, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)
        util.outputTrj(xyzFile, Control.printTrjLevel, cellDim, elements, coords, vels, forces, 0)

        #for i in range(1, numAtoms1):
        #    atom = molecule.getAtomWithNumber(i)
        #    atom.setOldPosition(0., 0., 0.)
        #molecule.setOldPotentialEnergy(0.)         
        oldCoords = coords.copy() 
        oldEnergy = energy
        convergence = False
        # Create cooling schedule.
        coolSchedule = self.coolSchedule(annSteps)
        self.integrator.initialize(system)  # Initialize integrator.
        for iStep in range(1, annSteps+1):
            #self.integrator.run(system, forceEngine)  # MD integration.
            coords, vels, energy, forces = self.integrator.run(forceEngine, coords, vels, forces)  # MD integration. 

            if thermoList and (iStep-1) % relaxSteps == 0 and (iStep-1) % freqCheckThermoRegion == 0: 
                # Generate region lists.
                thermoAtomLists, thermoMoveLists, thermoMassLists, thermoVelLists = thermoList.calcRegionList(imove, masses, coords, vels)
                #numRegions = len(thermoAtomLists)
                thermoTemps = numpy.zeros(numRegions, numpy.Float)
                thermoTempsStr = str(iStep) + ' '
                # Compute scaling factor according to cooling schedule.
                scaleFactor = coolSchedule.run(iStep)
                scaleFactor1 = 1. - scaleFactor
                tauTemp = scaleFactor1 * weakTau + scaleFactor * strongTau
                for iRegion in range(numRegions):
                    targetTemp = scaleFactor1 * initTemps[iRegion] + scaleFactor * finalTemps[iRegion]
                    # Create new thermostats.
                    annealThermostat = BerendsenThermostat(targetTemp, dt, tauTemp)
                    thermoAtomList = thermoAtomLists[iRegion]
                    if thermoAtomList == []:
                        thermoTemps[iRegion] = 0.
                        thermoTempsStr += str(thermoTemps[iRegion])+' '
                        continue # Continue if no atoms in thermostat region 
                    thermoMassList = thermoMassLists[iRegion]
                    thermoVelList = thermoVelLists[iRegion]
                    thermoDegFree = 3 * len(thermoAtomList)  # Assume all thermo atoms are movable                              
                    thermoVelList = annealThermostat.run(energy, thermoDegFree, thermoMassList, thermoVelList)  # !!!Energy should be only for thermo atoms. Will be changed later. It is OK now as energy is only used for computing extended Hamitonian in Nose-Hoover method.
                    thermoTemps[iRegion] = util.calcTemp(thermoDegFree, thermoMassList, thermoVelList)
                    thermoTempsStr += str(thermoTemps[iRegion])+' '
                    vels = thermoList.setVels(thermoAtomList, thermoVelList, vels)  # Update full vels list based on thermo vels list.
                if iStep % freqOutputMD == 0: tRegionFile.write(thermoTempsStr+'\n')
            elif not thermoList and (iStep-1) % relaxSteps == 0:
                # Compute scaling factor according to cooling schedule.
                scaleFactor = coolSchedule.run(iStep)
                scaleFactor1 = 1. - scaleFactor
                tauTemp = scaleFactor1 * weakTau + scaleFactor * strongTau
                targetTemp = scaleFactor1 * initTemps[0] + scaleFactor * finalTemps[0]
                # Create new thermostat.
                annealThermostat = BerendsenThermostat(targetTemp, dt, tauTemp)
                vels = annealThermostat.run(energy, degFree, masses, vels)  # Thermostat

            if self.barostat:  # Barostat
                cellDim, coords = self.barostat.run(cellDim, coords, vels, forces, self.integrator)

            #RMScoord = util.calcRMScoord(molecule)
            RMScoord = rmscoords(coords, oldCoords)
            #RMSforce = util.calcRMSforce(molecule)
            RMSforce = rmsforces(forces) 
            diffEnergy = energy - oldEnergy

            if iStep % freqOutputMD == 0: 
                self.outputSA(SAoutput, iStep, scaleFactor, energy, diffEnergy, RMScoord, RMSforce)
                equilibriumMD.outputMD(iStep, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces)

            if iStep % 25 == 0 and isinstance(forceEngine, ReaxForceEngine):  # Must ouput at frequency of integer multiples of 25.
                reax.reaxmdsave(iStep)

            if iStep % freqOutputTrj == 0: 
                util.outputTrj(xyzFile, Control.printTrjLevel, cellDim, elements, coords, vels, forces, iStep)
                equilibriumMD.writeMDrestart(rstName, molName, cellDim, coords, vels, forces, oldForces)

            if (RMSforce <= threshold):
                convergence = True
                if iStep % freqOutputMD != 0: 
                    self.outputSA(SAoutput, iStep, scaleFactor, energy, diffEnergy, RMScoord, RMSforce)
                SAoutput.write("%17s %20.10e %10s\n" % ("Final energy = ", energy / Control.printEnergyUnit, Control.printEnergyFlag))
                SAoutput.write("%17s %20.10e\n" % ("Final RMS force= ", RMSforce / Control.printEnergyUnit))
                SAoutput.write("%30s \n" % ("<< Minimization converged >> "))  
                break
            else:
                #for i in range(1, numAtoms1):
                #    atom = molecule.getAtomWithNumber(i)
                #    atom.setOldPosition(atom.getX(), atom.getY(), atom.getZ())
                #molecule.setOldPotentialEnergy(potEnergy)         
                oldCoords = coords.copy() 
                oldEnergy = energy
    
        arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)  # Update system information.

        if not convergence:
            SAoutput.write("%17s %20.10e %10s\n" % ("Final energy = ", energy / Control.printEnergyUnit, Control.printEnergyFlag))
            SAoutput.write("%17s %20.10e\n" % ("Final RMS force= ", RMSforce / Control.printEnergyUnit))
            SAoutput.write("%58s \n" % ("<< Maximal steps reached, minimization NOT converged >>")) 

        SAoutput.close()
        MDoutput.close()
        xyzFile.close()
        tRegionFile.close()
        
        return 

    def outputSA(self, file, num, scaleFactor, energy, diffEnergy, RMScoord, RMSforce):
        from cmdf.utility.control import Control    

        energy /= Control.printEnergyUnit
        diffEnergy /= Control.printEnergyUnit
        RMSforce /= Control.printEnergyUnit
        file.write("%6i  %5f  %20.10e  %20.10e  %20.10e  %20.10e\n" % \
                    (num, scaleFactor, energy, diffEnergy, RMScoord, RMSforce))
        return

