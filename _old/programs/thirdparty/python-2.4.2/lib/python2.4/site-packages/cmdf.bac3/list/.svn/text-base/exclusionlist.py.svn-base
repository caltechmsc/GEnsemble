####################################################################################
#                                                                                  #
# ExclusionList generates lists of short range interactions that are excluded in   #
# non-bond calculation.                                                            #
#                                                                                  #
# Exclusion12List : an array of bond pairs (i, j)                                  #
# Exclusion13List : an array of angles (i, j, k)                                   #
# Exclusion14List : an array of torsions and inversions (i, j, k, l)               #
#                                                                                  #
# Note that exclusion list may be different from short range list when constraints #
# exist. e.g. a fixed or ignored bond is NOT in bond list for energy calculation   # 
# but still in exclusion list. Also, exclusion 1-4 contains both torsion and       #
# inversion.                                                                       #
#                                                                                  #
# Created on 08/03/06, last revision on 08/03/06. yi                               #
#                                                                                  #
####################################################################################

import numpy

class ExclusionList:

    def __init__(self):

        return

    def calcEXClist(self):

        return

class Exclusion12List(ExclusionList):

    def __init__(self):

        return

    def calcEXClist(self, moveList, conList):
        """
        Generate exclusion 1-2 list:
        bonList[numBond][0] : atom number of first atom(I) in numBond bond  
        bonList[numBond][1] : atom number of second atom(J) in numBond bond  
        Note: I < J
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0

        for i in range(numAtoms):  # Loop over all atoms (both movable and fixed atoms).
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms (both movable and fixed atoms).
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Keep fixed and ignored bonds in exclusion 1-2 list.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                #if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                #    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])

                numBonds +=  1

        print 'Number of exclusion 1-2 = ', numBonds

        return bondList

class Exclusion13List(ExclusionList):

    def __init__(self):

        return

    def calcEXClist(self, moveList, conList):
        """
        Generate exclusion 1-3 list:
        angleList[numAng][0] : atom number of first atom(I) in numBond bond  
        angleList[numAng][1] : atom number of second atom(J) in numBond bond  
        angleList[numAng][3] : atom number of second atom(K) in numBond bond  
        Note: J is the center atom and I < K.
        """

        numAtoms = len(moveList) 
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0

        # Generate exclusion 1-2 list first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break   
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                #if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                #    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of exclusion 1-2 = ', numBonds

        # Generate exclusion 1-3 list based on exclusion 1-2 list.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                if iOne == jOne and iTwo < jTwo:
                    angleList.append([iTwo, iOne, jTwo])    
                    numAngles += 1 
                    continue
                elif iOne == jTwo and iTwo < jOne: 
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1 
                    continue
                elif iTwo == jOne and iOne < jTwo: 
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1 
                    continue
                elif iTwo == jTwo and iOne < jOne: 
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1 
                    continue
                else:
                    continue

        print 'Number of exclusion 1-3 = ', numAngles

        return angleList

class Exclusion14List(ExclusionList):

    def __init__(self):

        return 

    def calcEXClist(self, moveList, conList):
        """
        Exclusion 1-4 list consists of torsion and inversion lists.
        Generate torsion list:
        torsionList[numAng][0] : atom number of first atom(I) in numBond bond  
        torsionList[numAng][1] : atom number of second atom(J) in numBond bond  
        torsionList[numAng][3] : atom number of third atom(K) in numBond bond  
        torsionList[numAng][4] : atom number of fourth atom(L) in numBond bond  
        Note: J and K are center atoms and J < K.
        """

        numAtoms = len(moveList)
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0
        torsionList = []
        numTorsions = 0

        # Generate bond list first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of Bonds = ', numBonds

        # Generate angle list based on bond list.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                # Note that the following angles lists could contain fixed angles. This is allowed because
                # the fourth atom in torsion can be movable.
                if iOne == jOne and iTwo < jTwo:
                    angleList.append([iTwo, iOne, jTwo])
                    numAngles += 1
                    continue
                elif iOne == jTwo and iTwo < jOne:
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1
                    continue
                elif iTwo == jOne and iOne < jTwo:
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1
                    continue
                elif iTwo == jTwo and iOne < jOne:
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1
                    continue
                else:
                    continue

        #print 'Number of Angles = ', numAngles

        # Generate torsion list based on angle list.        
        for i in range(numAngles):
            iOne = angleList[i][0]
            iTwo = angleList[i][1]
            iThree = angleList[i][2]
            for j in range(numAngles):
                if i == j: continue
                jOne = angleList[j][0]
                jTwo = angleList[j][1]
                jThree = angleList[j][2]
                # Allow rigid torsions (all atoms fixed) for exclusion purpose.
                #if moveList[iOne] != 0 and moveList[iTwo] != 0 and moveList[iThree] != 0 and  \
                #    moveList[jOne] != 0 and moveList[jTwo] != 0 and moveList[jThree] != 0:
                #    continue  # If all atoms are fixed or ignored, go to next.
                if iOne == jTwo and iTwo == jOne and iTwo < iOne:
                    torsionList.append([iThree, iTwo, iOne, jThree])
                    numTorsions += 1
                    continue
                elif iTwo == jOne and iThree == jTwo and iTwo < iThree:
                    torsionList.append([iOne, iTwo, iThree, jThree])
                    numTorsions += 1
                    continue
                elif iTwo == jThree and iOne == jTwo and iTwo < iOne:
                    torsionList.append([iThree, iTwo, iOne, jOne])
                    numTorsions += 1
                    continue
                elif iTwo == jThree and iThree == jTwo and iTwo < iThree:
                    torsionList.append([iOne, iTwo, iThree, jOne])
                    numTorsions += 1
                    continue
                else:
                    continue

        #print 'Number of exclusion 1-4 (torsions) = ', numTorsions

        """
        Generate inversion list for ALL possible inversions:
        inversionList[numAng][0] : atom number of first atom(I) in numBond bond  
        inversionList[numAng][1] : atom number of second atom(J) in numBond bond  
        inversionList[numAng][3] : atom number of third atom(K) in numBond bond  
        inversionList[numAng][4] : atom number of fourth atom(L) in numBond bond  
        Note: I is a center atom and J < K < L.
        """

        """
        numAtoms = len(moveList)
        maxCon = len(conList) / numAtoms  # Maximum bond connectivity (=6)
        #print 'Max Con = ', maxCon 
        #maxNumBond = numAtoms * maxCon / 2    
        #bondList = numpy.zeros(maxNumBond*2, numpy.Int16)
        #bondList = numpy.reshape(bondList,(maxNumBond, 2))
        bondList = []
        numBonds = 0
        angleList = []
        numAngles = 0
        inversionList = []
        numInversions = 0

        # Generate bond list first.
        for i in range(numAtoms):  # Loop over all atoms.
            iOne = i
            iCon = i * maxCon
            for j in range(maxCon):  # Loop over all atoms.
                iTwo = conList[iCon+j] - 1  # Atom number index from zero.
                if iTwo == -1:  # Reach the end of connection list.
                    break
                if iOne > iTwo: # iOne should be smaller than iTwo to avoid double counting.
                    continue
                #print 'iOne, iTwo=', iOne, iTwo
                # Do NOT skip fixed bonds as the third atom could be movable.
                #if moveList[iOne] == 1 and moveList[iTwo] == 1:  # Skip if both atoms are fixed. 
                #    continue 
                if moveList[iOne] == 2 or moveList[iTwo] == 2: # Skip ignored atom.
                    continue
                #bondList[numBond][0] = iOne
                #bondList[numBond][1] = iTwo
                bondList.append([iOne, iTwo])  # Note the bond list may differ from the one created in BondList class.

                numBonds +=  1

        #print 'Numer of Bonds = ', numBonds

        # Generate angle list based on bond list.
        for i in range(numBonds):
            iOne = bondList[i][0]
            iTwo = bondList[i][1]
            for j in range(numBonds):
                if i == j: continue
                jOne = bondList[j][0]
                jTwo = bondList[j][1]
                # Note that the following angles lists could contain fixed angles. This is allowed because
                # the fourth atom in torsion can be movable.
                if iOne == jOne and iTwo < jTwo:
                    angleList.append([iTwo, iOne, jTwo])
                    numAngles += 1
                    continue
                elif iOne == jTwo and iTwo < jOne:
                    angleList.append([iTwo, iOne, jOne])
                    numAngles += 1
                    continue
                elif iTwo == jOne and iOne < jTwo:
                    angleList.append([iOne, iTwo, jTwo])
                    numAngles += 1
                    continue
                elif iTwo == jTwo and iOne < jOne:
                    angleList.append([iOne, iTwo, jOne])
                    numAngles += 1
                    continue
                else:
                    continue

        #print 'Number of Angles = ', numAngles
        """

        inversionList = []
        numInversions = 0
        # Generate inversion list based on angle list.        
        for i in range(numAngles):
            iOne = angleList[i][0]
            iTwo = angleList[i][1]
            iThree = angleList[i][2]
            for j in range(numAngles):
                if i == j: continue
                jOne = angleList[j][0]
                jTwo = angleList[j][1]
                jThree = angleList[j][2]
                # Allow rigid inversions for exclusion purpose.
                #if moveList[iOne] != 0 and moveList[iTwo] != 0 and moveList[iThree] != 0 and  \
                #    moveList[jOne] != 0 and moveList[jTwo] != 0 and moveList[jThree] != 0:
                #    continue  # If all atoms are fixed or ignored, go to next.
                if iTwo == jTwo and iOne == jOne and iOne < iThree and iThree < jThree:
                    inversionList.append([iTwo, iOne, iThree, jThree])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iOne == jThree and iOne < iThree and iThree < jOne:
                    inversionList.append([iTwo, iOne, iThree, jOne])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iThree == jOne and iThree < iOne and iOne < jThree:
                    inversionList.append([iTwo, iThree, iOne, jThree])
                    numInversions += 1
                    continue
                elif iTwo == jTwo and iThree == jThree and iThree < iOne and iOne < jOne:
                    inversionList.append([iTwo, iThree, iOne, jOne])
                    numInversions += 1
                    continue
                else:
                    continue

        print 'Number of exclusion 1-4 (inversion) = ', numInversions


        return torsionList, inversionList 

