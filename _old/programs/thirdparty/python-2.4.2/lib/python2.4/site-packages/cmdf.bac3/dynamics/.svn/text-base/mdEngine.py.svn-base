#!/usr/bin/env python
#####################################################################################
# MDEngine class: Molecular dynamics in the microcanonical(NVE), canonical(NVT),    #
# and isothermal-isobaric(NPT) ensembles.                                           #
#                                                                                   #
# Created on 01/22/06, last revision on 09/06/06. yi                                #
#                                                                                   #
#####################################################################################
import datetime
import numpy 
from cmdf.dynamics.integrator_pf import VelocityVerlet_f, LeapFrog, Beeman
from cmdf.dynamics.thermostat_pf import BerendsenThermostat, AndersenThermostat, NoseHooverThermostat  
#from cmdf.dynamcis.barostat_pf import BerendsenBarostat
from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3
from cmdf.utility.communication import systemToArrays, arraysToSystem_md, arraysToSystem_min
from cmdf.utility.control import Control
from cmdf.utility.unit import Unit 
from cmdf.utility.utility_pf import Utility 
from cmdf.utility.utility_f import translatecm
from cmdf.reaxFF.reaxForceEngine import ReaxForceEngine
import cmdf.reaxFF.reax as reax

class MDEngine:

    def __init__(self, integrator=None, thermostats=[], thermoList=None, barostat=None,  \
        gaussian=Gaussian3, numSteps=1000, freqOutputMD=10, freqOutputTrj=10,  \
        freqCheckThermoRegion=500, initTemps=[600.]):  
        self.integrator = integrator
        self.thermostats = thermostats
        self.thermoList = thermoList    
        self.barostat = barostat
        self.gaussian = gaussian
        self.numSteps = numSteps
        self.freqOutputMD = freqOutputMD
        self.freqOutputTrj = freqOutputTrj
        self.freqCheckThermoRegion = freqCheckThermoRegion
        self.initTemps = initTemps

        return

    def initialize(self, system, forceEngine):
    # Initialize position and velocity of molecule.
        #from control import Control
        util = Utility()

        molecule = system.getMolecule(0)
        molName = molecule.getName()
        degFree = molecule.getDegFree()
        isPeriodic = system.isPeriodic()
        initTemps = self.initTemps
        gaussian = self.gaussian
        thermoList = self.thermoList

        cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges,  \
            masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)

        # Translate the center of mass to origin.
        origin = numpy.zeros(3, numpy.Float)
        coords = translatecm(masses, coords, origin)

        if thermoList:   
            thermoAtomLists, thermoMoveLists, thermoMassLists, thermoVelLists = thermoList.calcRegionList(imove, masses, coords, vels)

            numRegions = len(thermoAtomLists)
            for iRegion in range(numRegions):
                thermoAtomList = thermoAtomLists[iRegion]
                if thermoAtomList == []: continue # Continue if no atoms in thermostat region 
                thermoMoveList = thermoMoveLists[iRegion]
                thermoMassList = thermoMassLists[iRegion]
                thermoVelList = thermoVelLists[iRegion]
                # Assign velocity from Maxwell-Boltzmann distribution.
                thermoVelList = util.setMBvelocity(thermoMoveList, thermoMassList, thermoVelList, initTemps[iRegion], gaussian)
                vels = thermoList.setVels(thermoAtomList, thermoVelList, vels)  # Update full vels list based on thermo vels list.
        elif not thermoList:  # Applies to entire system rather than thermo regions 
             vels = util.setMBvelocity(imove, masses, vels, initTemps[0], gaussian)

        # Assign velocity from random uniform distribution.
        #vels = util.setRanVelocity(degFree, imove, masses, vels, self.initTemp)

        # Remove translation and rotation.
        util.removeTranslation(molName, imove, masses, vels)
        if isPeriodic == 0:  # Non-periodic
            #util.removeTranslation(molName, imove, masses, vels)
            util.removeRotation(molName, imove, masses, coords, vels)  

        energy, forces = forceEngine.calcEnergyForce(coords)
        oldforces = forces.copy()

        arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)  # Update system information.

        ### The following will be adsorbed into arraysToSystem_md() by adding oldCoords, oldVels, oldForces.
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1
        for i in range(1, numAtoms1): 
            atom = molecule.getAtomWithNumber(i)

            # Set zero velocities and forces to fixed and ignored atoms.
            if atom.isMovable() != 1:
                atom.setVelocity(0., 0., 0.)
                atom.setOldVelocity(0., 0., 0.)
                continue

            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()
            atom.setOldPosition(rx, ry, rz)

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
            atom.setOldVelocity(vx, vy, vz)

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()
            atom.setOldForce(fx, fy, fz)

        if Control.printLevel > 0:
            logFile = open(molName+'.log', 'a')
            logFile.write('=> MD initialization completed.\n')    
            logFile.close()

        return

    def run(self, system, forceEngine):
        #from control import Control
        util = Utility()
        molecule = system.getMolecule(0)
        molName = molecule.getName() 
        xyzFile = open(molName+'.trj', 'a')
        MDoutput = open(molName+'.dyn', 'a')
        tRegionFile = open(molName+'.treg', 'a')
        logFile = open(molName+'.log', 'a')
        rstName = molName+'.rst'
        mdSteps = self.numSteps
        freqOutputMD = self.freqOutputMD
        freqOutputTrj = self.freqOutputTrj
        freqCheckThermoRegion = self.freqCheckThermoRegion
        minz = Control.sumForceMinZ
        maxz = Control.sumForceMaxZ
        degFree = molecule.getDegFree()
        isPeriodic = system.isPeriodic()
        thermostats = self.thermostats
        thermoList = self.thermoList
    
        if Control.printLevel > 1:
            initMDStart = datetime.datetime.now()
        self.initialize(system, forceEngine)  # Initialize positions and velocities of molecule.
        if Control.printLevel > 1:
            initMDEnd = datetime.datetime.now()
            logFile.write('MD initialization timing:\n'); logFile.flush()    
            util.timer(molName, initMDStart, initMDEnd)

        if Control.printLevel > 1:
            initIntegratorStart = datetime.datetime.now()
        self.integrator.initialize(system)  # Initialize integrator.
        if Control.printLevel > 1:
            initIntegratorEnd = datetime.datetime.now()
            logFile.write('Integrator initialization timing:\n'); logFile.flush()    
            util.timer(molName, initIntegratorStart, initIntegratorEnd)

        if Control.printLevel > 1:
            iter0MDStart = datetime.datetime.now()
        try:
            self.readMDrestart(system, forceEngine, rstName)  # Set parameters from restart file.
        except:
            logFile.write('=> CMDF dynamics starts from scratch.\n'); logFile.flush()
        else:
            logFile.write('=> CMDF dynamics restarts from previous result.\n'); logFile.flush()

        cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges,  \
            masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)

        self.outputMD(-1, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces) 
        self.outputMD(0, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces) 
        util.outputTrj(xyzFile, Control.printTrjLevel, cellDim, elements, coords, vels, forces, 0)
        if Control.printLevel > 1:
            iter0MDEnd = datetime.datetime.now()
            logFile.write('MD read/output timing, i = 0\n'); logFile.flush()    
            util.timer(molName, iter0MDStart, iter0MDEnd)

        for i in range(1, mdSteps+1):  # MD main loop

            if Control.printLevel > 1:
                iterMDStart = datetime.datetime.now()

            for thermostat in thermostats:
                if isinstance(thermostat, NoseHooverThermostat):                                         
                    if thermoList and (i == 1 or i % freqCheckThermoRegion == 0):
                        thermoAtomLists, thermoMoveLists, thermoMassLists, thermoVelLists = thermoList.calcRegionList(imove, masses, coords, vels)
                        numRegions = len(thermoAtomLists)
                        for iRegion in range(numRegions):
                            thermoAtomList = thermoAtomLists[iRegion]
                            if thermoAtomList == []: continue # Continue if no atoms in thermostat region 
                            thermoMassList = thermoMassLists[iRegion]
                            thermoVelList = thermoVelLists[iRegion]
                            thermostat = thermostats[iRegion]
                            thermoDegFree = 3 * len(thermoAtomList) # Assume all thermo atoms are movable 
                            thermoVelList = thermostat.run(energy, thermoDegFree, thermoMassList, thermoVelList)  # !!!Energy should be only for thermo atoms. Will be changed later. It is OK now as energy is only used for computing extended Hamitonian in Nose-Hoover method.
                            vels = thermoList.setVels(thermoAtomList, thermoVelList, vels)  # Update full vels list based on thermo vels list.
                    elif not thermoList:
                        vels = thermostats[0].run(energy, degFree, masses, vels)

            oldForces = forces.copy()
            coords, vels, energy, forces = self.integrator.run(forceEngine, coords, vels, forces)  # MD integration. 

            if thermostats:  # Thermostats
                if thermoList and (i == 1 or i % freqCheckThermoRegion) == 0:
                    thermoAtomLists, thermoMoveLists, thermoMassLists, thermoVelLists = thermoList.calcRegionList(imove, masses, coords, vels)
                    numRegions = len(thermoAtomLists)
                    thermoTemps = numpy.zeros(numRegions, numpy.Float)
                    thermoTempsStr = str(i) + ' '
                    for iRegion in range(numRegions):
                        thermoAtomList = thermoAtomLists[iRegion]
                        if thermoAtomList == []:
                            thermoTempsStr += str(thermoTemps[iRegion])+' ' 
                            continue # Return if no atoms in thermostat region 
                        thermoMassList = thermoMassLists[iRegion]
                        thermoVelList = thermoVelLists[iRegion]
                        thermostat = thermostats[iRegion]
                        thermoDegFree = 3 * len(thermoAtomList)  # Assume all thermo atoms are movable                              
                        thermoVelList = thermostat.run(energy, thermoDegFree, thermoMassList, thermoVelList)  # !!!Energy should be only for thermo atoms. Will be changed later. It is OK now as energy is only used for computing extended Hamitonian in Nose-Hoover method.
                        thermoTemps[iRegion] = util.calcTemp(thermoDegFree, thermoMassList, thermoVelList)
                        thermoTempsStr += str(thermoTemps[iRegion])+' ' 
                        vels = thermoList.setVels(thermoAtomList, thermoVelList, vels)  # Update full vels list based on thermo vels list.
                    if i % freqOutputMD == 0: tRegionFile.write(thermoTempsStr+'\n')
                elif not thermoList:
                    vels = thermostats[0].run(energy, degFree, masses, vels)

            if self.barostat:  # Barostat
                cellDim, coords = self.barostat.run(cellDim, coords, vels, forces, self.integrator)

            if Control.printLevel > 1:
                iterMDMid = datetime.datetime.now()
                logFile.write('MD integration timing, i = '+str(i)+'\n'); logFile.flush()    
                util.timer(molName, iterMDStart, iterMDMid)

            if i % freqOutputMD == 0:  # Output dyn and sumforce files.
                self.outputMD(i, MDoutput, degFree, cellDim, masses, coords, vels, energy, forces) 
                #util.sumForce(molName, imove, elements, coords, forces, minz, maxz, i)

            if i % 25 == 0 and isinstance(forceEngine, ReaxForceEngine):  # Must output at frequency of integer multiples of 25.
                reax.reaxmdsave(i)

            if i % freqOutputTrj == 0:  # Output trajectory and restart files.
                util.outputTrj(xyzFile, Control.printTrjLevel, cellDim, elements, coords, vels, forces, i)
                self.writeMDrestart(rstName, molName, cellDim, coords, vels, forces, oldForces)

            if i % freqOutputTrj == 0  \
                and not (thermostats and isinstance(thermostats[0], AndersenThermostat)): 
                util.removeTranslation(molName, imove, masses, vels)
                #util.removeRotation(molName, imove, masses, coords, vels)  
                if isPeriodic == 0:  # Non-periodic
                    #util.removeTranslation(molName, imove, masses, vels)
                    util.removeRotation(molName, imove, masses, coords, vels)  
            
            if Control.printLevel > 1:
                iterMDEnd = datetime.datetime.now()
                logFile.write('MD output timing, i = '+str(i)+'\n'); logFile.flush()    
                util.timer(molName, iterMDMid, iterMDEnd)

        MDoutput.close()
        xyzFile.close()
        logFile.close()
        tRegionFile.close()

        arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)  # Update system information.
    
        return

    def outputMD(self, n, dynfile, degFree, cellDim, masses, coords, vels, energy, forces):
        #from control import Control
        if n < 0:
            # Print the header of DYN file.
            strEnergyUnit = Control.printEnergyFlag
            strPressureUnit = Control.printPressureFlag
            dynfile.write("%3sN_Iter.%3sTot_E(%-8s)%5sPot_E(%-8s)%5sKin_E(%-8s)%3sTemp.(K)%5sPress.(%-3s)%1sVolume(A^3)\n" \
 %(' ',' ',strEnergyUnit,' ',strEnergyUnit,' ',strEnergyUnit,' ',' ',strPressureUnit,' '))
            return

        else:
            util = Utility()

            if isinstance(self.integrator, LeapFrog):
                potEnergy = molecule.getOldPotentialEnergy()
                kinEnergy, temp = util.calcOldKinEnergyTemp(molecule) 
                n -= 1
            else:
                potEnergy = energy 
                kinEnergy, temp = util.calcKinEnergyTemp(degFree, masses, vels)
            potEnergy /= Control.printEnergyUnit
            kinEnergy /= Control.printEnergyUnit
            totEnergy = potEnergy + kinEnergy
            press = util.calcPress(cellDim, masses, coords, vels, forces, self.integrator) / Control.printPressureUnit
            volume = util.calcVolume(cellDim, self.integrator)

            dynfile.write("%8i  %18.10e  %18.10e  %18.10e  %10.7f  %10.5f  %8.5f\n" %  \
                  (n, totEnergy, potEnergy, kinEnergy, temp, press, volume))

        return

    def writeMDrestart(self, rstfilename, molName, cellDim, r, v, f, oldf):
        numAtoms = int(len(r) / 3)

        # Write a restart file.
        rstfile = open(rstfilename, 'w')
        rstfile.write("%-11s  %-8i  %-60s\n" % ('Num_Atoms:', numAtoms, molName))
        rstfile.write("%-16s  %-12.5e  %-12.5e  %-12.5e  %-10.5f  %-10.5f  %-10.5f\n" %  \
                  ('Cell_Dimension:', cellDim[0], cellDim[1], cellDim[2],  \
                          cellDim[3], cellDim[4], cellDim[5])) 
        rstfile.write("%-30s\n" % ('Current positions:'))
        for i in range(numAtoms):
            i3 = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            rstfile.write("%18.10e  %18.10e  %18.10e\n" %  \
                        (r[i3], r[i31], r[i32]))

        rstfile.write("%-30s\n" % ('Current velocities:'))
        for i in range(numAtoms):
            i3 = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            rstfile.write("%18.10e  %18.10e  %18.10e\n" %  \
                        (v[i3], v[i31], v[i32]))

        rstfile.write("%-30s\n" % ('Current forces:'))
        for i in range(numAtoms):
            i3 = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            rstfile.write("%18.10e  %18.10e  %18.10e\n" %  \
                        (f[i3], f[i31], f[i32]))

        rstfile.write("%-30s\n" % ('Previous forces:'))
        for i in range(numAtoms):
            i3 = i * 3
            i31 = i3 + 1
            i32 = i3 + 2
            rstfile.write("%18.10e  %18.10e  %18.10e\n" %  \
                        (oldf[i3], oldf[i31], oldf[i32]))

        rstfile.close()

        return

    def readMDrestart(self, system, forceEngine, filename):
    # Set the data model from a restart file.        
        molecule = system.getMolecule(0)

        rstFile = open(filename, 'r')
        #checkFile = open('readCheck', 'w')
        for line in rstFile.readlines():
            if line.find('#') == 0: 
                continue

            if line.find('Num_Atoms') == 0:
                fields = line.split()
                if len(fields) >=2:
                    molecule.setNumber(int(fields[1]))            
                    molecule.setName(fields[2])
                    #checkFile.write('Num_Atoms:'+ fields[1]+ fields[2]+'\n')
                continue

            if line.find('Cell_Dimension') == 0:
                fields = line.split()
                if len(fields) >= 4:
                    cellA = float(fields[1])
                    cellB = float(fields[2])
                    cellC = float(fields[3])
                    if len(fields) >= 7:
                        alpha = float(fields[4])
                        beta  = float(fields[5])
                        gamma = float(fields[6])
                    else:
                        alpha = system.getA()
                        beta  = system.getB()
                        gama  = system.getC()
                
                    system.setCellParameters(cellA, cellB, cellC,  \
                                             alpha, beta, gamma)
                    #checkFile.write('Cell dimension:'+ fields[1]+ fields[2]+ fields[3]+ fields[4]+ fields[5]+ fields[6]+'\n')
                continue

            if line.find('Current positions') == 0: 
                numline = 0
                #checkFile.write(line+'\n')
                continue

            if numline < molecule.numAtoms(): 
                fields = line.split()
                if len(fields) < 3: 
                    print 'Warning! readMDrestart: Coordinates not completed.'
                numline += 1
                atom = molecule.getAtomWithNumber(numline)
                atom.setPosition(float(fields[0]), float(fields[1]), float(fields[2]))
                #checkFile.write(fields[0]+ fields[1]+ fields[2]+'\n')
                continue

            if line.find('Current velocities') == 0: 
                #checkFile.write(line+'\n')
                continue

            if numline < 2 * molecule.numAtoms(): 
                fields = line.split()
                if len(fields) < 3: 
                    print 'Warning! readMDrestart: Velocities not completed.'
                numline += 1
                atom = molecule.getAtomWithNumber(numline - molecule.numAtoms())
                atom.setVelocity(float(fields[0]), float(fields[1]), float(fields[2]))
                #checkFile.write(fields[0]+ fields[1]+ fields[2]+'\n')
                continue

            if line.find('Current forces') == 0: 
                #checkFile.write(line+'\n')
                continue

            if numline < 3 * molecule.numAtoms(): 
                fields = line.split()
                if len(fields) < 3: 
                    print 'Warning! readMDrestart: Current forces not completed.'
                numline += 1
                atom = molecule.getAtomWithNumber(numline - 2 * molecule.numAtoms())
                atom.setForce(float(fields[0]), float(fields[1]), float(fields[2]))
                #checkFile.write(fields[0]+ fields[1]+ fields[2]+'\n')
                continue

            if line.find('Previous forces') == 0: 
                #checkFile.write(line+'\n')
                continue

            if numline < 4 * molecule.numAtoms(): 
                fields = line.split()
                if len(fields) < 3: 
                    print 'Warning! readMDrestart: Previous forces not completed.'
                numline += 1
                atom = molecule.getAtomWithNumber(numline - 3 * molecule.numAtoms())
                atom.setOldForce(float(fields[0]), float(fields[1]), float(fields[2]))
                #checkFile.write(fields[0]+ fields[1]+ fields[2]+'\n')
                continue

        cellDim, elements, coords, vels, energy, forces, oldForces, imove, fixed, charges,  \
            masses, fftypes, bondlist, orderlist, itranlist = systemToArrays(system)

        #forceEngine.setCoords(coords)
        #forceEngine.calcEnergyForce()
        #energy = forceEngine.getEnergy()
        energy, forces = forceEngine.calcEnergyForce(coords)

        arraysToSystem_md(system, cellDim, coords, vels, energy, forces, oldForces)  # Update system information.

        return

