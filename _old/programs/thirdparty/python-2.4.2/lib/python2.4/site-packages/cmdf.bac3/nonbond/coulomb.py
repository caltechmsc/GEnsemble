####################################################################################
#                                                                                  #
# Coulomb energy-force engine                                                      #
#                                                                                  #
# Coulomb class compute electrostatic interactions for either point charges or     # 
# distributed charges.                                                             #
#                                                                                  #
# Created on 08/01/06, last revision on 08/01/06. yi                               #
#                                                                                  #
####################################################################################

from math import sqrt
import numpy
from cmdf.utility.unit import Unit
unit = Unit()

class Coulomb:

    def __init__(self, epsilon, reps):
        #unit.electrostatic_energy = 1.0 / (4.0 * unit.PI * epsilon0)
        self.coulombCoeff = unit.electrostatic_energy / epsilon 
        self.reps = reps  # Logical variable to indicate if eps edpends on distance.

        return

    #def calcCoulombEF(self, nbMoveList, nbCoordList, nbChargeList, exclusion12List, exclusion13List):
    def calcCoulombEF(self, nbLists, exclusionLists):
        # This can not be called for periodic system.
        #nbLists = {'move': nbMoveList, 'coord': nbCoordList, 'charge': nbChargeList}
        #exclusionLists = {'1-2': exclusion12List, '1-3': exclusion13List,  \
        #       '1-4Torsion': exclusion14TorsionList, '1-4Inversion': exclusion14InversionList}

        exclu12 = False
        exclu13 = False
        exclu14 = False

        # Unpack dictionary. 
        nbMoveList = nbLists['move']
        nbCoordList = nbLists['coord']
        nbChargeList = nbLists['charge']

        coulombCoeff = self.coulombCoeff
        reps = self.reps  # epsilon = epsilon * r if reps is true, otherwise eps is a constant. 
        numNBAtoms = len(nbLists['move']) 
        numNonBonds = 0
        numExcludedBonds = 0
        energyCoulomb = 0.
        nbForceList = numpy.zeros(3*numNBAtoms, numpy.Float64)
        for i in range(numNBAtoms-1):  # Loop over movable atoms only.
            if nbMoveList[i] == 1:  # Skip if atom is fixed.
                continue
            chargeI = nbChargeList[i]

            for j in range(i+1, numNBAtoms): 
                chargeJ = nbChargeList[j]
                
                # Check exclusion
                ### Make the following as a subroutine later in nb method as it will be used in vdw also.
                for exclusion in exclusionLists:
                    if exclusion == '1-2':
                        for bond in exclusionLists[exclusion]:
                            if i == bond[0] and j == bond[1]: 
                                exclu12 = True
                                break
                        if exclu12: break
                    if exclusion == '1-3':
                        for angle in exclusionLists[exclusion]:
                            if (i == angle[0] and j == angle[1]) or  \
                                    (i == angle[1] and j == angle[0]) or  \
                                    (i == angle[1] and j == angle[2]) or  \
                                    (i == angle[2] and j == angle[1]) or  \
                                    (i == angle[0] and j == angle[2]) or  \
                                    (i == angle[2] and j == angle[0]):  # This check may not be necessary as I < K. 
                                exclu13 = True
                                break
                        if exclu13: break
                    if exclusion == '1-4Torsion':
                        for torsion in exclusionLists[exclusion]:
                            if (i == torsion[0] and j == torsion[1]) or  \
                                    (i == torsion[1] and j == torsion[0]) or  \
                                    (i == torsion[1] and j == torsion[2]) or  \
                                    (i == torsion[2] and j == torsion[1]) or  \
                                    (i == torsion[2] and j == torsion[3]) or  \
                                    (i == torsion[3] and j == torsion[2]) or  \
                                    (i == torsion[0] and j == torsion[2]) or  \
                                    (i == torsion[2] and j == torsion[0]) or  \
                                    (i == torsion[0] and j == torsion[3]) or  \
                                    (i == torsion[3] and j == torsion[0]) or  \
                                    (i == torsion[1] and j == torsion[3]) or  \
                                    (i == torsion[3] and j == torsion[1]):     
                                exclu14 = True
                                break
                        if exclu14: break
                    if exclusion == '1-4Inversion':
                        for inversion in exclusionLists[exclusion]:
                            if (i == inversion[0] and j == inversion[1]) or  \
                                    (i == inversion[1] and j == inversion[0]) or  \
                                    (i == inversion[0] and j == inversion[2]) or  \
                                    (i == inversion[2] and j == inversion[0]) or  \
                                    (i == inversion[0] and j == inversion[3]) or  \
                                    (i == inversion[3] and j == inversion[0]) or  \
                                    (i == inversion[1] and j == inversion[2]) or  \
                                    (i == inversion[2] and j == inversion[1]) or  \
                                    (i == inversion[1] and j == inversion[3]) or  \
                                    (i == inversion[3] and j == inversion[1]) or  \
                                    (i == inversion[2] and j == inversion[3]) or  \
                                    (i == inversion[3] and j == inversion[2]): 
                                exclu14 = True
                                break
                        if exclu14: break
                if exclu12 or exclu13 or exclu14:
                    numExcludedBonds += 1 # Count the number of excluded bonds. 
                    exclu12 = False
                    exclu13 = False
                    exclu14 = False
                    continue  # Bond excluded, go to next one.
                # Exclusion is done.

                numNonBonds += 1  # Count the number of non-bonded pairs.

                dxij = nbCoordList[i*3]   - nbCoordList[j*3]
                dyij = nbCoordList[i*3+1] - nbCoordList[j*3+1]
                dzij = nbCoordList[i*3+2] - nbCoordList[j*3+2]
                distSq = dxij * dxij + dyij * dyij + dzij * dzij
                distSqInv = 1.0 / distSq  

                if reps:  # epsilon = epsilon * r
                    eCoulomb = chargeI * chargeJ * distSqInv 
                    derForceC = -2.0 * distSqInv * eCoulomb
                else:
                    distInv = sqrt(distSqInv) 
                    eCoulomb = chargeI * chargeJ * distInv
                    derForceC = -distSqInv * eCoulomb

                # cutoff etc. Not implemented yet. 
                eCoulombPair = eCoulomb 
                derForce = derForceC     

                energyCoulomb += eCoulombPair 

                # Compute atomic forces
                forceXinc = dxij * derForce     
                forceYinc = dyij * derForce     
                forceZinc = dzij * derForce     

                nbForceList[i]   += forceXinc
                nbForceList[i+1] += forceYinc
                nbForceList[i+2] += forceZinc
                nbForceList[j]   -= forceXinc
                nbForceList[j+1] -= forceYinc
                nbForceList[j+2] -= forceZinc

        energyCoulomb *= coulombCoeff 
        nbForceList *= coulombCoeff

        print 'Number of included Non-bonds = ', numNonBonds
        print 'Number of excluded Non-bonds = ', numExcludedBonds

        return energyCoulomb, nbForceList

