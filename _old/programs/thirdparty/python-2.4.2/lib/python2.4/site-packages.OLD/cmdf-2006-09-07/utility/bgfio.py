#!/usr/bin/env python

"""\
 bgfio.py: bgf reader and writer

 This program is part of the CMDF.
 Copyright 2004 California Institute of Technology.  All Rights
 Reserved. Markus J. Buehler, mbuehler@wag.caltech.edu

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation provided that the above copyright notice
 and this complete notice appear in all copies.

 This program is distributed in the hope that it will be useful, and in
 no event shall California Institute of Technology be liable to any
 party for direct, indirect, special, incidental or consequential
 damages, including lost profits, arising out of the use of this
 software and its documentation, even if the California Institute of
 Technology has been advised of the possibility of such damage. The
 California Institute of Technology specifically disclaims any
 warranties, including the implied warranties or merchantability and
 fitness for a particular purpose. The software and documentation
 provided hereunder is on an AS IS basis, and the California Institute
 of Technology has no obligations to provide maintenance, support,
 updates, enhancements or modifications.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307
"""
import sys, types
from cmdf.modbabel.modbabel import *
from Scientific.IO.FortranFormat import FortranFormat, FortranLine


###################################
# helper functions
###################################
def connect(molecule, conect, order, itran):
    for i in range(len(conect)):
        con = conect[i]
        ord = order[i]
        itr = itran[i]
        rootNumber = int(con[0])
        for j in range(1, len(con)):
            neighborNumber = int(con[j])
            bo = int(ord[j])
            it = int(itr[j])
            molecule.addBond(rootNumber, neighborNumber, bo, it)


def fftype2element(fftype):
    # determine the element from the fftype
    symbol = fftype
    if len(symbol) == 1:
        symbol = symbol[0]
    elif len(symbol) >= 2:
        if symbol[1] == '_':
            symbol = symbol[0]
        else:
            symbol = symbol[0:2] 
    else:
        symbol = ''

    return symbol


def reformat(format_string):
    """
    Reformats a format string to remove spaces.  This is
    necessary because the Scientific.IO.FortranFormat
    constructor barfs if it finds spaces in the line.
    """
    delim = ','
    line = format_string.split(delim)
    for i in range(len(line)):
        line[i] = line[i].strip()
    return delim.join(line)


def strip_zeros(data):
    """
    Remove all zeros from the end of
    a list of integers.
    """

    for i in range(len(data)):
        if data[i] == 0:
            return data[0:i]
    return data


def truncate(data, size):
    """
    Truncates a list so that it's
    lenght is equal to size.
    """
    if size >= 0 and len(data) >= size:
        return data[0:size]


def get_format_string(line):
    """
    Takes a line from a bgf file that contains a format
    string and returns the reformatted string.
    """
    format_string = ''
    start = line.find('(') + 1
    end = line.find(')')
    if start != -1 and end != -1:
        format_string = line[start:end]
        format_string = format_string.strip()
        format_string = reformat(format_string)

    return format_string

###################################
# Read/Write functions
###################################
def read(filepath, format=False):
    """
    Reads a bgf file and returns a modbabel
    system object. Use the format flag to
    read the data according to the fortran
    format string.
    """

    format_dict = {}

    system = System()
    molecule = system.newMolecule()

    conect = []
    order = []
    itran = []

    neighbors = []

    f = open(filepath, 'r')

    for line in f:
        if line[0:6] == 'REMARK': continue
        if format:
            if line.find('FORMAT') != -1:
                format = FortranFormat(get_format_string(line))
                if line.find('ATOM') != -1:
                    format_dict['ATOM'] = format
                    continue
                if line.find('CONECT') != -1:
                    format_dict['CONECT'] = format
                    continue
                if line.find('ORDER') != -1:
                    format_dict['ORDER'] = format
                    continue

        if line.find('DESCRP') == 0:
            fields = line.split()
            if len(fields) > 1:
                molecule.setName(fields[1])

        if line.find('SGNAME') == 0:
            fields = line.split()
            if len(fields) >= 5:
                system.setSgName(fields[1])
                system.setSgSymbol(fields[2])
                system.setSgNumber(int(fields[3]))
                system.setSgCaseNumber(int(fields[4]))


        if line.find('AXES') == 0:
            fields = line.split()
            if len(fields) >= 2:
                system.setAxes(fields[1])

        if line.find('CRYSTX') == 0:
            fields = line.split()
            if len(fields) >= 7:
                system.setCellParameters(float(fields[1]),float(fields[2]),float(fields[3]),
                                         float(fields[4]),float(fields[5]),float(fields[6]))

        if line.find('ATOM') == 0 or line.find('HETATM') == 0:
            chain = 'A'
            movable = 1
            if format:
                atom_data = FortranLine(line, format_dict['ATOM'])
            else:    
                atom_data = line.split()

            if line[23] == ' ':
                keyword = atom_data[0]
                number = int(atom_data[1])
                label = atom_data[2]
                residue_name = atom_data[3]
                residue_number = int(atom_data[4])
                x = float(atom_data[5])
                y = float(atom_data[6])
                z = float(atom_data[7])
                fftype = atom_data[8]
                max_covalent_bonds = int(atom_data[9])
                lone_pairs = int(atom_data[10])
                charge = float(atom_data[11])

                """
                if len(atom_data) >= 13: 
                    movable = int(atom_data[12])
                if len(atom_data) >= 14: 
                    mass = float(atom_data[13])
                if len(atom_data) >= 15: 
                    solvation = int(atom_data[14])
                """    

            else:
                keyword = atom_data[0]
                number = int(atom_data[1])
                label = atom_data[2]
                residue_name = atom_data[3]
                chain = atom_data[4]
                residue_number = int(atom_data[5])
                x = float(atom_data[6])
                y = float(atom_data[7])
                z = float(atom_data[8])
                fftype = atom_data[9]
                max_covalent_bonds = int(atom_data[10])
                lone_pairs = int(atom_data[11])
                charge = float(atom_data[12])

                """
                if len(atom_data) >= 14: 
                    movable = int(atom_data[13])
                if len(atom_data) >= 15: 
                    mass = float(atom_data[14])
                if len(atom_data) >= 16: 
                    solvation = int(atom_data[15])
                """    


            residue = molecule.getResidue(residue_name, residue_number, chain)

            atom = residue.newAtom(number, label, residue_name, chain,
                                   residue_number, x, y, z, fftype, 
                                   charge, max_covalent_bonds, lone_pairs)

            atom.setElement(fftype2element(fftype))
           
            if movable == 0:
                atom.setFixed(1, 1, 1)

        if format:
            if line.find('CONECT') == 0:
                conect_data = FortranLine(line, format_dict['CONECT'])
                conect_data = strip_zeros(conect_data)
                conect_data = conect_data[1:]
                order_data = ['1']*len(conect_data)
                order_data[0] = conect_data[0]
                itran_data = ['222']*len(conect_data)
                itran_data[0] = conect_data[0]
                conect.append(conect_data)
                order.append(order_data) 
                itran.append(itran_data) 

            if line.find('ORDER') == 0:
                order_data = FortranLine(line, format_dict['CONECT'])
                order_data = strip_zeros(order_data)
                order_data = order_data[1:]
                order[-1] = order_data

            if line.find('ITRAN') == 0:
                itran_data = FortranLine(line, format_dict['CONECT'])
                itran_data = strip_zeros(data)
                itran_data = itran_data[1:]
                itran[-1] = itran_data
        else:
            if line.find('CONECT') == 0:
                conect_data = line.split()[1:]
                order_data = ['1']*len(conect_data)
                order_data[0] = conect_data[0]
                itran_data = ['222']*len(conect_data)
                itran_data[0] = conect_data[0]
                conect.append(conect_data)
                order.append(order_data) 
                itran.append(itran_data) 

            if line.find('ORDER') == 0 :
                order_data = line.split()[1:]
                order[-1] = order_data

            if line.find('ITRAN') == 0:
                itran_data = line.split()[1:]
                itran[-1] = itran_data
            
    connect(molecule, conect, order, itran )
    f.close()
    return system



def write(system, filepath, format=False):
    """
    Write the content of system obejct to bgf file.
    If format=True, output is formatted according to 
    the bgf format strings. 
    """

    molecule = system.getMolecule(0)
    name = molecule.getName()

    cellx = system.getA()
    celly = system.getB()
    cellz = system.getC()

    alpha = system.getAlpha()
    beta = system.getBeta()
    gamma = system.getGamma()

    natoms = molecule.numAtoms()
    newlines = []
    connection_table = []


    chunk = 'XTLGRF 200\n'
    newlines.append(chunk)
    chunk = 'DESCRP %s\n' % name
    newlines.append(chunk)
    chunk = 'REMARK BGF file generated by CMDF\n'
    newlines.append(chunk)
    chunk = 'REMARK Structure contains %d atoms\n' % (natoms)
    newlines.append(chunk)

    chunk = 'CRYSTX %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f\n' % (cellx, celly, cellz, alpha, beta, gamma)
    newlines.append(chunk)
    chunk = 'FORMAT ATOM   (a6,1x,i5,1x,a5,1x,a3,1x,a1,1x,a5,3f10.5,1x,a5,i3,i2,1x,f8.5)\n'
    newlines.append(chunk)

    i = 1

    while i <= natoms:
   
        atom = molecule.getAtomWithNumber(i)
        chg = atom.getCharge()
       
        atom_data = ('HETATM', atom.getNumber(), atom.getElement()+str(atom.getNumber()), atom.getResidueName(), atom.getChain(), 
                     atom.getResidueNumber(), atom.getX(), atom.getY(), atom.getZ(), 
                     atom.getFFType(), atom.getMaxCovalentBonds(), atom.getLonePairs(), atom.getCharge())

        if format:
            format_string = '%-6s %5d %-5s %3s %1s %-4d %10.5f%10.5f%10.5f %-5s%3d%2d%9.5f\n'
        else:
            format_string = '%-6s %5d %-5s %3s %1s %-4d %10.5f %10.5f %10.5f %-5s %3d %2d %9.5f\n'
        chunk = format_string % atom_data
        newlines.append(chunk)
        i += 1


    # connection data
    newlines.append('FORMAT CONECT (a6,12i6)\n') 
    i = 1
    while i <= natoms:
        atom = molecule.getAtomWithNumber(i)
        root = atom.getNumber()
        conect_data = ['CONECT', root]
        order_data = ['ORDER', root]
        itran_data = ['ITRAN', root] 
        numNeighbors = atom.numNeighbors()
        for j in range(numNeighbors):
            bond = atom.getNeighbor(j)
            conect_data.append(bond.getNeighborNumber())
            order_data.append(bond.getOrder())
            itran_data.append(bond.getItran())

        # write connection data
        if format:
            format_string = '%-6s' + '%6d' * (numNeighbors+1) + '\n'
        else:
            format_string = '%-6s ' + '%6d ' * (numNeighbors+1) + '\n'

        chunk = format_string % tuple(conect_data)
        newlines.append(chunk)

        # only write order data if bond orders are > 1
        for k in range(2,len(order_data)):
            if order_data[k] > 1:
                chunk = format_string % tuple(order_data)
                newlines.append(chunk)
                break

        # only write itran data if values are other than 222 and 0
        for k in range(2,len(itran_data)):
            if itran_data[k] != 222 and itran_data[k] != 0:
                chunk = format_string % tuple(itran_data)
                newlines.append(chunk)
                break

        i += 1
   
    chunk = "END\n"
    newlines.append(chunk)
   
    f = open(filepath,'w')
    f.writelines(newlines)
    f.close()
    return




    
def main():
    """
    This is serving as a test script for now.
    Usage: bgf_reader <bgf_file>
    """
    filepath = None
    try:
        filepath = sys.argv[1]
    except:
        print 'Usage: bgf_reader <input_bgf_file>'
        sys.exit()

    system = read(filepath, format=False)
    molecule = system.getMolecule(0)

    #formattedWrite(system, 'bgfio_out.bgf')
    write(system, 'bgfio_out.bgf', format=True)

    #print 'number of chains = ', molecule.numChains()

    atom = molecule.getAtomWithNumber(4)

    #residue = molecule.getResidue('LEU', 27, 'A')
    #residue.getAtomWithNumber(46)
    
    if atom:

        print 'x = ', atom.getX()
        print 'y = ', atom.getY()
        print 'z = ', atom.getZ()

        for i in range(atom.numNeighbors()):
            bond = atom.getNeighbor(i)
            print 'root = ', bond.getRootNumber()
            print 'neighbor = ', bond.getNeighborNumber()
            print 'bond order = ',bond.getOrder() 
            print 'fftype = ', atom.getFFType()
            print 'itran = ', bond.getItran()

        print 'element for atom %i is %s' % (atom.getNumber(), atom.getElement())
       


if __name__ == '__main__':
    main()


