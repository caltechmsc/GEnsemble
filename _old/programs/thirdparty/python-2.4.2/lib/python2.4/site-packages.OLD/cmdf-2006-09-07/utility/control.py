#!/usr/bin/env python
#############################################################################################
#                                                                                           #
#  Control class: control CMDF jobs by reading parameters from a keyword file and creating  #
#  objects needed in later calculations.                                                    #
#  The higher level GUI toolkits may be implemented in future.                              #
#                                                                                           #
#  Created on 03/10/06, last revision on 06/28/06. yi                                       #
#                                                                                           #
#############################################################################################
import sys
import numpy
import cmdf.utility.bgfio as bgfio
from cmdf.utility.unit import Unit
from cmdf.utility.utility_pf import Utility
from cmdf.utility.communication import systemToArrays, arraysToSystem_md, arraysToSystem_min
from cmdf.optimize.simulatedAnnealing import SimulatedAnnealing_MD, Sigmoid, Exponent, Linear  
from cmdf.optimize.conjugateGradient import ConjugateGradient_SP, ConjugateGradient_MEE
#from cmdf.optimize.minimize import ConjugateGradient_PR, BFGS, Newton_cg, Simplex, Powell
import cmdf.optimize.minimize as minimize
from cmdf.dynamics.integrator_pf import VelocityVerlet_f, LeapFrog, Beeman 
from cmdf.dynamics.thermostat_pf import BerendsenThermostat, AndersenThermostat, NoseHooverThermostat
from cmdf.dynamics.barostat_pf import BerendsenBarostat, AndersenHoover, ParrinelloRahmanHoover
from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3
from cmdf.dynamics.constraint import Rattle    
#from forceEngine import MasterForceEngine
from cmdf.mee.meeForceEngine import MeeForceEngine
from cmdf.mee.mpeForceEngine import MpeForceEngine
#from cmdf.reax.reaxForceEngine import ReaxForceEngine
import cmdf.mee.mee as mee

class Control:
    #printLevel = 1

    def __init__(self):
        #self.printLevel = 1

        return

    # Set up a system from structure file.
    def loadSystem(self, inputFileName):

        try:
            self.system = bgfio.read(inputFileName+'.bgf')
        except:
            print 'Error! loadSystem: Faild to read BGF input file.'
            sys.exit(1)

        self.sgName = self.system.getSgName()
        self.sgSymbol = self.system.getSgSymbol()
        self.sgNumber = self.system.getSgNumber()
        self.axes = str(self.system.getAxes())
        self.molecule = self.system.getMolecule(0)
        self.numAtoms = self.molecule.numAtoms()
        self.molName = self.molecule.getName()
        self.dim = self.molecule.getDimension()

        self.cellDim, self.elements, self.coords, self.vels, self.energy, self.forces,  \
         self.oldForces, self.imove, self.fixed, self.charges, self.masses, self.fftypes,  \
          self.bondlist, self.orderlist, self.itranlist = systemToArrays(self.system) 

        logFile = open(self.molName+'.log', 'a') 
        cmdfStr = '<<< Computational Materials Design Facility (CMDF) >>>\n'
        logFile.write('%65s' % (cmdfStr)) 
        logFile.write('=> Loading system completed.\n')
        logFile.close()

        return

    def writeSystem(self):
        #from utility_pf import Utility
        util = Utility()

        bgfio.write(self.system, self.molName+'_last.bgf')
        lastTrjFile = open(self.molName+'_last.xyz', 'w')
        util.outputTrjSys(self.molecule, lastTrjFile, self.numSteps)
        lastTrjFile.close()

        return

    # Setup a force engine.
    def setForceEngine(self, ForceEngine):
    #def setForceEngine(self, valenceForceEngine, coulombForceEngine, vdwForceEngine, solvationForceEngine):
        #from utility_pf import Utility
        util = Utility()

        """
        self.valenceForceEngine = valenceForceEngine(self.numAtoms) 
        self.coulombForceEngine = self.valenceForceEngine 
        self.vdwForceEngine = self.valenceForceEngine 
        self.solvationForceEngine = self.valenceForceEngine 
        self.forceEngine = MasterForceEngine(self.valenceForceEngine, self.coulombForceEngine, \
            self.vdwForceEngine, self.solvationForceEngine)
        self.forceEngine.setupEnergyExpression(self.molecule)
        self.forceEngine.downloadCoords(self.molecule)
        self.forceEngine.calcEnergyForce()
        self.forceEngine.uploadEnergyForce(self.molecule)
        print 'masterEnergy=', self.forceEngine.getEnergy()
        print 'masterForce =', self.forceEngine.getForces()
        logFile = open(self.molName+'.log', 'a') 
        logFile.write('=> Setup master force engine completed.\n')
        logFile.close()

        """
        if ForceEngine is MeeForceEngine:
            self.forceEngine = MeeForceEngine(self.numAtoms)
            self.forceEngine.setupEnergyExpression(self.coords, self.fixed, self.charges, self.fftypes, self.bondlist, self.orderlist)
            mee.cmdf_mee_current_energy()
            #self.forceEngine.setCoords(self.coords)
            #self.forceEngine.calcEnergyForce()
            #energy = self.forceEngine.getEnergy()
            #forces = self.forceEngine.getForces()
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)

            print 'Initial MEE energy (eV)   =', energy
            print 'Initial MEE forces (eV)/A =', forces

            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup MEE force engine completed.\n')
            logFile.close()

        elif ForceEngine is MpeForceEngine:
            self.forceEngine = MpeForceEngine(self.numAtoms, self.cellDim, self.sgName, self.sgSymbol, self.sgNumber, self.axes)
            self.forceEngine.setupEnergyExpression(self.coords, self.fixed, self.charges, self.fftypes, self.bondlist,  \
                self.orderlist, self.itranlist)
            ### Need check out if this is MPE current energy or MEE energy.
            mee.cmdf_mee_current_energy()
            #self.forceEngine.setCoords(self.coords)
            #self.forceEngine.calcEnergyForce()
            #energy = self.forceEngine.getEnergy()
            #forces = self.forceEngine.getForces()
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)

            print 'Initial MPE energy (eV)   =', energy
            print 'Initial MPE forces (eV)/A =', forces

            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup MPE force engine completed.\n')
            logFile.close()

        elif ForceEngine is ReaxForceEngine:
            reaxFFName = util.searchFileName('reaxForceField')
            self.forceEngine = ReaxForceEngine(self.numAtoms, reaxFFName)
            self.forceEngine.readForceFieldFile(reaxFFName)

            self.forceEngine.setupEnergyExpression(coords, fixed, charges, fftypes, blist, bolist)
            self.forceEngine.setCoords(coords)
            self.forceEngine.calcEnergyForce()
            print 'Initial Reax energy =', self.forceEngine.getEnergy()
            print 'Initial Reax force =', self.forceEngine.getForces()
            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup Reax force engine completed.\n')
            logFile.close()

        return

    def setParameters(self, system):
        #from utility_pf import Utility
        util = Utility()

        try:
            cmdfKeyFileName = util.searchFileName('cmdf/cmdf.key')
            cmdfKeyFile = open(cmdfKeyFileName, 'r')
            self.readKey(system, cmdfKeyFile)         # Setup parameters and objects from default CMDF keyword file.
        except:
            errFile = open(self.molName+'.err', 'a')
            errFile.write('Error! readKey: Failed to read CMDF keyword file (cmdf.key). \n')
            errFile.close()
            sys.exit(1)

        try:
            userKeyFile = open(self.molName+'.key', 'r')
            self.readKey(system, userKeyFile)         # Setup parameters and objects from user keyword file.
        except:
            logFile = open(self.molName+'.log', 'a')
            logFile.write('Warning! readKey: Failed to read user keyword file. The default cmdf.key is used.\n')
            logFile.close()

        self.writeKey()  # Write parameters to log file.
        self.createObjects()  # Create objects.

        return

    # Read parameters from the keyword file. 
    def readKey(self, system, keyFile):
        #from unit import Unit
        #from utility_pf import Utility
        UNIT = Unit()
        util = Utility()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        self.numRattle = 0
        self.constraintRattle = []
        #self.translateVector = (0.,) * 3 
        self.translateVector = numpy.zeros([3], numpy.Float32)
        self.minimizer = None
        self.integrator = None
        self.thermostat = None
        self.barostat = None
        self.constrain = None
        self.gaussian = None
        for line in keyFile.readlines():
            if line.find('#') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'md':
                        self.task = fields[1]
                    elif fields[1] == 'minimize':
                        self.task = fields[1]
                    else:  # Default task.
                        self.task = 'md'
                else:  # Default task.
                    self.task = 'md'
                continue

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                        system.setPeriodic(0) 
                    elif fields[1] == 'mpe':
                        self.forceEngine = MpeForceEngine
                        system.setPeriodic(1) 
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                        system.setPeriodic(1) 
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                        system.setPeriodic(0) 
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                    system.setPeriodic(0) 
                continue

            """
            if line.find('ENERGY_VALENCE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.valenceForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.valenceForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.valenceForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_COULOMB') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.coulombForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.coulombForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.coulombForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_VDW') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.vdwForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.vdwForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.vdwForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_SOLVATION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.solvationForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.solvationForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.solvationForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_RESTRAINT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.restraintForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.restraintForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.restraintForceEngine = MeeForceEngine
                continue
            """

            if line.find('TIME_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.timeStep = float(fields[1]) * UNIT.ps
                continue

            if line.find('NUM_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numSteps = int(fields[1])
                continue

            if line.find('EQU_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.equSteps = int(fields[1])
                continue

            if line.find('FREQ_OUTPUT_MD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqOutputMD = int(fields[1])
                continue

            if line.find('FREQ_OUTPUT_TRJ') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqOutputTrj = int(fields[1])
                continue

            if line.find('INIT_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.initTemp = float(fields[1]) * UNIT.K
                continue

            if line.find('TARGET_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.targetTemp = float(fields[1]) * UNIT.K
                continue

            if line.find('TARGET_PRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.targetPress = float(fields[1]) * UNIT.GPa
                continue

            if line.find('TAU_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.tauTemp = float(fields[1]) * UNIT.ps
                continue

            if line.find('TAU_PRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.tauPress = float(fields[1]) * UNIT.ps
                continue

            if line.find('NIU_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.niuTemp = float(fields[1])
                continue

            if line.find('COMPRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.compress = float(fields[1]) / UNIT.GPa
                continue

            if line.find('FREQ_NOSE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqNose = float(fields[1]) * UNIT.THz
                continue

            if line.find('NUM_NOSE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numNose = int(fields[1])
                continue

            if line.find('NUM_SUZ') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numSuz = int(fields[1])
                continue

            if line.find('THRESHOLD_FORCE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.threshold = float(fields[1]) * UNIT.kcalpermol
                continue

            if line.find('THRESHOLD_COORD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.xthreshold = float(fields[1]) * UNIT.Ang
                continue

            if line.find('THRESHOLD_ENERGY') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fthreshold = float(fields[1]) * UNIT.kcalpermol
                continue

            if line.find('MAX_ITERATION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.maxiteration = int(fields[1]) 
                continue

            if line.find('MAX_FUNCTION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.maxfunction = int(fields[1]) 
                continue

            if line.find('GAUSSIAN') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == '1':
                        self.gaussian = Gaussian1
                    elif fields[1] == '2':
                        self.gaussian = Gaussian2 
                    elif fields[1] == '3':
                        self.gaussian = Gaussian3
                    else:  # Default Gaussian.
                        self.gaussian = Gaussian3
                continue

            if line.find('COOL_SCHEDULE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'linear':
                        self.coolSchedule = Linear
                    elif fields[1] == 'exponent':
                        self.coolSchedule = Exponent
                    elif fields[1] == 'sigmoid':
                        self.coolSchedule = Sigmoid 
                    else:  # Default cooling schedule.
                        self.coolSchedule = Linear
                continue

            if line.find('FIX_ATOMS') == 0:
                fields = line.split()
                for iatom in range(1, len(fields)): 
                    fixedAtom = molecule.getAtomWithNumber(int(fields[iatom]))
                    fixedAtom.setFixed()
                continue

            if line.find('FIX_RANGE') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    fixedStart = int(fields[1])
                    fixedEnd = int(fields[2])
                    for iatom in range(fixedStart, fixedEnd+1): 
                        fixedAtom = molecule.getAtomWithNumber(iatom)
                        fixedAtom.setFixed()
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: fixed atom range not complete.') 
                    errFile.close()
                continue

            if line.find('CONSTRAINT_METHOD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'rattle':
                        self.constrain = Rattle
                continue

            if line.find('RATTLE_DISTANCE') == 0 and self.constrain is Rattle:
                fields = line.split()
                if len(fields) >= 4:
                    self.constraintRattle.append   \
                        ((int(fields[1]), int(fields[2]), float(fields[3]) * UNIT.Ang)) 
                    self.numRattle += 1
                elif len(fields) == 3:  # Original distance is used as a constraint if L12 is blank.
                    dist12 = util.calcDistance(molecule, int(fields[1]), int(fields[2]))
                    self.constraintRattle.append   \
                        ((int(fields[1]), int(fields[2]), dist12 * UNIT.Ang)) 
                    self.numRattle += 1
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: skip as constraint information not complete.') 
                    errFile.close()
                continue

            if line.find('TRANSLATE_VECTOR') == 0:
                fields = line.split()
                if len(fields) >= 4:
                    self.translateVector = (float(fields[1]), float(fields[2]), float(fields[3]))
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: translation vector not complete.') 
                    errFile.close()
                continue

            if line.find('TRANSLATE_ATOMS') == 0:
                fields = line.split()
                for iatom in range(1, len(fields)): 
                    transAtom = molecule.getAtomWithNumber(int(fields[iatom]))
                    transAtom.setIgnored()
                continue

            if line.find('TRANSLATE_RANGE') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    transStart = int(fields[1])
                    transEnd = int(fields[2])
                    for iatom in range(transStart, transEnd+1): 
                        transAtom = molecule.getAtomWithNumber(iatom)
                        transAtom.setIgnored()
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: translation atom range not complete.') 
                    errFile.close()
                continue

            if line.find('SUMFORCE_RANGE_Z') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    self.sumForceMinZ = float(fields[1])
                    self.sumForceMaxZ = float(fields[2])
                continue

            if line.find('THERMOSTAT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'berendsen':
                        #self.thermostat = BerendsenThermostat(self.targetTemp, self.timeStep, self.tauTemp, self.masses)
                        self.thermoStr = 'Berendsen'
                    elif fields[1] == 'andersen':
                        #self.thermostat = AndersenThermostat(self.targetTemp, self.timeStep, self.niuTemp,  \
                        #                                        self.gaussian, self.imove, self.masses)
                        self.thermoStr = 'Andersen'
                    elif fields[1] == 'nose-hoover':
                        #self.thermostat = NoseHooverThermostat(self.molName, self.targetTemp, self.timeStep, self.numNose,  \
                        #                                        self.freqNose, self.numSuz, self.masses)
                        self.thermoStr = 'Nose-Hoover'
                    else:  # Default thermostat.
                        #self.thermostat = None             
                        self.thermoStr = 'None'
                continue

            if line.find('BAROSTAT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'berendsen':
                        #self.barostat = BerendsenBarostat(self.targetPress, self.timeStep, self.tauPress,  \
                        #                                 self.compress, self.masses)
                        self.baroStr = 'Berendsen'
                    elif fields[1] == 'andersen-hoover':
                        #self.barostat = None    # Switch off explicit thermostat and barostat,
                        #self.thermostat = None  # and will use implicit thermostat/barostat embeded in VVAH integrator.
                        self.thermoStr = 'Hoover'
                        self.baroStr = 'Andersen'
                    elif fields[1] == 'parrinello-rahman-hoover':
                        #self.thermostat = None  # Switch off explicit thermostat and barostat,
                        #self.barostat = None    # and will use implicit thermostat/barostat embeded in VVPRH integrator.
                        self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
                        self.thermoStr = 'Hoover'
                        self.baroStr = 'Parrinello-Rahman'
                    else:  # Default barostat.
                        #self.barostat = None
                        self.baroStr = 'None'
                continue

            if line.find('INTEGRATOR') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'beeman':
                        #self.integrator = Beeman(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Beeman'
                    elif fields[1] == 'verlet':
                        #self.integrator = VelocityVerlet(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Velocity Verlet'
                    elif fields[1] == 'verlet_f':
                        #self.integrator = integrator_pf.VelocityVerlet_f(self.molName, self.timeStep, self.translateVector,  \
                        #                    self.imove, self.masses)
                        self.integraStr = 'Velocity Verlet_f'
                    elif fields[1] == 'leap-frog':
                        #self.integrator = LeapFrog(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Leap Frog'
                    elif fields[1] == 'vv-ah-NPT':
                        #self.integrator = VelocityVerletAH(system, self.targetPress,  \
                        #   self.targetTemp, self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.masses) 
                        self.integraStr = 'modified Velocity Verlet for Andersen-Hoover NPT dynamics'
                    elif fields[1] == 'vv-prh-NPT':
                        #self.integrator = VelocityVerletPRH(system, self.targetPress, self.targetTemp,  \
                        #                     self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.imove, self.masses)
                        self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
                    else:  # Default integrator.
                        #self.integrator = None 
                        self.integraStr = 'None'
                continue
        
            if line.find('MINIMIZER') == 0:
                if self.task == 'md': self.miniStr = 'None'; continue
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'cg_sp':
                        #self.nMethod = 0
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'Conjugate Gradient (Shanno-Phua)'
                    elif fields[1] == 'bfgs_sp':
                        #self.nMethod = 1
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'BFGS (Shanno-Phua)'
                    elif fields[1] == 'cg_mee':
                        #self.minimizer = ConjugateGradient_MEE(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)
                        self.miniStr = 'Conjugate Gradient in MEE'
                    elif fields[1] == 'cg_fr':  # Not working for array.
                        #self.nMethod = 0
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_FR(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'Conjugate Gradient (Fletcher-Reeves)'
                    elif fields[1] == 'sa':
                        #self.minimizer = SimulatedAnnealing_MD(self.coolSchedule, self.integrator, self.thermostat,  \
                        #                    self.barostat, self.gaussian, self.initTemp, self.targetTemp,  \
                        #                    self.numSteps, self.equSteps, self.timeStep,  \
                        #                    self.threshold, self.freqOutputMD, self.freqOutputTrj,  \
                        #                    self.cellDim, self.coords, self.vels, self.forces) 
                        self.miniStr = 'Simulated Annealing via MD'
                    elif fields[1] == 'simplex':
                        self.miniStr = 'Simplex'
                    elif fields[1] == 'powell':
                        self.miniStr = 'Powell'
                    elif fields[1] == 'cg_pr':
                        self.miniStr = 'Conjugate Gradient (Polak-Ribiere)'
                    elif fields[1] == 'bfgs':
                        self.miniStr = 'BFGS'
                    elif fields[1] == 'newton_cg':
                        self.miniStr = 'Newton CG'
                    else:  # Default minimizer.
                        #self.minimizer = None 
                        self.miniStr = 'None'
                continue
        
            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = UNIT.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = UNIT.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = UNIT.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = UNIT.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = UNIT.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = UNIT.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = UNIT.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = UNIT.bar
                        self.printPressureFlag = 'Bar'
                continue

        if self.numRattle == 0:  # No leagal constraints found.
            self.constrain = None
        else:
            self.constrain = Rattle
        self.numConstraints = self.numRattle

        self.numAtoms = molecule.numAtoms()
        self.numAtoms1 = self.numAtoms + 1
        self.numMovableAtoms = molecule.numMovableAtoms()
        self.numFixedAtoms = molecule.numFixedAtoms()
        self.numIgnoredAtoms = molecule.numIgnoredAtoms()
        # The following is done in data model as above.
        """
        self.numMovableAtoms = 0 
        self.numFixedAtoms = 0 
        self.numIgnoredAtoms = 0 
        for i in range(1, self.numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() == 1: 
                self.numMovableAtoms += 1
            elif atom.isFixed() == 1:
                self.numFixedAtoms += 1
            elif atom.isIgnored() == 1:
                self.numIgnoredAtoms += 1 
        """
        self.numForceAtoms = self.numMovableAtoms + self.numFixedAtoms
        totalNumAtoms = self.numForceAtoms + self.numIgnoredAtoms
        if self.numAtoms != totalNumAtoms:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! setParameter: Number of atoms not consistent.') 
            errFile.close()
        # Compute degree of freedom.
        if self.task == 'minimize':
            # DOF = 3 * Nmove if do minimization.
            self.degFree = 3 * self.numMovableAtoms
        elif self.task == 'md':
            if isinstance(self.thermostat, AndersenThermostat):
                self.degFree = 3 * self.numMovableAtoms - self.numConstraints
            else:
                if system.isPeriodic() == 0:  # Non-periodic
                    self.degFree = 3 * self.numMovableAtoms - 6 - self.numConstraints
                elif system.isPeriodic() != 0:  # Periodic
                    #self.degFree = 3 * self.numMovableAtoms - 3 - self.numConstraints 
                    self.degFree = 3 * self.numMovableAtoms - self.numConstraints 
            if self.numFixedAtoms == 1:  # Single fixed atom.
                self.degFree = self.degFree - 3
        molecule.setDegFree(int(self.degFree))

        self.isPeriodic = system.isPeriodic()

        Control.printLevel = self.printLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag
        Control.sumForceMinZ = self.sumForceMinZ
        Control.sumForceMaxZ = self.sumForceMaxZ

        return

    def writeKey(self):
    	"""
    	Write parameters to log file.
    	"""
        unit = Unit()

        if self.printLevel > 0:
            logFile = open(self.molName+'.log', 'a') 

            if self.task == 'md':
                logFile.write('Task type              : Molecular dynamics\n')
            elif self.task == 'minimize':
                logFile.write('Task type              : Minimization\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine           : MEE (non-peridoic DREIDING force field)\n')
            elif self.forceEngine is MpeForceEngine:
                logFile.write('Force engine           : MPE (peridoic DREIDING force field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine           : ReaxFF \n')
            if self.isPeriodic == 0:
                logFile.write('Periodic boundary cond.: Non-periodic \n')
            else:   
                logFile.write('Periodic boundary cond.: Periodic \n')
            #if self.valenceForceEngine is MeeForceEngine:
            #    logFile.write('Valence Force engine   : MEE (Dreiding Force Field)\n')
            #elif self.valenceforceEngine is ReaxForceEngine:
            #    logFile.write('Valence Force engine   : Reax Force Field\n')
            #if self.coulombForceEngine is MeeForceEngine:
            #    logFile.write('Coulomb Force engine   : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('Coulomb Force engine   : Reax Force Field\n')
            #if self.vdwForceEngine is MeeForceEngine:
            #    logFile.write('vdW Force engine       : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('vdW Force engine       : Reax Force Field\n')
            #if self.solvationForceEngine is MeeForceEngine:
            #    logFile.write('Solvation Force engine : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('Solvation Force engine : Reax Force Field\n')
            logFile.write('System name            : '+self.molName+'\n')
            logFile.write('Unit cell dimension    : '+str(self.cellDim)+'\n')
            logFile.write('Number of atoms        : '+str(self.numAtoms)+'\n')
            logFile.write('Number of movable atoms: '+str(self.numMovableAtoms)+'\n')
            logFile.write('Number of fixed atoms  : '+str(self.numFixedAtoms)+'\n')
            logFile.write('Number of ignored atoms: '+str(self.numIgnoredAtoms)+'\n')
            logFile.write('Degree of freedom      : '+str(self.degFree)+'\n')
            if self.constrain == Rattle:
                logFile.write('Constraint             : RATTLE\n')
                str1 = 'Number of constraints  : '+str(self.numRattle)+'\n'
                logFile.write(str1) 
                if self.printLevel > 1:
                    for i in range(self.numRattle):
                        str2 = 'Distance constraint '+str(i+1)+'  : '+str(self.constraintRattle[i])+'\n'
                        logFile.write(str2)
            logFile.write('Translation vector     : ' +str(float(self.translateVector[0])) \
                                                      + ', ' +str(float(self.translateVector[1])) \
                                                      + ', ' +str(float(self.translateVector[2]))+'\n')
            logFile.write('Minimizer              : '+self.miniStr+'\n') 
            logFile.write('Integrator             : '+self.integraStr+'\n') 
            logFile.write('Thermostat             : '+self.thermoStr+'\n') 
            logFile.write('Barostat               : '+self.baroStr+'\n') 
            if self.gaussian is Gaussian1:
                logFile.write('Gaussian               : Gaussian1\n')
            elif self.gaussian is Gaussian2:
                logFile.write('Gaussian               : Gaussian2\n')
            elif self.gaussian is Gaussian3:
                logFile.write('Gaussian               : Gaussian3\n')
            if self.coolSchedule is Linear:
                logFile.write('Cooling schedule       : Linear\n')
            elif self.coolSchedule is Exponent:
                logFile.write('Cooling schedule       : Exponent\n')
            elif self.coolSchedule is Sigmoid:
                logFile.write('Cooling schedule       : Sigmoid\n')
            logFile.write('Time step (ps)         : '+str(self.timeStep/unit.ps)+'\n') 
            logFile.write('Number of steps        : '+str(self.numSteps)+'\n') 
            logFile.write('Maximal iterations(Min): '+str(self.maxiteration)+'\n') 
            logFile.write('Maximal func_calls(Min): '+str(self.maxfunction)+'\n') 
            logFile.write('RMS Force threshold,Min: '+str(self.threshold/unit.kcalpermol)+'\n') 
            logFile.write('RMS Coord threshold,Min: '+str(self.xthreshold/unit.Ang)+'\n') 
            logFile.write('Diff. Eng threshold,Min: '+str(self.fthreshold/unit.kcalpermol)+'\n') 
            logFile.write('Output interval(MD,Min): '+str(self.freqOutputMD)+'\n') 
            logFile.write('Output interval(Trj)   : '+str(self.freqOutputTrj)+'\n') 
            logFile.write('Initial temperature (K): '+str(self.initTemp/unit.K)+'\n') 
            logFile.write('Target temperature (K) : '+str(self.targetTemp/unit.K)+'\n') 
            logFile.write('Target pressure (GPa)  : '+str(self.targetPress/unit.GPa)+'\n') 
            logFile.write('Output energy unit     : '+self.printEnergyFlag+'\n') 
            logFile.write('Output pressure unit   : '+self.printPressureFlag+'\n') 
            if self.printLevel == 1:
                logFile.write('Print level            : '+'Normal\n')
            elif self.printLevel == 2:
                logFile.write('Print level            : '+'Verbose\n')
            elif self.printLevel == 3:
                logFile.write('Print level            : '+'Debug\n')

            logFile.write('=> Loading parameters and setup completed.\n') 

            logFile.close()

        return

    def createObjects(self):
    	"""
    	Create instance objects.
    	"""
        unit = Unit()

        # Create thermostat.	
        if self.thermoStr == 'Berendsen':
            self.thermostat = BerendsenThermostat(self.targetTemp, self.timeStep, self.tauTemp, self.masses)
        elif self.thermoStr == 'Andersen':
            self.thermostat = AndersenThermostat(self.targetTemp, self.timeStep, self.niuTemp,  \
                                                            self.gaussian, self.imove, self.masses)
        elif self.thermoStr == 'Nose-Hoover':
            self.thermostat = NoseHooverThermostat(self.molName, self.targetTemp, self.timeStep, self.numNose,  \
                                                                self.freqNose, self.numSuz, self.masses)
        else: 
            self.thermostat = None             

        # Create barostat.	
        if self.baroStr == 'Berendsen':
            self.barostat = BerendsenBarostat(self.targetPress, self.timeStep, self.tauPress,  \
                                                     self.compress, self.masses)
        elif self.thermoStr == 'Hoover' and self.baroStr == 'Andersen':
            self.barostat = None    # Switch off explicit thermostat and barostat,
            self.thermostat = None  # and will use implicit thermostat/barostat embeded in VVAH integrator.
        elif self.thermoStr == 'Hoover' and self.baroStr == 'Parrinello-Rahman':
            self.thermostat = None  # Switch off explicit thermostat and barostat,
            self.barostat = None    # and will use implicit thermostat/barostat embeded in VVPRH integrator.
            self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
        elif self.baroStr == 'None': # Default barostat.
            self.barostat = None

        # Create integrator. 	
        if self.integraStr == 'Beeman': 
            self.integrator = Beeman(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'Velocity Verlet':
            self.integrator = VelocityVerlet(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'Velocity Verlet_f':
            self.integrator = VelocityVerlet_f(self.molName, self.timeStep, self.translateVector,  \
                                        self.imove, self.masses)
        elif self.integraStr == 'Leap Frog': 
            self.integrator = LeapFrog(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'modified Velocity Verlet for Andersen-Hoover NPT dynamics':
            self.integrator = VelocityVerletAH(system, self.targetPress,  \
                     self.targetTemp, self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.masses) 
        elif self.integraStr == 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics':
            self.integrator = VelocityVerletPRH(system, self.targetPress, self.targetTemp,  \
                     self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.imove, self.masses)
        else:  
            self.integrator = None 
        
        # Create minimizer. 	
        if self.miniStr == 'Conjugate Gradient (Shanno-Phua)':
            self.nMethod = 0
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.maxfunction, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'BFGS (Shanno-Phua)':
            self.nMethod = 1
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.maxfunction, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'Conjugate Gradient in MEE':
            # Note MEE CG uses energy unit of kcal/mol.
            threshold = self.threshold / unit.kcalpermol
            self.minimizer = ConjugateGradient_MEE(self.maxiteration, threshold)
        elif self.miniStr == 'Conjugate Gradient (Fletcher-Reeves)':
            #self.nMethod = 0
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_FR(self.molName, self.nMethod, self.maxiteration, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'Simulated Annealing via MD':
            self.minimizer = SimulatedAnnealing_MD(self.coolSchedule, self.integrator, self.thermostat,  \
                                    self.barostat, self.gaussian, self.initTemp, self.targetTemp,  \
                                    self.numSteps, self.equSteps, self.timeStep,  \
                                    self.threshold, self.freqOutputMD, self.freqOutputTrj,  \
                                    self.masses) 
        elif self.miniStr == 'Simplex':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Simplex(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Powell':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Powell(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Conjugate Gradient (Polak-Ribiere)':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.ConjugateGradient_PR(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'BFGS':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.BFGS(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Newton CG':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Newton_CG(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        else: 
            self.minimizer = None 

        logFile = open(self.molName+'.log', 'a')
        logFile.write('=> Creating objects completed.\n') 
        logFile.close()

        return

    # Read parameters from the .ana file. 
    def readAna(self, system):
        #from unit import Unit
        unit = Unit()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        try:
            anaFile = open(molName+'.ana', 'r')
        except:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! readAnaly: Failed to open .ana file.') 
            errFile.close()
            return

        self.forceEngine = None
        for line in anaFile.readlines():
            if line.find('#') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'force_check':
                        self.task = fields[1]
                    elif fields[1] == 'rdf':
                        self.task = fields[1]
                    else:  # Default task.
                        self.task = 'force_check'

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                continue

            if line.find('FORCE_CHECK_DELTA') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcDelta = float(fields[1]) * unit.Ang
                continue

            if line.find('FORCE_CHECK_MAXNUM') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcMaxNum = int(fields[1]) 
                continue

            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = unit.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = unit.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = unit.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = unit.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = unit.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = unit.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = unit.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = unit.bar
                        self.printPressureFlag = 'Bar'
                continue

        if self.printLevel > 0:
            logFile = open(molName+'.log', 'a') 
            if self.task == 'force_check':
                logFile.write('Task type              : Force check (finite difference method)\n')
            elif self.task == 'rdf':
                logFile.write('Task type              : Radial distribution function\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine           : MEE (Dreiding Force Field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine           : Reax Force Field\n')

            logFile.close()

        Control.printLevel = self.printLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag

        return

    # Set parameters from the .dbg file. 
    def readDbg(self, system):
        #from unit import Unit
        unit = Unit()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        try:
            anaFile = open(molName+'.dbg', 'r')
        except:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! readDbg: Failed to open .dbg file.') 
            errFile.close()
            return

        self.forceEngine = None
        for line in anaFile.readlines():
            if line.find('#') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'force_check':
                        self.task = fields[1]
                    #elif fields[1] == 'rdf':
                    #    self.task = fields[1]
                    else:  # Default task.
                        self.task = 'force_check'

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                continue

            if line.find('FORCE_CHECK_DELTA') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcDelta = float(fields[1]) * unit.Ang
                continue

            if line.find('FORCE_CHECK_MAXNUM') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcMaxNum = int(fields[1]) 
                continue

            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = unit.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = unit.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = unit.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = unit.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = unit.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = unit.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = unit.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = unit.bar
                        self.printPressureFlag = 'Bar'
                continue

        if self.printLevel > 0:
            logFile = open(molName+'.log', 'a') 
            if self.task == 'force_check':
                logFile.write('Task type              : Force check (finite difference method)\n')
            #elif self.task == 'rdf':
            #    logFile.write('Task type              : Radial distribution function\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine           : MEE (Dreiding Force Field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine           : Reax Force Field\n')

            logFile.close()

        Control.printLevel = self.printLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag

        return

