####################################################################################
#                                                                                  #
# Integrator class contains methods used for integrating MD trajectory.            #
#                                                                                  #
# beeman            : modified Beeman algorithm                                    #
# velocityVerlet    : Velocity version of Verlet algorithm                         #
# velocityVerletAH  : modified Velocity version of Verlet algorithm                #
# velocityVerletPRH : modified Velocity version of Verlet algorithm                #
# leapFrog          : Leap Frog algorithm                                          #
#                                                                                  #
# Created on 02/07/06, last revision on 04/02/06. yi                               #
#                                                                                  #
####################################################################################

import numpy 
#from cmdf.utility.lapy import LaPy
#from cmdf.utility.utility_pf import Utility
from cmdf.dynamics.barostat_pf import BerendsenBarostat
from cmdf.dynamics.constraint import Constraint 
from cmdf.dynamics.integrator_f import verlet1, verlet2 

class Integrator:

    def __init__(self, timeStep=0.1):
        self.timeStep = timeStep

        return

    def initialize(self, system):

        return

    def run(self, system, forceEngine):

        return

class VelocityVerlet(Integrator):

    def __init__(self, system, timeStep=0.1, constrain=None, numRattle=0, constraintRattle=None, translateVector=(0.,)*3):
        Integrator.__init__(self, timeStep) 
        self.constrain = constrain
        self.numRattle = numRattle
        self.constraintRattle = constraintRattle
        if self.constraintRattle is None:
            self.constraintRattle = []
        if (self.constrain is Rattle): 
            self.Rattle = Rattle(self.timeStep, self.numRattle, self.constraintRattle)
        self.translateVector = translateVector

        molecule = system.getMolecule(0)
        self.molName = molecule.getName()
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%22s <<< CMDF Molecular Dynamics via Velocity Verlet integration >>>\n" % (' '))
        MDoutput.close()

        return

    def initialize(self, system):

        return

    def run(self, system, forceEngine):
#
#        Velocity verlet algorithm: 
#        
#        (1) Update velocity: v(t + dt/2) = v(t) + f(t) * dt / (2 * m)   
#            Update position: r(t + dt) = r(t) + v(t + dt/2) * dt    
#    
#        (2) Compute the new forces from the new positions r(t + dt).
#    
#        (3) Update velocity: v(t + dt) = v(t + dt/2) + f(t + dt) * dt/ (2 * m)  
#           
        translateVector = self.translateVector
        dt = self.timeStep
        dtHalf = dt * 0.5
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms() 

        mass = [0.] * numAtoms
        xold = [0.] * numAtoms; yold = [0.] * numAtoms; zold = [0.] * numAtoms
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                if atom.isIgnored() == 1:
                    rx = atom.getX() + translateVector[0]
                    ry = atom.getY() + translateVector[1]
                    rz = atom.getZ() + translateVector[2]
                    atom.setPosition(rx, ry, rz)
                continue
            mass[i] = atom.getAtomicMass()
    
            xold[i] = atom.getX()
            yold[i] = atom.getY()
            zold[i] = atom.getZ()
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            # Update velocities: v(t + dt/2) = v(t) + f(t) * dt / (2 * m)   
            vx = vx + fx * dtHalf / mass[i]
            vy = vy + fy * dtHalf / mass[i]
            vz = vz + fz * dtHalf / mass[i]

            # Update positions: r(t + dt) = r(t) + v(t + dt/2) * dt    
            x = xold[i] + vx * dt  
            y = yold[i] + vy * dt 
            z = zold[i] + vz * dt  

#            Remove PBC in dynamics to get unfolded trajectory
#            x = x - cellx * round(x / cellx) 
#            y = y - celly * round(y / celly) 
#            z = z - cellz * round(z / cellz) 
#
            atom.setPosition(x, y, z)
            atom.setVelocity(vx, vy, vz)
        
        # Correct positions and half-step velocities due to constraints.
        if (self.constrain is Rattle): 
            niter = self.Rattle.run1(molecule, xold, yold, zold)

        # Compute the new forces from the new positions r(t + dt).
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)

        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue
    
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()
    
        # Update velocity: v(t + dt) = v(t + dt/2) + f(t + dt) * dt / (2 * m)  
            vx = vx + fx * dtHalf / mass[i]
            vy = vy + fy * dtHalf / mass[i]
            vz = vz + fz * dtHalf / mass[i]

            atom.setVelocity(vx, vy, vz)

        # Correct full-step velocities due to constraints.
        if (self.constrain is Rattle): 
            niter = self.Rattle.run2(molecule)
            from control import Control
            if Control.printLevel > 2:
                from utility import Utility
                UTI = Utility()
                logFile = open(molecule.getName()+'.log', 'a')
                logFile.write('rattle2: NumIteration = '+str(niter)+'\n')
                for i in range(self.numRattle):
                    numA = self.constraintRattle[i][0]
                    numB = self.constraintRattle[i][1]
                    logFile.write('DistanceAB = '+str(numA)+' '+str(numB)+' '+  \
                        str(UTI.calcDistance(molecule, numA, numB))+'\n')

        return   

class VelocityVerlet_f(Integrator):

    def __init__(self, molName="cmdf", timeStep=0.1, translateVector=numpy.zeros([3], numpy.Float),  \
                imove=numpy.zeros([1], numpy.Int), masses=numpy.ones([1], numpy.Float)):
        Integrator.__init__(self, timeStep) 
        self.translateVector = translateVector
        self.imove = imove
        self.masses = masses

        self.molName = molName
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%22s <<< CMDF Molecular Dynamics via Velocity Verlet integration >>>\n" % (' '))
        MDoutput.close()

        return

    def initialize(self, system):

        return

    def run(self, forceEngine, r, v, f):
        dt = self.timeStep
        trans = self.translateVector
        imove = self.imove
        masses = self.masses
        rold = r.copy()
        r, rold, v = verlet1(dt, trans, imove, masses, r, rold, v, f)
        #forceEngine.setCoords(r)
        #forceEngine.calcEnergyForce()
        #f = forceEngine.getForces()
        #energy = forceEngine.getEnergy()
        energy, f = forceEngine.calcEnergyForce(r)
        v = verlet2(dt, imove, masses, v, f)

        return r, v, energy, f

class LeapFrog(Integrator):

    def __init__(self, system, timeStep=0.1, constrain=None, numRattle=0, constraintRattle=None, translateVector=(0.,)*3):
        Integrator.__init__(self, timeStep) 
        self.constrain = constrain
        self.numRattle = numRattle
        self.constraintRattle = constraintRattle
        if self.constraintRattle is None:
            self.constraintRattle = []
        if (self.constrain is Rattle): 
            self.Rattle = Rattle(self.timeStep, self.numRattle, self.constraintRattle)
        self.translateVector = translateVector

        molecule = system.getMolecule(0)
        self.molName = molecule.getName()
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%22s <<< CMDF Molecular Dynamics via Leap Frog integration >>>\n" % (' '))
        MDoutput.close()

        return
       
    def initialize(self, system):
        """
        v(dt/2) = v(0) + (dt/2)*a(0)
        """
        dt = self.timeStep
        dtHalf = dt * 0.5
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue
            mass = atom.getAtomicMass()
    
            # get v(0)
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            # get a(0) from f(0)
            ax = atom.getForceX() / mass
            ay = atom.getForceY() / mass
            az = atom.getForceZ() / mass
    
            vxnew = vx + dtHalf * ax
            vynew = vy + dtHalf * ay
            vznew = vz + dtHalf * az
    
            # Set velocities at dt/2.
            atom.setVelocity(vxnew, vynew, vznew)
    
            # get position at t(0)
            x  = atom.getX()
            y  = atom.getY()
            z  = atom.getZ()
    
            # propagate position to t(0+dt)
            xnew  = x + dt * vxnew 
            ynew  = y + dt * vynew 
            znew  = z + dt * vznew 
    
            # update position to r(0+dt)
            atom.setPosition(xnew, ynew, znew)
    
        return
    
    #standard leap frog verlet integration.  uses velocities at 1/2 steps
    #to give positions at full steps. method is described in 
    #feynman lectures vol 1, sec 9-6

    def run(self, system, forceEngine):
#           
#        x(t + dt) = x(t) + dt*v(t+dt/2)
#        v(t + dt/2) = v(t - dt/2) + dt*a(t)
#        a(t) = f(t)/m
#           
        translateVector = self.translateVector
        dt = self.timeStep
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()

        # Compute forces at t.
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)
        molecule.setOldPotentialEnergy(molecule.getPotentialEnergy())
    
        #ke = 0.
        xold = [0.] * numAtoms; yold = [0.] * numAtoms; zold = [0.] * numAtoms
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                if atom.isIgnored() == 1:
                    rx = atom.getX() + translateVector[0]
                    ry = atom.getY() + translateVector[1]
                    rz = atom.getZ() + translateVector[2]
                    atom.setPosition(rx, ry, rz)
                continue
            mass = atom.getAtomicMass()
    
            #get x(t)
            xold[i] = atom.getX()
            yold[i] = atom.getY()
            zold[i] = atom.getZ()
    
            #get v(t-dt/2)
            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()
    
            #get a(t) from f(t)
            ax = atom.getForceX() / mass
            ay = atom.getForceY() / mass
            az = atom.getForceZ() / mass
    
            #calc v(t + dt/2) from above
            vxnew = vx + dt * ax
            vynew = vy + dt * ay
            vznew = vz + dt * az
    
            #now calc x(t+dt)
            xnew = xold[i] + dt * vxnew
            ynew = yold[i] + dt * vynew
            znew = zold[i] + dt * vznew
    
            # Compute average velocity at t.
            vxt = 0.5 * (vx + vxnew)
            vyt = 0.5 * (vy + vynew)
            vzt = 0.5 * (vz + vznew)
            # Set new positions at t+dt, new velocities at t+dt/2,
            # old velocities at t. Note that position and velocity 
            # are not synchronized. Output OldVelocity and OldPotentialEnergy in dyn file.
            atom.setPosition(xnew, ynew, znew)
            atom.setVelocity(vxnew, vynew, vznew)       
            atom.setOldVelocity(vxt, vyt, vzt)       
            
        # Correct positions and velocities due to constraints.
        if (self.constrain is Rattle): 
            niter = self.Rattle.run1(molecule, xold, yold, zold)
            from control import Control
            if Control.printLevel > 2:
                from utility import Utility
                UTI = Utility()
                logFile = open(molecule.getName()+'.log', 'a')
                logFile.write('rattle2: NumIteration = '+str(niter)+'\n')
                for i in range(self.numRattle):
                    numA = self.constraintRattle[i][0]
                    numB = self.constraintRattle[i][1]
                    logFile.write('DistanceAB = '+str(numA)+' '+str(numB)+' '+  \
                        str(UTI.calcDistance(molecule, numA, numB))+'\n')

        return   

class Beeman(Integrator):

    def __init__(self, system, timeStep=0.1, constrain=None, numRattle=0, constraintRattle=None, translateVector=(0.,)*3):
        Integrator.__init__(self, timeStep) 
        self.constrain = constrain
        self.numRattle = numRattle
        self.constraintRattle = constraintRattle
        if self.constraintRattle is None:
            self.constraintRattle = []
        if (self.constrain is Rattle): 
            self.Rattle = Rattle(self.timeStep, self.numRattle, self.constraintRattle)
        self.translateVector = translateVector

        molecule = system.getMolecule(0)
        self.molName = molecule.getName()
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%22s <<< CMDF Molecular Dynamics via Beeman integration >>>\n" % (' '))
        MDoutput.close()

        return
       
    def initialize(self, system):
    # Initialize old forces for Beeman integration.
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        numAtoms1 = numAtoms + 1

        for i in range(1, numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() != 1:
                continue

            atom.setOldForce(atom.getForceX(),
                             atom.getForceY(),
                             atom.getForceZ())

        return

    def run(self, system, forceEngine):
#
#     This is Python version of modified Beeman algorithum based
#     on a subroutine in TINKER (Jay William Ponder).
#
#     "beeman" performs a single molecular dynamics time step
#     by means of a Beeman multistep recursion formula; the
#     actual coefficients are Brooks' "Better Beeman" values
#
#     literature reference:
#
#     B. R. Brooks, "Algorithms for Molecular Dynamics at Constant
#     Temperature and Pressure", DCRT Report, NIH, April 1988
#
        import datetime
        from control import Control
        from utility import Utility
        UTI = Utility()

        if Control.printLevel > 1:
            iterStart = datetime.datetime.now()

        translateVector = self.translateVector
        dt = self.timeStep
        dt_8 = dt / 8.0  
        dt2_8 = dt * dt_8

        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()

        mass = [0.] * numAtoms
        x = [0.] * numAtoms; y = [0.] * numAtoms; z = [0.] * numAtoms
        xold = [0.] * numAtoms; yold = [0.] * numAtoms; zold = [0.] * numAtoms
        vx = [0.] * numAtoms; vy = [0.] * numAtoms; vz = [0.] * numAtoms
        ax = [0.] * numAtoms; ay = [0.] * numAtoms; az = [0.] * numAtoms
        axold = [0.] * numAtoms; ayold = [0.] * numAtoms; azold = [0.] * numAtoms
#
#     Compute positions at full step and velocities at half step.
#
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                if atom.isIgnored() == 1:
                    rx = atom.getX() + translateVector[0]
                    ry = atom.getY() + translateVector[1]
                    rz = atom.getZ() + translateVector[2]
                    atom.setPosition(rx, ry, rz)
                continue
            mass[i] = atom.getAtomicMass() 

            x[i] = atom.getX()
            y[i] = atom.getY()
            z[i] = atom.getZ()

            xold[i] = x[i] 
            yold[i] = y[i] 
            zold[i] = z[i]

            vx[i] = atom.getVelocityX()
            vy[i] = atom.getVelocityY()
            vz[i] = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            ax[i] = fx / mass[i]
            ay[i] = fy / mass[i]
            az[i] = fz / mass[i]

            fxold = atom.getOldForceX()
            fyold = atom.getOldForceY()
            fzold = atom.getOldForceZ()

            axold[i] = fxold / mass[i]
            ayold[i] = fyold / mass[i]
            azold[i] = fzold / mass[i]

            xterm = 5.0 * ax[i] - axold[i]
            yterm = 5.0 * ay[i] - ayold[i]
            zterm = 5.0 * az[i] - azold[i]

            x[i] += vx[i] * dt + xterm * dt2_8
            y[i] += vy[i] * dt + yterm * dt2_8
            z[i] += vz[i] * dt + zterm * dt2_8

            vx[i] += xterm * dt_8
            vy[i] += yterm * dt_8
            vz[i] += zterm * dt_8

            atom.setPosition(x[i], y[i], z[i])
            atom.setVelocity(vx[i], vy[i], vz[i])

        # Correct positions and half-step velocities due to constraints.
        if (self.constrain is Rattle): 
            niter = self.Rattle.run1(molecule, xold, yold, zold)

        if Control.printLevel > 1:
            forceStart = datetime.datetime.now()
#     Compute forces at full step.
        forceEngine.downloadCoords(molecule)
        if Control.printLevel > 1:
            forceMid1 = datetime.datetime.now()
        forceEngine.calcEnergyForce()
        if Control.printLevel > 1:
            forceMid2 = datetime.datetime.now()
        forceEngine.uploadEnergyForce(molecule)
        if Control.printLevel > 1:
            forceEnd = datetime.datetime.now()
            logFile = open(self.molName+'.log', 'a')
            logFile.write('Beeman force timing, download, calc, upload:\n'); logFile.flush()
            UTI.timer(self.molName, forceStart, forceMid1)
            UTI.timer(self.molName, forceMid1, forceMid2)
            UTI.timer(self.molName, forceMid2, forceEnd)
#
#     Compute velocities at full step. 
#
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue

            axold[i] = ax[i]
            ayold[i] = ay[i]
            azold[i] = az[i]

            ax[i] = atom.getForceX() / mass[i] 
            ay[i] = atom.getForceY() / mass[i] 
            az[i] = atom.getForceZ() / mass[i] 

            vx[i] += (3.0 * ax[i] + axold[i]) * dt_8
            vy[i] += (3.0 * ay[i] + ayold[i]) * dt_8
            vz[i] += (3.0 * az[i] + azold[i]) * dt_8

            atom.setVelocity(vx[i], vy[i], vz[i])
            atom.setOldForce(mass[i] * axold[i],
                             mass[i] * ayold[i],
                             mass[i] * azold[i])

        # Correct full-step velocities due to constraints.
        if (self.constrain == Rattle): 
            niter = self.Rattle.run2(molecule)
            from control import Control
            if Control.printLevel > 2:
                from utility import Utility
                UTI = Utility()
                logFile = open(molecule.getName()+'.log', 'a')
                logFile.write('rattle2: NumIteration = '+str(niter)+'\n')
                for i in range(self.numRattle):
                    numA = self.constraintRattle[i][0]
                    numB = self.constraintRattle[i][1]
                    logFile.write('DistanceAB = '+str(numA)+' '+str(numB)+' '+  \
                        str(UTI.calcDistance(molecule, numA, numB))+'\n')

        if Control.printLevel > 1:
            iterEnd = datetime.datetime.now()
            logFile = open(self.molName+'.log', 'a')
            logFile.write('Beeman iteration timing:\n'); logFile.flush()
            UTI.timer(self.molName, iterStart, iterEnd)

        return   

class VelocityVerletAH(Integrator):

    def __init__(self, system, targetPress=1.0, targetTemp=300., timeStep=0.1, numNose=4, freqNose=0.1, numSuz=3, dim=3, mass=numpy.ones(1, numpy.Float)):
        Integrator.__init__(self, timeStep) 
        self.system = system
        molecule = self.system.getMolecule(0)

        self.targetPress = targetPress 
        self.targetTemp = targetTemp
        self.numNose = numNose
        self.freqNose = freqNose
        self.numSuz = numSuz
        self.dim = dim
        self.mass = mass

        # Creat AndersenHoover object.
        self.AndersenHoover = AndersenHoover(self.targetPress, self.targetTemp, self.timeStep,  \
                                         self.numNose, self.freqNose, self.numSuz, self.dim, self.mass)

        self.molName = molecule.getName()
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%1s<<< CMDF Molecular Dynamics via modified Velocity Verlet integration with Andersen-Hoover NPT method >>>\n" % (' '))
        MDoutput.close()

        return

    def initialize(self, system):

        return

    def run(self, system, forceEngine):
    #
    # Modified Velocity Verlet integration in NPT dynamics
    # using the Andersen-Hoover method.
    #
    # S. Nose, "A unified formulation of the constant temperature 
    # molecular dynamics methods", J. Chem. Phys. 81, 511 (1984)
    #
    # W. G. Hoover, "Canonical dynamics: Equilibrium phase-space distributions",
    # Phys. Rev. A 31, 1695 (1985)
    #
    # G. J. Martyna, M. E. Tuckerman, D. J. Tobias and M. L. Klein,
    # "Explicit Reversible Integrators for Extended Systems Dynamics",
    #  Molecular Physics, 87, 1117-1157 (1996)
    #
        from math import exp

        # Andersen-Hoover and Nose-Hoover dynamics 
        self.AndersenHoover.run(degFree, cellDim, energy, r, v, f, integrator)

        dim = self.dim
        dt = self.timeStep
        dt2 = dt * 0.5
        molecule = system.getMolecule(0)
        numAtoms = molecule.numAtoms()
        mass = [0.] * numAtoms

        xah = self.AndersenHoover.xah
        vah = self.AndersenHoover.vah
        wah = self.AndersenHoover.wah
        gah = self.AndersenHoover.gah

        E2 = 1. / 6.
        E4 = E2 / 20.
        E6 = E4 / 42.
        E8 = E6 / 72.

        # Update the particle velocities
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue
            mass[i] = atom.getAtomicMass() 

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            vx = vx + dt2 * fx / mass[i]
            vy = vy + dt2 * fy / mass[i]
            vz = vz + dt2 * fz / mass[i]

            atom.setVelocity(vx, vy, vz)

        # Update the particle positions
        aa = exp(dt2 * vah)            
        aa2 = aa * aa
        arg2 = (vah * dt2) ** 2
        poly = (((E8 * arg2 + E6) * arg2 + E4) * arg2 + E2) * arg2 + 1.
        bb = aa * poly * dt
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)

            rx = atom.getX() * aa2 + atom.getVelocityX() * bb
            ry = atom.getY() * aa2 + atom.getVelocityY() * bb
            rz = atom.getZ() * aa2 + atom.getVelocityZ() * bb

            atom.setPosition(rx, ry, rz)

        # Update xah = log(V) / dim
        xah = xah + vah * dt
        vol = 2.71828 ** (xah * dim)

        """
        # Update cell dimensions
        sys = self.system
        cellA = sys.getA()
        cellB = sys.getB()
        cellC = sys.getC()
        alpha = sys.getAlpha()
        beta = sys.getBeta()
        gamma = sys.getGamma()
        volold = cellA * cellB * cellC 
        scale = (vol / volold) ** (1. / 3.)
        cellA = cellA * scale
        cellB = cellB * scale
        cellC = cellC * scale
        sys.setCellParameters(cellA, cellB, cellC, alpha, beta, gamma) 
        """

        # Get the new forces
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)

        # Update the particles velocities 
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            vx = vx + dt2 * fx / mass[i]
            vy = vy + dt2 * fy / mass[i]
            vz = vz + dt2 * fz / mass[i]

            atom.setVelocity(vx, vy, vz)

        # Upload Andersen-Hoover barostat parameters
        self.AndersenHoover.xah = xah
        self.AndersenHoover.vah = vah
        self.AndersenHoover.wah = wah
        self.AndersenHoover.gah = gah

        # Andersen-Hoover and Nose-Hoover dynamics 
        self.AndersenHoover.run(system)

        return cellDim, r, v, f

class VelocityVerletPRH(Integrator):

    def __init__(self, system, targetPress=1.0, targetTemp=300., timeStep=0.1, numNose=4, freqNose=0.1, numSuz=3, dim=3, imove=numpy.zeros(1, numpy.Float), mass=numpy.ones(1, numpy.Float)):
        Integrator.__init__(self, timeStep) 
        self.system = system
        molecule = self.system.getMolecule(0)
        self.targetPress = targetPress
        self.targetTemp = targetTemp
        self.timeStep = timeStep    
        self.dim = dim
        self.imove = imove
        self.mass = mass
        self.numNose = numNose
        self.freqNose = freqNose
        self.numSuz = numSuz

        # Creat ParrinelloRahmanHoover object.
        self.ParrinelloRahmanHoover = ParrinelloRahmanHoover(self.targetPress, self.targetTemp, self.timeStep, 
                                        self.numNose, self.freqNose, self.numSuz, self.dim, self.imove, self.mass)

        self.molName = molecule.getName()
        MDoutput = open(self.molName+'.dyn', 'a')
        MDoutput.write("%1s<<< CMDF Molecular Dynamics via modified Velocity Verlet integration with Parrinello-Rahman-Hoover NPT method >>>\n" % (' '))
        MDoutput.close()

        return

    def initialize(self, system):

        return

    def run(self, system, forceEngine):
    #
    # Modified Velocity Verlet integration in NPT dynamics
    # using the Parrinello-Rahman-Hoover method.
    #
    # S. Nose, "A unified formulation of the constant temperature 
    # molecular dynamics methods", J. Chem. Phys. 81, 511 (1984)
    #
    # W. G. Hoover, "Canonical dynamics: Equilibrium phase-space distributions",
    # Phys. Rev. A 31, 1695 (1985)
    #
    # G. J. Martyna, M. E. Tuckerman, D. J. Tobias and M. L. Klein,
    # "Explicit Reversible Integrators for Extended Systems Dynamics",
    #  Molecular Physics, 87, 1117-1157 (1996)
    #
        from math import exp

        # Parrinello-Rahman-Hoover and Nose-Hoover dynamics 
        # Update the particle velocities, box velocities, 
        # thermostat velocities and thermostat positions.
        self.ParrinelloRahmanHoover.run(degFree, cellDim, energy, r, v, f, integrator) 

        #veig = self.veig
        #veigv = self.veigv

        vtemp  = self.ParrinelloRahmanHoover.vtemp
        box    = self.ParrinelloRahmanHoover.box
        vbox   = self.ParrinelloRahmanHoover.vbox
        bmass  = self.ParrinelloRahmanHoover.bmass
        gbox   = self.ParrinelloRahmanHoover.gbox

        lapy = LAPy()
        dt = self.timeStep
        dt2 = dt * 0.5
        dim = self.dim
        mass = self.mass 
        numAtoms = int(len(mass))
        #molecule = system.getMolecule(0)
        #numAtoms = molecule.numAtoms()

        E2 = 1. / 6.
        E4 = E2 / 20.
        E6 = E4 / 42.
        E8 = E6 / 72.

        # Update the particle velocities
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue
            mass[i] = atom.getAtomicMass()

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            vx = vx + dt2 * fx / mass[i]
            vy = vy + dt2 * fy / mass[i]
            vz = vz + dt2 * fz / mass[i]

            atom.setVelocity(vx, vy, vz)

        # Update the particle positions
        # Compute eigenvalues and eigen vectors of vtemp. 
        veig = {}
        veigv = {}
        nrot = 0
        lapy.jacobi(vtemp, 3, 3, veig, veigv, nrot)

        aa2 = {}
        bb = {}
        for i in [1, 2, 3]:  
            aa = exp(dt2 * veig[i])
            aa2[i] = aa * aa
            arg2 = (veig[i] * dt2) ** 2
            poly = (((E8 * arg2 + E6) * arg2 + E4) * arg2 + E2) * arg2 + 1.
            bb[i] = aa * poly * dt

        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue

            rx = atom.getX()
            ry = atom.getY()
            rz = atom.getZ()

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            u1 = rx * veigv[(1, 1)] + ry * veigv[(2, 1)] + rz * veigv[(3, 1)] 
            u2 = rx * veigv[(1, 2)] + ry * veigv[(2, 2)] + rz * veigv[(3, 2)] 
            u3 = rx * veigv[(1, 3)] + ry * veigv[(2, 3)] + rz * veigv[(3, 3)] 

            uv1 = vx * veigv[(1, 1)] + vy * veigv[(2, 1)] + vz * veigv[(3, 1)]
            uv2 = vx * veigv[(1, 2)] + vy * veigv[(2, 2)] + vz * veigv[(3, 2)]
            uv3 = vx * veigv[(1, 3)] + vy * veigv[(2, 3)] + vz * veigv[(3, 3)]

            u1 = u1 * aa2[1] + uv1 * bb[1]
            u2 = u2 * aa2[2] + uv2 * bb[2]
            u3 = u3 * aa2[3] + uv3 * bb[3]

            rx = u1 * veigv[(1, 1)] + u2 * veigv[(1, 2)] + u3 * veigv[(1, 3)]
            ry = u1 * veigv[(2, 1)] + u2 * veigv[(2, 2)] + u3 * veigv[(2, 3)]
            rz = u1 * veigv[(3, 1)] + u2 * veigv[(3, 2)] + u3 * veigv[(3, 3)]

            atom.setPosition(rx, ry, rz)

        #print 'veig  in VVPRH:', veig  
        #print 'veigv in VVPRH:', veigv 
        # Update the box           
        ubox = {}
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                ubox[(i, j)] = 0.

        for i in [1, 2, 3]:
            for j in [1, 2, 3]:  
                for k in [1, 2, 3]:  
                    ubox[(j, i)] += veigv[(k, j)] * box[(k, i)]

        #print ' box in VVPRH:', box

        for i in [1, 2, 3]:   
            for j in [1, 2, 3]:  
                ubox[(j, i)] = ubox[(j, i)] * aa2[j]

        #print 'ubox in VVPRH:', ubox
        #print 'aa2  in VVPRH:', aa2  
        
        for i in [1, 2, 3]:
            for j in [1, 2, 3]:
                box[(i, j)] = 0.

        for i in [1, 2, 3]:  
            for j in [1, 2, 3]:  
                for k in [1, 2, 3]:  
                    box[(j, i)] += veigv[(j, k)] * ubox[(k, i)]

        #print 'box in VVPRH:', box

        # V = det(box)
        vol = lapy.matDet(box)

        #print 'volume in VVPRH=', vol

        """
        # Update cell dimensions
        sys = self.system
        cellA = sys.getA()
        cellB = sys.getB()
        cellC = sys.getC()
        alpha = sys.getAlpha()
        beta = sys.getBeta()
        gamma = sys.getGamma()
        volold = cellA * cellB * cellC 
        scale = (vol / volold) ** (1. / 3.)
        cellA = cellA * scale
        cellB = cellB * scale
        cellC = cellC * scale
        sys.setCellParameters(cellA, cellB, cellC, alpha, beta, gamma) 
        """

        # Get the new forces
        forceEngine.downloadCoords(molecule)
        forceEngine.calcEnergyForce()
        forceEngine.uploadEnergyForce(molecule)

        # Update the particle velocities 
        for i in range(numAtoms):
            atom = molecule.getAtomWithNumber(i+1)
            if atom.isMovable() != 1:
                continue

            vx = atom.getVelocityX()
            vy = atom.getVelocityY()
            vz = atom.getVelocityZ()

            fx = atom.getForceX()
            fy = atom.getForceY()
            fz = atom.getForceZ()

            vx = vx + dt2 * fx / mass[i]
            vy = vy + dt2 * fy / mass[i]
            vz = vz + dt2 * fz / mass[i]

            atom.setVelocity(vx, vy, vz)

        # Upload Parrinello-Rahman-Hoover barostat parameters
        #self.veig = veig
        #self.veigv = veigv

        self.ParrinelloRahmanHoover.vtemp = vtemp
        self.ParrinelloRahmanHoover.box   = box
        self.ParrinelloRahmanHoover.vbox  = vbox
        self.ParrinelloRahmanHoover.gbox  = gbox
        self.ParrinelloRahmanHoover.bmass = bmass

        # Parrinello-Rahman-Hoover and Nose-Hoover dynamics 
        self.ParrinelloRahmanHoover.run(system)

        return cellDim, r, v, f

