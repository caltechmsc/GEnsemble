#!/usr/bin/env python
"""\
 Vec3.py - A simple containers for vectors in 3-space. The goal is to be
  relatively lightweight so that math is fast.

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

from math import sqrt

class Vec3:
    def __init__(self,x=0,y=0,z=0):
        self._items = [x,y,z]
        return

    def __str__(self): return str(self.tuple())
    def __setitem__(self,i,val): self._items[i] = val
    def __getitem__(self,i): return self._items[i]

    def x(self): return self._items[0]
    def y(self): return self._items[1]
    def z(self): return self._items[2]

    def tuple(self): return tuple(self._items)
    def length(self): return sqrt(self.dot(self))
    def length2(self): return self.dot(self)
    def squared(self): return self.dot(self)

    def dist(self,other): return self.__minus__(other).length()
    def dist2(self,other): return self.__minus__(other).length2()
    
    def dot(self,other):
        return self._items[0]*other._items[0]+self._items[1]*other._items[1] \
               + self._items[2]*other._items[2]

    def __add__(self,other):
        return Vec3(self._items[0]+other._items[0],
                    self._items[1]+other._items[1],
                    self._items[2]+other._items[2])

    def __sub__(self,other):
        return Vec3(self._items[0]-other._items[0],
                    self._items[1]-other._items[1],
                    self._items[2]-other._items[2])

    # Note: multiplication only refers to scalar multiplication
    def __mul__(self,val):
        return Vec3(self._items[0]*val,self._items[1]*val,self._items[2]*val)

    def __rmul__(self,val):
        return Vec3(self._items[0]*val,self._items[1]*val,self._items[2]*val)

    def __div__(self,val):
        return Vec3(self._items[0]/val,self._items[1]/val,self._items[2]/val)

    def __neg__(self):
        return Vec3(-self._items[0],-self._items[1],-self._items[2])

    def copy(self):
        return Vec3(self._items[0],self._items[1],self._items[2])

    def scale(self,val):
        for i in range(3): self._items[i] *= val
        return

    def normalize(self):
        mag = self.length()
        if mag: self.scale(1/mag)
        return

    def midpoint(self,other):
        a = self.__add__(other)
        a.scale(0.5)
        return a

    def cross(self,other):
        return Vec3(self._items[1]*other._items[2]
                    -self._items[2]*other._items[1],
                    self._items[2]*other._items[0]
                    -self._items[0]*other._items[2],
                    self._items[0]*other._items[1]
                    -self._items[1]*other._items[0])

if __name__ == '__main__':
    a = Vec3(1,2,3)
    b = Vec3(0,0,0)
    print a.midpoint(b)
    print a+b,a+a,a+a-b
    print a
    print 5*a,a*5
    a /= 5.
    print a
    print -a

