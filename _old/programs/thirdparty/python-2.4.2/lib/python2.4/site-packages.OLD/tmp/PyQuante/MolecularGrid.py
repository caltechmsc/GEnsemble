#!/usr/bin/env python
"""\
 MolecularGrid.py Construct molecular grids from patched atomic
 grids. The technique behind this is based upon:
  A.D. Becke, 'A multicenter numerical integration scheme for
   polyatomic molecules.' J. Chem. Phys 88(4) 1988.
 although I haven't coded the Becke projection operators yet.

 The atomic grids are constructed from atomic grids that use
 Lebedev grids for the angular part, and Legendre grids for
 the radial parts.

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

from AtomicGrid import AtomicGrid
from Numeric import array,concatenate,Float,reshape
from PyQuante.cints import dist2

class MolecularGrid:
    "Class to hold grid information from patched atomic grids"
    def __init__(self, atoms, nrad=32, fineness=1, spingrid=True,
                 gridtype='Becke'):
        self.atoms = atoms
        self.nrad = nrad
        self.fineness = fineness
        self.gridtype = gridtype
        self.spingrid = spingrid
        self.make_atom_grids()
        self.patch_atoms()
        self._length = None
        return

    def __len__(self):
        if self._length: return self._length
        self._length = 0
        for atom in self.atomgrids:
            self._length += len(atom)
        return self._length

    def make_atom_grids(self):
        self.atomgrids = []
        for atom in self.atoms:
            gr = AtomicGrid(atom.atno,self.nrad,self.fineness,
                            self.spingrid,self.gridtype)
            x,y,z = atom.pos()
            gr.translate(x,y,z)
            self.atomgrids.append(gr)

    def patch_atoms(self):
        "Remove gridpoints that are closer to another atom than they "
        " are to their home atom. A simplistic way of doing Becke "
        " projection operators. "
        nat = len(self.atoms)
        for iat in range(nat):
            ati = self.atoms[iat]
            npts = len(self.atomgrids[iat])
            for i in range(npts):
                point = self.atomgrids[iat].points[i]
                xp,yp,zp,wp = point.xyzw()
                rip2 = dist2(ati.pos(),(xp,yp,zp))
                for jat in range(nat):
                    if jat == iat: continue
                    #atno,(xj,yj,zj) = self.atoms[jat]
                    atj = self.atoms[jat]
                    rjp2 = dist2(atj.pos(),(xp,yp,zp))
                    if rjp2 < rip2: point.zeroweight()
        self.prune()
        return

    def prune(self):
        "Remove gridpoints that have been marked as unnecessary"
        for agr in self.atomgrids: agr.prune()
        return

    def points(self):
        "Dynamically form an array of all grid points"
        p = []
        for agr in self.atomgrids: p += agr.points
        return p

    def set_bf_amps(self,bfs):
        "Set the basis func amplitude at each grid point"
        for agr in self.atomgrids: agr.set_bf_amps(bfs)
        return

    def setdens(self,D):
        "Set the density at each grid point"
        for agr in self.atomgrids: agr.setdens(D)
        return

    def setdens0_D(self,D):
        "Set the density at each grid point"
        for agr in self.atomgrids: agr.setdens0_D(D)
        return

    def setdens0(self,rho0s):
        nat = len(rho0s)
        for i in range(nat): self.atomgrids[i].setdens0(rho0s[i])
        return

    def weights(self):
        "Return a vector of weights of each point in the grid"
        weights = array((),Float)
        for agr in self.atomgrids:
            aw = agr.weights()
            weights = concatenate((weights,aw))
        return weights
    
    def dens(self):
        "Return a vector of the density for each point in the grid"
        ds = array((),Float)
        for agr in self.atomgrids:
            ad = agr.dens()
            ds = concatenate((ds,ad))
        return ds
    
    def bfs(self,i):
        "Return a basis function over the entire grid"
        bfs = array((),Float)
        for agr in self.atomgrids:
            abfs = agr.bfs(i)
            bfs = concatenate((bfs,abfs))
        return bfs

    def nbf(self):
        return self.atomgrids[0].nbf()

    def npts(self):
        npts = 0
        for agr in self.atomgrids: npts += agr.npts()
        return npts

    def allbfs(self):
        "Construct a matrix with bfs in columns over the entire grid, "
        " so that R[0] is the first basis function, R[1] is the second..."
        bfs = array((),Float)
        for agr in self.atomgrids:
            abfs = agr.allbfs()
            bfs = concatenate((bfs,abfs))
        # Now the bfs array is a concatenation of all of the bfs
        npts = self.npts()
        nbf,nrem = divmod(len(bfs),npts)
        if nrem != 0: raise "Remainder in divmod allbfs"
        nbf2 = self.nbf()
        if nbf != nbf2: raise "Wrong # bfns %d %d" % (nbf,nbf2)
        bfs = reshape(bfs,(npts,nbf))
        return bfs
        
    

