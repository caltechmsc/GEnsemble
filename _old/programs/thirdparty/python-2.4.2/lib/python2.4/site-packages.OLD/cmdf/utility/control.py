#!/usr/bin/env python
#############################################################################################
#                                                                                           #
#  Control class: control CMDF jobs by reading parameters from a keyword file and creating  #
#  objects needed in later calculations.                                                    #
#  The higher level GUI toolkits may be implemented in future.                              #
#                                                                                           #
#  Created on 03/10/06, last revision on 09/06/06. yi                                       #
#                                                                                           #
#############################################################################################
import sys
import os
import os.path
import numpy
import cmdf.utility.bgfio as bgfio
from cmdf.utility.unit import Unit
from cmdf.utility.utility_pf import Utility
from cmdf.utility.communication import systemToArrays, arraysToSystem_md, arraysToSystem_min
from cmdf.optimize.simulatedAnnealing import SimulatedAnnealing_MD, Sigmoid, Exponent, Linear  
from cmdf.optimize.conjugateGradient import ConjugateGradient_SP, ConjugateGradient_MEE
#from cmdf.optimize.minimize import ConjugateGradient_PR, BFGS, Newton_cg, Simplex, Powell
import cmdf.optimize.minimize as minimize
from cmdf.dynamics.integrator_pf import VelocityVerlet_f, LeapFrog, Beeman 
from cmdf.dynamics.thermostat_pf import BerendsenThermostat, AndersenThermostat, NoseHooverThermostat
from cmdf.dynamics.barostat_pf import BerendsenBarostat, AndersenHoover, ParrinelloRahmanHoover
from cmdf.dynamics.distribution import Gaussian1, Gaussian2, Gaussian3
from cmdf.dynamics.constraint import Rattle    
#from forceEngine import MasterForceEngine
from cmdf.mee.meeForceEngine import MeeForceEngine
import cmdf.mee.mee as mee
from cmdf.mee.mpeForceEngine import MpeForceEngine
from cmdf.reaxFF.reaxForceEngine import ReaxForceEngine
import cmdf.reaxFF.reax as reax
from cmdf.eam.imdForceEngine_shift import IMDForceEngine_shift
from cmdf.eam.imdForceEngine_noshift import IMDForceEngine_noshift
import cmdf.eam.IMD_EAM as imd_eam_shift 
import cmdf.eam.IMD_EAM_noshift as imd_eam_noshift 
from cmdf.nonbond.coulomb import Coulomb
from cmdf.list.shortrangelist import BondList, AngleList, TorsionList, InversionList3Coord, InversionListAll
from cmdf.list.exclusionlist import Exclusion12List, Exclusion13List, Exclusion14List
from cmdf.list.regionlist import OrthorhombicRegion, SphericalRegion, ThermoList

class Control:
    #printLevel = 1

    def __init__(self):
        #self.printLevel = 1

        return

    # Set up a system from structure file.
    def loadSystem(self, inputFileName):

        try:
            self.system = bgfio.read(inputFileName+'.bgf')
        except:
            print 'Error! loadSystem: Faild to read BGF input file.'
            sys.exit(1)

        self.sgName = self.system.getSgName()
        self.sgSymbol = self.system.getSgSymbol()
        self.sgNumber = self.system.getSgNumber()
        self.axes = str(self.system.getAxes())
        self.molecule = self.system.getMolecule(0)
        self.numAtoms = self.molecule.numAtoms()
        self.molName = self.molecule.getName()
        self.dim = self.molecule.getDimension()

        os.system('date > %s' % self.molName+'.log')
        logFile = open(self.molName+'.log', 'a') 
        cmdfStr = '<<< Computational Materials Design Facility (CMDF) >>>\n'
        logFile.write('%65s' % (cmdfStr)) 

        self.cellDim, self.elements, self.coords, self.vels, self.energy, self.forces,  \
         self.oldForces, self.imove, self.fixed, self.charges, self.masses, self.fftypes,  \
          self.bondlist, self.orderlist, self.itranlist = systemToArrays(self.system) 

        logFile.write('=> Loading system completed.\n')
        logFile.close()

        return

    def writeSystem(self):
        #from utility_pf import Utility
        util = Utility()

        bgfio.write(self.system, self.molName+'_last.bgf', format=True)  # Output true format.
        lastTrjFile = open(self.molName+'_last.xyz', 'w')
        util.outputTrjSys(self.molecule, lastTrjFile, self.numSteps)
        lastTrjFile.close()

        return

    # Setup a force engine.
    def setForceEngine(self, ForceEngine):
    #def setForceEngine(self, valenceForceEngine, coulombForceEngine, vdwForceEngine, solvationForceEngine):
        #from utility_pf import Utility
        util = Utility()
        unit = Unit()

        """
        self.valenceForceEngine = valenceForceEngine(self.numAtoms) 
        self.coulombForceEngine = self.valenceForceEngine 
        self.vdwForceEngine = self.valenceForceEngine 
        self.solvationForceEngine = self.valenceForceEngine 
        self.forceEngine = MasterForceEngine(self.valenceForceEngine, self.coulombForceEngine, \
            self.vdwForceEngine, self.solvationForceEngine)
        self.forceEngine.setupEnergyExpression(self.molecule)
        self.forceEngine.downloadCoords(self.molecule)
        self.forceEngine.calcEnergyForce()
        self.forceEngine.uploadEnergyForce(self.molecule)
        print 'masterEnergy=', self.forceEngine.getEnergy()
        print 'masterForce =', self.forceEngine.getForces()
        logFile = open(self.molName+'.log', 'a') 
        logFile.write('=> Setup master force engine completed.\n')
        logFile.close()

        """
        if ForceEngine is MeeForceEngine:
            self.forceEngine = MeeForceEngine(self.numAtoms)
            self.forceEngine.setupEnergyExpression(self.coords, self.fixed, self.charges, self.fftypes, self.bondlist, self.orderlist)
            mee.cmdf_mee_current_energy()
            #self.forceEngine.setCoords(self.coords)
            #self.forceEngine.calcEnergyForce()
            #energy = self.forceEngine.getEnergy()
            #forces = self.forceEngine.getForces()
            """
            #The following is test for generation of lists.
            bndList = BondList()
            bondList = bndList.calcSRlist(self.imove, self.bondlist)
            print 'Bond list = ', bondList
            exclude12 = Exclusion12List()
            exclusion12List = exclude12.calcEXClist(self.imove, self.bondlist)
            print 'Exclusion 1-2 list = ', exclusion12List
            angList = AngleList()
            angleList = angList.calcSRlist(self.imove, self.bondlist)
            print 'Angle list = ', angleList
            exclude13 = Exclusion13List()
            exclusion13List = exclude13.calcEXClist(self.imove, self.bondlist)
            print 'Exclusion 1-3 list = ', exclusion13List
            torList = TorsionList()
            torsionList = torList.calcSRlist(self.imove, self.bondlist)
            print 'Torsion list = ', torsionList
            invList3 = InversionList3Coord()
            inversion3List = invList3.calcSRlist(self.imove, self.bondlist)
            print 'Inversion list (3-coordinate) = ', inversion3List
            invListAll = InversionListAll()
            inversionList = invListAll.calcSRlist(self.imove, self.bondlist)
            print 'Inversion list (all)= ', inversionList
            exclude14 = Exclusion14List()
            exclusion14TorsionList, exclusion14InversionList = exclude14.calcEXClist(self.imove, self.bondlist)

            #The following is test for CMDF version of Coulomb FE.
            # Pack lists into dictionary.
            nbLists = {'move':self.imove, 'coord':self.coords, 'charge':self.charges}
            #exclusionLists = {'1-2':exclusion12List, '1-3':exclusion13List,  \
            #            '1-4Torsion':exclusion14TorsionList, '1-4Inversion':exclusion14InversionList}
            exclusionLists = {'1-2':exclusion12List, '1-3':exclusion13List}  
            coulomb = Coulomb(1.0, False)
            #energyCoulomb, forcesCoulomb = coulomb.calcCoulombEF(self.imove, self.coords, self.charges, exclusion12List, exclusion13List)
            energyCoulomb, forcesCoulomb = coulomb.calcCoulombEF(nbLists, exclusionLists)

            print 'Coulomb energy kcal/mol   =', energyCoulomb / unit.kcalpermol 
            print 'Coulomb forces kcal/mol/A =', forcesCoulomb / unit.kcalpermol 

            #The following is test for decoulping of MEE force engine.
            energyBond, forcesBond = self.forceEngine.calcEnergyForceBond(self.coords)
            print 'Bond energy kcal/mol =', energyBond / unit.kcalpermol
            print 'Bond forces kcal/molA=', forcesBond / unit.kcalpermol

            energyBond2, forcesBond2 = self.forceEngine.calcEnergyForceBond2(self.coords)
            print 'Bond energy2    =', energyBond2 / unit.kcalpermol
            print 'Bond forces2    =', forcesBond2 / unit.kcalpermol

            energyAng, forcesAng = self.forceEngine.calcEnergyForceAng(self.coords)
            print 'Angle energy     =', energyAng / unit.kcalpermol
            print 'Angle forces     =', forcesAng / unit.kcalpermol

            energyAng2, forcesAng2 = self.forceEngine.calcEnergyForceAng2(self.coords)
            print 'Angle energy2     =', energyAng2 / unit.kcalpermol
            print 'Angle forces2     =', forcesAng2 / unit.kcalpermol

            energyInv, forcesInv = self.forceEngine.calcEnergyForceInv(self.coords)
            print 'Inversion energy     =', energyInv / unit.kcalpermol
            print 'Inversion forces     =', forcesInv / unit.kcalpermol

            energyTor, forcesTor = self.forceEngine.calcEnergyForceTor(self.coords)
            print 'Torsion energy    =', energyTor / unit.kcalpermol
            print 'Torsion forces    =', forcesTor / unit.kcalpermol

            energyVdw, energyCoulomb, forcesNB = self.forceEngine.calcEnergyForceNBall(self.coords)
            print 'Vdw energy kcal/mol    =', energyVdw / unit.kcalpermol
            print 'Coulomb energy kcal/mol=', energyCoulomb / unit.kcalpermol
            print 'NB All forces kcal/molA=', forcesNB / unit.kcalpermol

            energyHB, forcesHB = self.forceEngine.calcEnergyForceHBall(self.coords)
            print 'HB energy eV in control=', energyHB 
            print 'HB energy kcal/mol    =', energyHB / unit.kcalpermol
            print 'HB All forces kcal/molA=', forcesHB / unit.kcalpermol
            """

            energy, forces = self.forceEngine.calcEnergyForce(self.coords)

            print 'Initial MEE energy (kcal/mol)   =', energy / unit.kcalpermol
            print 'Initial MEE forces (kcal/molA)  =', forces / unit.kcalpermol

            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup MEE force engine completed.\n')
            logFile.close()

        elif ForceEngine is MpeForceEngine:
            self.forceEngine = MpeForceEngine(self.numAtoms, self.cellDim, self.sgName, self.sgSymbol, self.sgNumber, self.axes)
            self.forceEngine.setupEnergyExpression(self.coords, self.fixed, self.charges, self.fftypes, self.bondlist,  \
                self.orderlist, self.itranlist)
            ### Need check out if this is MPE current energy or MEE energy. NOT!!
            #mee.cmdf_mee_current_energy()
            #self.forceEngine.setCoords(self.coords)
            #self.forceEngine.calcEnergyForce()
            #energy = self.forceEngine.getEnergy()
            #forces = self.forceEngine.getForces()
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)

            print 'Initial MPE energy (kcal/mol)   =', energy / unit.kcalpermol
            print 'Initial MPE forces (kcal/molA)  =', forces / unit.kcalpermol

            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup MPE force engine completed.\n')
            logFile.close()

        elif ForceEngine is ReaxForceEngine:
            reaxFFName = util.searchFileName(os.path.join('cmdf', 'reaxFF', 'reaxForceField'))
            print 'reaxForceField source: ', reaxFFName
            geoFileName = self.molName+'.bgf'
            print 'geo source: ', geoFileName
            controlFileName = util.searchFileName(os.path.join('cmdf', 'reaxFF', 'reaxControl'))
            print 'reax control source: ', controlFileName
            #self.forceEngine = ReaxForceEngine(self.numAtoms, self.cellDim, reaxFFName)
            self.forceEngine = ReaxForceEngine(self.numAtoms, geoFileName, reaxFFName, controlFileName)
            #self.forceEngine.readForceFieldFile(reaxFFName)

            #self.forceEngine.setupEnergyExpression(self.coords, self.fixed, self.charges, self.fftypes, self.bondlist, self.orderlist)
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)
            #print 'Initial Reax energy (kcal/mol)  =', self.forceEngine.getEnergy() / unit.kcalpermol
            #print 'Initial Reax force (kcal/mol/A) =', self.forceEngine.getForces() / unit.kcalpermol
            print 'Initial Reax energy (kcal/mol)  =', energy / unit.kcalpermol
            print 'Initial Reax force (kcal/mol/A) =', forces / unit.kcalpermol
            reax.reaxmdsave(0)  # Output initial connection table and charge.
            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup ReaxFF force engine completed.\n')
            logFile.close()

        elif ForceEngine is IMDForceEngine_noshift:
            FFflavor = self.imdEamFSP['FFflavor']
            cutoff = self.imdEamFSP['cutoff']
            spacing = self.imdEamFSP['spacing']
            imdEamFFName = util.searchFileName(os.path.join('cmdf', 'eam', 'imdEamForceField'))
            self.forceEngine = IMDForceEngine_noshift(self.numAtoms, self.cellDim)
            self.forceEngine.setupEnergyExpression(self.coords, self.masses, self.elements,  \
                                        FFflavor, cutoff, spacing, imdEamFFName)
            self.forceEngine.writeChkpt(self.molName)
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)
            print 'Initial IMD-EAM_noshift energy (kcal/mol)  =', energy / unit.kcalpermol
            print 'Initial IMD-EAM_noshift force (kcal/mol/A) =', forces / unit.kcalpermol
            print 'Initial IMD-EAM_noshift energy (eV)  =', energy 
            print 'Initial IMD-EAM_noshift force (eV/A) =', forces
            imd_eam_noshift.PrintEnergies()
            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup IMD force engine (no shift) completed.\n')
            logFile.close()

        elif ForceEngine is IMDForceEngine_shift:
            FFflavor = self.imdEamFSP['FFflavor']
            cutoff = self.imdEamFSP['cutoff']
            spacing = self.imdEamFSP['spacing']
            imdEamFFName = util.searchFileName(os.path.join('cmdf', 'eam', 'imdEamForceField'))
            self.forceEngine = IMDForceEngine_shift(self.numAtoms, self.cellDim)
            self.forceEngine.setupEnergyExpression(self.coords, self.masses, self.elements,  \
                                        FFflavor, cutoff, spacing, imdEamFFName)
            self.forceEngine.writeChkpt(self.molName)
            energy, forces = self.forceEngine.calcEnergyForce(self.coords)
            print 'Initial IMD-EAM_shift energy (kcal/mol)  =', energy / unit.kcalpermol
            print 'Initial IMD-EAM_shift force (kcal/mol/A) =', forces / unit.kcalpermol
            print 'Initial IMD-EAM_shift energy (eV)  =', energy 
            print 'Initial IMD-EAM_shift force (eV/A) =', forces
            imd_eam_shift.PrintEnergies()
            logFile = open(self.molName+'.log', 'a') 
            logFile.write('=> Setup IMD force engine (shift) completed.\n')
            logFile.close()

        return

    def setParameters(self, system):
        #from utility_pf import Utility
        util = Utility()

        try:
            cmdfKeyFileName = util.searchFileName(os.path.join('cmdf', 'config', 'cmdf.key'))
            cmdfKeyFile = open(cmdfKeyFileName, 'r')
            self.readKey(system, cmdfKeyFile)         # Setup parameters and objects from default CMDF keyword file.
        except:
            errFile = open(self.molName+'.err', 'a')
            errFile.write('Error! readKey: Failed to read CMDF keyword file (cmdf.key)! \n')
            errFile.close()
            sys.exit(1)

        try:
            userKeyFile = open(self.molName+'.key', 'r')
            self.readKey(system, userKeyFile)         # Setup parameters and objects from user keyword file.
        except:
            errFile = open(self.molName+'.err', 'a')
            errFile.write('Error! readKey: Failed to read user keyword file (*.key)! \n')
            errFile.close()
            sys.exit(1)

        self.writeKey()  # Write parameters to log file.
        self.createObjects()  # Create objects.

        return

    # Read parameters from the keyword file. 
    def readKey(self, system, keyFile):
        #from unit import Unit
        #from utility_pf import Utility
        UNIT = Unit()
        util = Utility()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        self.numRattle = 0
        self.constraintRattle = []
        #self.translateVector = (0.,) * 3 
        self.translateVector = numpy.zeros([3], numpy.Float32)
        #self.minimizer = None
        #self.integrator = None
        #self.thermostat = None
        #self.barostat = None
        self.constrain = None
        self.gaussian = Gaussian3
        self.numRegions = 0
        self.initTemps = [] 
        self.targetTemps = []
        self.regionRuleStrs = [] 
        self.regionParameters = []
        for line in keyFile.readlines():
            if line.find('#') == 0 or line.find('!') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'md':
                        self.task = fields[1]
                    elif fields[1] == 'minimize':
                        self.task = fields[1]
                    else:  # Default task.
                        self.task = 'md'
                else:  # Default task.
                    self.task = 'md'
                continue

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                        system.setPeriodic(0) 
                    elif fields[1] == 'mpe':
                        self.forceEngine = MpeForceEngine
                        system.setPeriodic(1) 
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                        system.setPeriodic(1) 
                    elif fields[1] == 'eam_noshift':
                        self.forceEngine = IMDForceEngine_noshift
                        system.setPeriodic(1) 
                    elif fields[1] == 'eam_shift':
                        self.forceEngine = IMDForceEngine_shift
                        system.setPeriodic(1) 
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                        system.setPeriodic(0) 
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                    system.setPeriodic(0) 
                continue

            if line.find('FORCE_FIELD_SPECIFICATION') == 0:  # Force field specifications used in IMD-EAM calculation.
                fields = line.split()
                if len(fields) >= 8:
                    self.imdEamFSP = {}
                    if fields[2] == 'RGL' or fields[2] == 'QSC' or fields[2] == 'QSC2':
                        self.imdEamFSP['FFflavor'] = fields[2]
                    else: # Default force field flavor
                        self.imdEamFSP['FFflavor'] = 'RGL' 
                    self.imdEamFSP['cutoff'] = [float(fields[4]), float(fields[5])]
                    self.imdEamFSP['spacing'] = float(fields[7])
                continue

            """
            if line.find('ENERGY_VALENCE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.valenceForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.valenceForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.valenceForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_COULOMB') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.coulombForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.coulombForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.coulombForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_VDW') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.vdwForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.vdwForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.vdwForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_SOLVATION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.solvationForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.solvationForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.solvationForceEngine = MeeForceEngine
                continue

            if line.find('ENERGY_RESTRAINT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.restraintForceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.restraintForceEngine = ReaxForceEngine
                    else:  # Default force engine.
                        self.restraintForceEngine = MeeForceEngine
                continue
            """

            if line.find('TIME_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.timeStep = float(fields[1]) * UNIT.ps
                continue

            if line.find('NUM_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numSteps = int(fields[1])
                continue

            if line.find('EQU_STEP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.equSteps = int(fields[1])
                continue

            if line.find('FREQ_OUTPUT_MD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqOutputMD = int(fields[1])
                continue

            if line.find('FREQ_OUTPUT_TRJ') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqOutputTrj = int(fields[1])
                continue

            if line.find('FREQ_CHECK_THERMO_REGION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqCheckThermoRegion = int(fields[1])
                continue

            if line.find('INIT_TEMP') == 0:  # Applies to entire system rather than local thermo region
                fields = line.split()
                if len(fields) >= 2:
                    self.initTemps.append(float(fields[1]) * UNIT.K)
                continue

            if line.find('TARGET_TEMP') == 0:  # Applies to entire system rather than local thermo region
                fields = line.split()
                if len(fields) >= 2:
                    self.targetTemps.append(float(fields[1]) * UNIT.K)
                continue

            if line.find('TARGET_PRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.targetPress = float(fields[1]) * UNIT.GPa
                continue

            if line.find('TAU_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.tauTemp = float(fields[1]) * UNIT.ps
                continue

            if line.find('TAU_PRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.tauPress = float(fields[1]) * UNIT.ps
                continue

            if line.find('NIU_TEMP') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.niuTemp = float(fields[1])
                continue

            if line.find('COMPRESS') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.compress = float(fields[1]) / UNIT.GPa
                continue

            if line.find('FREQ_NOSE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.freqNose = float(fields[1]) * UNIT.THz
                continue

            if line.find('NUM_NOSE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numNose = int(fields[1])
                continue

            if line.find('NUM_SUZ') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.numSuz = int(fields[1])
                continue

            if line.find('THRESHOLD_FORCE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.threshold = float(fields[1]) * UNIT.kcalpermol
                continue

            if line.find('THRESHOLD_COORD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.xthreshold = float(fields[1]) * UNIT.Ang
                continue

            if line.find('THRESHOLD_ENERGY') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fthreshold = float(fields[1]) * UNIT.kcalpermol
                continue

            if line.find('MAX_ITERATION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.maxiteration = int(fields[1]) 
                continue

            if line.find('MAX_FUNCTION') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.maxfunction = int(fields[1]) 
                continue

            if line.find('GAUSSIAN') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == '1':
                        self.gaussian = Gaussian1
                    elif fields[1] == '2':
                        self.gaussian = Gaussian2 
                    elif fields[1] == '3':
                        self.gaussian = Gaussian3
                    else:  # Default Gaussian.
                        self.gaussian = Gaussian3
                continue

            if line.find('COOL_SCHEDULE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'linear':
                        self.coolSchedule = Linear
                    elif fields[1] == 'exponent':
                        self.coolSchedule = Exponent
                    elif fields[1] == 'sigmoid':
                        self.coolSchedule = Sigmoid 
                    else:  # Default cooling schedule.
                        self.coolSchedule = Linear
                continue

            if line.find('THERMO_REGION') == 0:
                fields = line.split()
                if len(fields) >= 15:
                    self.numRegions += 1
                    iRegion = int(fields[1]) - 1
                    self.initTemps.append(float(fields[3]))
                    self.targetTemps.append(float(fields[5]))
                    self.regionRuleStrs.append(str(fields[6]))
                    if self.regionRuleStrs[iRegion] == 'orthorhombic':
                        self.regionParameters.append([[float(fields[8]), float(fields[9])],  \
                                                      [float(fields[11]), float(fields[12])], \
                                                      [float(fields[14]), float(fields[15])]]) 
                    elif self.regionRuleStrs[iRegion] == 'spherical':
                        self.regionParameters.append([[float(fields[8]), float(fields[9]),  \
                                    float(fields[10])], [float(fields[12]), float(fields[14])]])
                    else:
                        errFile = open(molName+'.err', 'a') 
                        errFile.write('Error! readKey: unknown region rule!') 
                        errFile.close()
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Error! readKey: range parameters not complete!') 
                    errFile.close()
                continue

            if line.find('FIX_ATOMS') == 0:
                fields = line.split()
                for iatom in range(1, len(fields)): 
                    fixedAtom = molecule.getAtomWithNumber(int(fields[iatom]))
                    fixedAtom.setFixed()
                continue

            if line.find('FIX_RANGE') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    fixedStart = int(fields[1])
                    fixedEnd = int(fields[2])
                    for iatom in range(fixedStart, fixedEnd+1): 
                        fixedAtom = molecule.getAtomWithNumber(iatom)
                        fixedAtom.setFixed()
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! readKey: fixed atom range not complete.') 
                    errFile.close()
                continue

            if line.find('CONSTRAINT_METHOD') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'rattle':
                        self.constrain = Rattle
                continue

            if line.find('RATTLE_DISTANCE') == 0 and self.constrain is Rattle:
                fields = line.split()
                if len(fields) >= 4:
                    self.constraintRattle.append   \
                        ((int(fields[1]), int(fields[2]), float(fields[3]) * UNIT.Ang)) 
                    self.numRattle += 1
                elif len(fields) == 3:  # Original distance is used as a constraint if L12 is blank.
                    dist12 = util.calcDistance(molecule, int(fields[1]), int(fields[2]))
                    self.constraintRattle.append   \
                        ((int(fields[1]), int(fields[2]), dist12 * UNIT.Ang)) 
                    self.numRattle += 1
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: skip as constraint information not complete.') 
                    errFile.close()
                continue

            if line.find('TRANSLATE_VECTOR') == 0:
                fields = line.split()
                if len(fields) >= 4:
                    self.translateVector = (float(fields[1]), float(fields[2]), float(fields[3]))
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: translation vector not complete.') 
                    errFile.close()
                continue

            if line.find('TRANSLATE_ATOMS') == 0:
                fields = line.split()
                for iatom in range(1, len(fields)): 
                    transAtom = molecule.getAtomWithNumber(int(fields[iatom]))
                    transAtom.setIgnored()
                continue

            if line.find('TRANSLATE_RANGE') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    transStart = int(fields[1])
                    transEnd = int(fields[2])
                    for iatom in range(transStart, transEnd+1): 
                        transAtom = molecule.getAtomWithNumber(iatom)
                        transAtom.setIgnored()
                else:
                    errFile = open(molName+'.err', 'a') 
                    errFile.write('Warning! setParameter: translation atom range not complete.') 
                    errFile.close()
                continue

            if line.find('SUMFORCE_RANGE_Z') == 0:
                fields = line.split()
                if len(fields) >= 3:
                    self.sumForceMinZ = float(fields[1])
                    self.sumForceMaxZ = float(fields[2])
                continue

            if line.find('THERMOSTAT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'berendsen':
                        #self.thermostat = BerendsenThermostat(self.targetTemp, self.timeStep, self.tauTemp, self.masses)
                        self.thermoStr = 'Berendsen'
                    elif fields[1] == 'andersen':
                        #self.thermostat = AndersenThermostat(self.targetTemp, self.timeStep, self.niuTemp,  \
                        #                                        self.gaussian, self.imove, self.masses)
                        self.thermoStr = 'Andersen'
                    elif fields[1] == 'nose-hoover':
                        #self.thermostat = NoseHooverThermostat(self.molName, self.targetTemp, self.timeStep, self.numNose,  \
                        #                                        self.freqNose, self.numSuz, self.masses)
                        self.thermoStr = 'Nose-Hoover'
                    else:  # Default thermostat.
                        #self.thermostat = None             
                        self.thermoStr = 'None'
                continue

            if line.find('BAROSTAT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'berendsen':
                        #self.barostat = BerendsenBarostat(self.targetPress, self.timeStep, self.tauPress,  \
                        #                                 self.compress, self.masses)
                        self.baroStr = 'Berendsen'
                    elif fields[1] == 'andersen-hoover':
                        #self.barostat = None    # Switch off explicit thermostat and barostat,
                        #self.thermostat = None  # and will use implicit thermostat/barostat embeded in VVAH integrator.
                        self.thermoStr = 'Hoover'
                        self.baroStr = 'Andersen'
                    elif fields[1] == 'parrinello-rahman-hoover':
                        #self.thermostat = None  # Switch off explicit thermostat and barostat,
                        #self.barostat = None    # and will use implicit thermostat/barostat embeded in VVPRH integrator.
                        self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
                        self.thermoStr = 'Hoover'
                        self.baroStr = 'Parrinello-Rahman'
                    else:  # Default barostat.
                        #self.barostat = None
                        self.baroStr = 'None'
                continue

            if line.find('INTEGRATOR') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'beeman':
                        #self.integrator = Beeman(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Beeman'
                    elif fields[1] == 'verlet':
                        #self.integrator = VelocityVerlet(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Velocity Verlet'
                    elif fields[1] == 'verlet_f':
                        #self.integrator = integrator_pf.VelocityVerlet_f(self.molName, self.timeStep, self.translateVector,  \
                        #                    self.imove, self.masses)
                        self.integraStr = 'Velocity Verlet_f'
                    elif fields[1] == 'leap-frog':
                        #self.integrator = LeapFrog(system, self.timeStep, self.constrain,  \
                        #                    self.numRattle, self.constraintRattle, self.translateVector)
                        self.integraStr = 'Leap Frog'
                    elif fields[1] == 'vv-ah-NPT':
                        #self.integrator = VelocityVerletAH(system, self.targetPress,  \
                        #   self.targetTemp, self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.masses) 
                        self.integraStr = 'modified Velocity Verlet for Andersen-Hoover NPT dynamics'
                    elif fields[1] == 'vv-prh-NPT':
                        #self.integrator = VelocityVerletPRH(system, self.targetPress, self.targetTemp,  \
                        #                     self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.imove, self.masses)
                        self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
                    else:  # Default integrator.
                        #self.integrator = None 
                        self.integraStr = 'None'
                continue
        
            if line.find('MINIMIZER') == 0:
                if self.task == 'md': self.miniStr = 'None'; continue
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'cg_sp':
                        #self.nMethod = 0
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'Conjugate Gradient (Shanno-Phua)'
                    elif fields[1] == 'bfgs_sp':
                        #self.nMethod = 1
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'BFGS (Shanno-Phua)'
                    elif fields[1] == 'cg_mee':
                        #self.minimizer = ConjugateGradient_MEE(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)
                        self.miniStr = 'Conjugate Gradient in MEE'
                    elif fields[1] == 'cg_fr':  # Not working for array.
                        #self.nMethod = 0
                        #self.degFree = 3 * molecule.numMovableAtoms()
                        #self.minimizer = ConjugateGradient_FR(self.molName, self.nMethod, self.numSteps, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
                        self.miniStr = 'Conjugate Gradient (Fletcher-Reeves)'
                    elif fields[1] == 'sa':
                        #self.minimizer = SimulatedAnnealing_MD(self.coolSchedule, self.integrator, self.thermostat,  \
                        #                    self.barostat, self.gaussian, self.initTemp, self.targetTemp,  \
                        #                    self.numSteps, self.equSteps, self.timeStep,  \
                        #                    self.threshold, self.freqOutputMD, self.freqOutputTrj,  \
                        #                    self.cellDim, self.coords, self.vels, self.forces) 
                        self.miniStr = 'Simulated Annealing Algorithum'
                    elif fields[1] == 'simplex':
                        self.miniStr = 'Simplex'
                    elif fields[1] == 'powell':
                        self.miniStr = 'Powell'
                    elif fields[1] == 'cg_pr':
                        self.miniStr = 'Conjugate Gradient (Polak-Ribiere)'
                    elif fields[1] == 'bfgs':
                        self.miniStr = 'BFGS'
                    elif fields[1] == 'newton_cg':
                        self.miniStr = 'Newton CG'
                    else:  # Default minimizer.
                        #self.minimizer = None 
                        self.miniStr = 'None'
                continue
        
            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_TRJ_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'coord':
                        self.printTrjLevel = 1 
                    elif fields[1] == 'coord+vel':
                        self.printTrjLevel = 2 
                    elif fields[1] == 'coord+vel+force':
                        self.printTrjLevel = 3 
                    else:  # Default print flag.
                        self.printTrjLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = UNIT.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = UNIT.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = UNIT.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = UNIT.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = UNIT.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = UNIT.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = UNIT.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = UNIT.bar
                        self.printPressureFlag = 'Bar'
                continue

        if len(self.targetTemps) != self.numRegions and self.numRegions > 0:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Error! readKey: Too many temperature assingment!\n') 
            errFile.close()
            sys.exit(1)

        if self.numRattle == 0:  # No leagal constraints found.
            self.constrain = None
        else:
            self.constrain = Rattle
        self.numConstraints = self.numRattle

        self.numAtoms = molecule.numAtoms()
        self.numAtoms1 = self.numAtoms + 1
        self.numMovableAtoms = molecule.numMovableAtoms()
        self.numFixedAtoms = molecule.numFixedAtoms()
        self.numIgnoredAtoms = molecule.numIgnoredAtoms()
        # The following is done in data model as above.
        """
        self.numMovableAtoms = 0 
        self.numFixedAtoms = 0 
        self.numIgnoredAtoms = 0 
        for i in range(1, self.numAtoms1):
            atom = molecule.getAtomWithNumber(i)
            if atom.isMovable() == 1: 
                self.numMovableAtoms += 1
            elif atom.isFixed() == 1:
                self.numFixedAtoms += 1
            elif atom.isIgnored() == 1:
                self.numIgnoredAtoms += 1 
        """
        self.numForceAtoms = self.numMovableAtoms + self.numFixedAtoms
        totalNumAtoms = self.numForceAtoms + self.numIgnoredAtoms
        if self.numAtoms != totalNumAtoms:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! setParameter: Number of atoms not consistent.') 
            errFile.close()
        # Compute degree of freedom.
        if self.task == 'minimize':
            # DOF = 3 * Nmove if do minimization.
            self.degFree = 3 * self.numMovableAtoms
        elif self.task == 'md':
            if self.thermoStr == 'andersen':
                self.degFree = 3 * self.numMovableAtoms - self.numConstraints
            else:
                if system.isPeriodic() == 0:  # Non-periodic
                    self.degFree = 3 * self.numMovableAtoms - 6 - self.numConstraints
                elif system.isPeriodic() != 0:  # Periodic
                    #self.degFree = 3 * self.numMovableAtoms - 3 - self.numConstraints 
                    self.degFree = 3 * self.numMovableAtoms - self.numConstraints 
            if self.numFixedAtoms == 1:  # Single fixed atom.
                self.degFree = self.degFree - 3
        molecule.setDegFree(int(self.degFree))

        self.isPeriodic = system.isPeriodic()

        # Update imove array here.
        self.cellDim, self.elements, self.coords, self.vels, self.energy, self.forces,  \
         self.oldForces, self.imove, self.fixed, self.charges, self.masses, self.fftypes,  \
          self.bondlist, self.orderlist, self.itranlist = systemToArrays(self.system) 

        self.printTrjLevel = 3  # Temperaroy default

        Control.printLevel = self.printLevel    
        Control.printTrjLevel = self.printTrjLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag
        Control.sumForceMinZ = self.sumForceMinZ
        Control.sumForceMaxZ = self.sumForceMaxZ

        return

    def writeKey(self):
    	"""
    	Write parameters to log file.
    	"""
        unit = Unit()

        if self.printLevel > 0:
            logFile = open(self.molName+'.log', 'a') 

            if self.task == 'md':
                logFile.write('Task type               : Molecular dynamics\n')
            elif self.task == 'minimize':
                logFile.write('Task type               : Minimization or MD cooling/heating\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine            : MEE (non-peridoic DREIDING force field)\n')
            elif self.forceEngine is MpeForceEngine:
                logFile.write('Force engine            : MPE (peridoic DREIDING force field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine            : ReaxFF \n')
            elif self.forceEngine is IMDForceEngine_noshift:
                logFile.write('Force engine            : IMD-EAM (no shift) \n')
                logFile.write('IMD-EAM FF specification: '+str(self.imdEamFSP)+'\n')
            elif self.forceEngine is IMDForceEngine_shift:
                logFile.write('Force engine            : IMD-EAM (shift) \n')
                logFile.write('IMD-EAM FF specification: '+str(self.imdEamFSP)+'\n')
            if self.isPeriodic == 0:
                logFile.write('Periodic boundary cond. : Non-periodic \n')
            else:   
                logFile.write('Periodic boundary cond. : Periodic \n')
            #if self.valenceForceEngine is MeeForceEngine:
            #    logFile.write('Valence Force engine   : MEE (Dreiding Force Field)\n')
            #elif self.valenceforceEngine is ReaxForceEngine:
            #    logFile.write('Valence Force engine   : Reax Force Field\n')
            #if self.coulombForceEngine is MeeForceEngine:
            #    logFile.write('Coulomb Force engine   : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('Coulomb Force engine   : Reax Force Field\n')
            #if self.vdwForceEngine is MeeForceEngine:
            #    logFile.write('vdW Force engine       : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('vdW Force engine       : Reax Force Field\n')
            #if self.solvationForceEngine is MeeForceEngine:
            #    logFile.write('Solvation Force engine : MEE (Dreiding Force Field)\n')
            #elif self.coulombForceEngine is ReaxForceEngine:
            #    logFile.write('Solvation Force engine : Reax Force Field\n')
            logFile.write('System name             : '+self.molName+'\n')
            logFile.write('Unit cell dimension     : '+str(self.cellDim)+'\n')
            logFile.write('Number of atoms         : '+str(self.numAtoms)+'\n')
            logFile.write('Number of movable atoms : '+str(self.numMovableAtoms)+'\n')
            logFile.write('Number of fixed atoms   : '+str(self.numFixedAtoms)+'\n')
            logFile.write('Number of ignored atoms : '+str(self.numIgnoredAtoms)+'\n')
            logFile.write('Degree of freedom       : '+str(self.degFree)+'\n')
            if self.constrain == Rattle:
                logFile.write('Constraint              : RATTLE\n')
                str1 = 'Number of constraints   : '+str(self.numRattle)+'\n'
                logFile.write(str1) 
                if self.printLevel > 1:
                    for i in range(self.numRattle):
                        str2 = 'Distance constraint '+str(i+1)+'   : '+str(self.constraintRattle[i])+'\n'
                        logFile.write(str2)
            logFile.write('Translation vector      : ' +str(float(self.translateVector[0])) \
                                                      + ', ' +str(float(self.translateVector[1])) \
                                                      + ', ' +str(float(self.translateVector[2]))+'\n')
            logFile.write('Minimizer               : '+self.miniStr+'\n') 
            logFile.write('Integrator              : '+self.integraStr+'\n') 
            logFile.write('Thermostat              : '+self.thermoStr+'\n') 
            logFile.write('Barostat                : '+self.baroStr+'\n') 
            if self.gaussian is Gaussian1:
                logFile.write('Gaussian                : Gaussian1\n')
            elif self.gaussian is Gaussian2:
                logFile.write('Gaussian                : Gaussian2\n')
            elif self.gaussian is Gaussian3:
                logFile.write('Gaussian                : Gaussian3\n')
            if self.coolSchedule is Linear:
                logFile.write('Cooling schedule        : Linear\n')
            elif self.coolSchedule is Exponent:
                logFile.write('Cooling schedule        : Exponent\n')
            elif self.coolSchedule is Sigmoid:
                logFile.write('Cooling schedule        : Sigmoid\n')
            logFile.write('Time step (ps)          : '+str(self.timeStep/unit.ps)+'\n') 
            logFile.write('Number of steps         : '+str(self.numSteps)+'\n') 
            logFile.write('Maximal iterations(Min) : '+str(self.maxiteration)+'\n') 
            logFile.write('Maximal func_calls(Min) : '+str(self.maxfunction)+'\n') 
            logFile.write('RMS Force threshold(Min): '+str(self.threshold/unit.kcalpermol)+'\n') 
            logFile.write('RMS Coord threshold(Min): '+str(self.xthreshold/unit.Ang)+'\n') 
            logFile.write('Diff. Eng threshold(Min): '+str(self.fthreshold/unit.kcalpermol)+'\n') 
            logFile.write('Output interval(MD,Min) : '+str(self.freqOutputMD)+'\n') 
            logFile.write('Output interval(Trj)    : '+str(self.freqOutputTrj)+'\n') 
            logFile.write('Initial temperatures(K) : '+str(self.initTemps)+'\n') 
            logFile.write('Target temperatures(K)  : '+str(self.targetTemps)+'\n') 
            logFile.write('Number of thermo regions: '+str(self.numRegions)+'\n') 
            logFile.write('Region rules            : '+str(self.regionRuleStrs)+'\n') 
            logFile.write('Region parameters       : '+str(self.regionParameters)+'\n') 
            logFile.write('Target pressure (GPa)   : '+str(self.targetPress/unit.GPa)+'\n') 
            logFile.write('Output energy unit      : '+self.printEnergyFlag+'\n') 
            logFile.write('Output pressure unit    : '+self.printPressureFlag+'\n') 
            if self.printLevel == 1:
                logFile.write('Print level             : '+'Normal\n')
            elif self.printLevel == 2:
                logFile.write('Print level             : '+'Verbose\n')
            elif self.printLevel == 3:
                logFile.write('Print level             : '+'Debug\n')
            if self.printTrjLevel == 1:
                logFile.write('Print trajectory level  : '+'coord\n')
            elif self.printTrjLevel == 2:
                logFile.write('Print trajectory level  : '+'coord + vel\n')
            elif self.printTrjLevel == 3:
                logFile.write('Print trajectory level  : '+'coord + vel + force\n')


            logFile.write('=> Loading parameters and setup completed.\n') 

            logFile.close()

        return

    def createObjects(self):
    	"""
    	Create instance objects.
    	"""
        unit = Unit()

        self.minimizer = None
        self.integrator = None
        self.barostat = None
        self.thermostats = [] 
        self.regionRules = []
        self.thermoList = None

        if self.numRegions > 0:
            # Create region rules.
            for iRegion in range(self.numRegions):
                if self.regionRuleStrs[iRegion] == 'orthorhombic':
                    orthorhombicRegion = OrthorhombicRegion(self.regionParameters[iRegion])
                    self.regionRules.append(orthorhombicRegion)
                elif self.regionRuleStrs[iRegion] == 'spherical':
                    regionPar = self.regionParameters[iRegion]
                    sphericalRegion = SphericalRegion(regionPar[0], regionPar[1])
                    self.regionRules.append(sphericalRegion)

            # Create thermoList which contains region rules.
            self.thermoList = ThermoList(self.regionRules)

            # Create thermostats in various regions specified by region rules.	
            for iRegion in range(self.numRegions):
                if self.thermoStr == 'Berendsen':
                    thermostat = BerendsenThermostat(self.targetTemps[iRegion], self.timeStep, self.tauTemp)
                    self.thermostats.append(thermostat) 
                elif self.thermoStr == 'Andersen':
                    thermostat = AndersenThermostat(self.targetTemps[iRegion], self.timeStep, self.niuTemp,  \
                                                        self.gaussian, self.imove)
                    self.thermostats.append(thermostat) 
                elif self.thermoStr == 'Nose-Hoover':
                    thermostat = NoseHooverThermostat(self.molName, self.targetTemps[iRegion], self.timeStep,  \
                                         self.numNose, self.freqNose, self.numSuz) 
                    self.thermostats.append(thermostat) 
        elif self.numRegions == 0:  # Thermostat applies to entire system
            if self.thermoStr == 'Berendsen':
                thermostat = BerendsenThermostat(self.targetTemps[0], self.timeStep, self.tauTemp)
                self.thermostats.append(thermostat) 
            elif self.thermoStr == 'Andersen':
                thermostat = AndersenThermostat(self.targetTemps[0], self.timeStep, self.niuTemp,  \
                                                    self.gaussian, self.imove)
                self.thermostats.append(thermostat) 
            elif self.thermoStr == 'Nose-Hoover':
                thermostat = NoseHooverThermostat(self.molName, self.targetTemps[0], self.timeStep,  \
                                     self.numNose, self.freqNose, self.numSuz) 
                self.thermostats.append(thermostat) 

        # Create barostat.	
        if self.baroStr == 'Berendsen':
            self.barostat = BerendsenBarostat(self.targetPress, self.timeStep, self.tauPress,  \
                                                     self.compress, self.masses)
        elif self.thermoStr == 'Hoover' and self.baroStr == 'Andersen':
            self.barostat = None    # Switch off explicit thermostat and barostat,
            self.thermostat = None  # and will use implicit thermostat/barostat embeded in VVAH integrator.
        elif self.thermoStr == 'Hoover' and self.baroStr == 'Parrinello-Rahman':
            self.thermostat = None  # Switch off explicit thermostat and barostat,
            self.barostat = None    # and will use implicit thermostat/barostat embeded in VVPRH integrator.
            self.integraStr = 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics'
        elif self.baroStr == 'None': # Default barostat.
            self.barostat = None

        # Create integrator. 	
        if self.integraStr == 'Beeman': 
            self.integrator = Beeman(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'Velocity Verlet':
            self.integrator = VelocityVerlet(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'Velocity Verlet_f':
            self.integrator = VelocityVerlet_f(self.molName, self.timeStep, self.translateVector,  \
                                        self.imove, self.masses)
        elif self.integraStr == 'Leap Frog': 
            self.integrator = LeapFrog(system, self.timeStep, self.constrain,  \
                                        self.numRattle, self.constraintRattle, self.translateVector)
        elif self.integraStr == 'modified Velocity Verlet for Andersen-Hoover NPT dynamics':
            self.integrator = VelocityVerletAH(system, self.targetPress,  \
                     self.targetTemp, self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.masses) 
        elif self.integraStr == 'modified Velocity Verlet for Parrinello-Rahman-Hoover NPT dynamics':
            self.integrator = VelocityVerletPRH(system, self.targetPress, self.targetTemp,  \
                     self.timeStep, self.numNose, self.freqNose, self.numSuz, self.dim, self.imove, self.masses)
        else:  
            self.integrator = None 
        
        # Create minimizer. 	
        if self.miniStr == 'Conjugate Gradient (Shanno-Phua)':
            self.nMethod = 0
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.maxfunction, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'BFGS (Shanno-Phua)':
            self.nMethod = 1
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_SP(self.molName, self.nMethod, self.maxfunction, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'Conjugate Gradient in MEE':
            # Note MEE CG uses energy unit of kcal/mol.
            threshold = self.threshold / unit.kcalpermol
            self.minimizer = ConjugateGradient_MEE(self.maxiteration, threshold)
        elif self.miniStr == 'Conjugate Gradient (Fletcher-Reeves)':
            #self.nMethod = 0
            #self.degFree = 3 * molecule.numMovableAtoms()
            self.minimizer = ConjugateGradient_FR(self.molName, self.nMethod, self.maxiteration, self.threshold, self.freqOutputMD, self.degFree, self.coords)  
        elif self.miniStr == 'Simulated Annealing Algorithum':
            self.minimizer = SimulatedAnnealing_MD(self.coolSchedule, self.integrator, self.thermostats,  \
                                    self.barostat, self.gaussian, self.initTemps, self.targetTemps, self.thermoList, \
                                    self.numSteps, self.equSteps, self.timeStep,  \
                                    self.threshold, self.freqOutputMD, self.freqOutputTrj, self.freqCheckThermoRegion, \
                                    self.numRegions, self.masses) 
        elif self.miniStr == 'Simplex':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Simplex(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Powell':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Powell(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Conjugate Gradient (Polak-Ribiere)':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.ConjugateGradient_PR(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'BFGS':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.BFGS(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        elif self.miniStr == 'Newton CG':
            if self.printLevel > 0 and self.printLevel < 2: # Print final energy, coordinates, number of func and iter, warning flag.
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 1 and self.printLevel < 3: # Same as above
                full_output = 1
                disp = 1
                retall = 0
            elif self.printLevel > 2 and self.printLevel < 4: # Print coordinates at every step.
                full_output = 1
                disp = 1
                retall = 1
            self.minimizer = minimize.Newton_CG(self.molName, self.xthreshold, self.fthreshold, self.threshold, self.maxiteration, self.maxfunction, full_output, disp, retall, self.coords)
        else: 
            self.minimizer = None 

        logFile = open(self.molName+'.log', 'a')
        logFile.write('=> Creating objects completed.\n') 
        logFile.close()

        return

    # Read parameters from the .ana file. 
    def readAna(self, system):
        #from unit import Unit
        unit = Unit()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        try:
            anaFile = open(molName+'.ana', 'r')
        except:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! readAnaly: Failed to open .ana file.') 
            errFile.close()
            return

        self.forceEngine = None
        for line in anaFile.readlines():
            if line.find('#') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'force_check':
                        self.task = fields[1]
                    elif fields[1] == 'rdf':
                        self.task = fields[1]
                    else:  # Default task.
                        self.task = 'force_check'

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                continue

            if line.find('FORCE_CHECK_DELTA') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcDelta = float(fields[1]) * unit.Ang
                continue

            if line.find('FORCE_CHECK_MAXNUM') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcMaxNum = int(fields[1]) 
                continue

            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = unit.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = unit.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = unit.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = unit.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = unit.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = unit.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = unit.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = unit.bar
                        self.printPressureFlag = 'Bar'
                continue

        if self.printLevel > 0:
            logFile = open(molName+'.log', 'a') 
            if self.task == 'force_check':
                logFile.write('Task type              : Force check (finite difference method)\n')
            elif self.task == 'rdf':
                logFile.write('Task type              : Radial distribution function\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine           : MEE (Dreiding Force Field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine           : Reax Force Field\n')

            logFile.close()

        Control.printLevel = self.printLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag

        return

    # Set parameters from the .dbg file. 
    def readDbg(self, system):
        #from unit import Unit
        unit = Unit()

        molecule = system.getMolecule(0)
        molName = molecule.getName()

        try:
            anaFile = open(molName+'.dbg', 'r')
        except:
            errFile = open(molName+'.err', 'a') 
            errFile.write('Warning! readDbg: Failed to open .dbg file.') 
            errFile.close()
            return

        self.forceEngine = None
        for line in anaFile.readlines():
            if line.find('#') == 0:  # Skip comment line. 
                continue

            if line.find('TASK_TYPE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'force_check':
                        self.task = fields[1]
                    #elif fields[1] == 'rdf':
                    #    self.task = fields[1]
                    else:  # Default task.
                        self.task = 'force_check'

            if line.find('FORCE_ENGINE') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'mee':
                        self.forceEngine = MeeForceEngine
                    elif fields[1] == 'reax':
                        self.forceEngine = ReaxForceEngine
                    #elif fields[1] == 'master':
                    #    self.forceEngine = MasterForceEngine
                    else:  # Default force engine.
                        self.forceEngine = MeeForceEngine
                else:  # Default force engine.
                    self.forceEngine = MeeForceEngine
                continue

            if line.find('FORCE_CHECK_DELTA') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcDelta = float(fields[1]) * unit.Ang
                continue

            if line.find('FORCE_CHECK_MAXNUM') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    self.fcMaxNum = int(fields[1]) 
                continue

            if line.find('PRINT_LEVEL') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'normal':
                        self.printLevel = 1 
                    elif fields[1] == 'verbose':
                        self.printLevel = 2 
                    elif fields[1] == 'debug':
                        self.printLevel = 3 
                    else:  # Default print flag.
                        self.printLevel = 1 
                continue

            if line.find('PRINT_ENERGY_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'eV':
                        self.printEnergyUnit = unit.eV
                        self.printEnergyFlag = 'eV'
                    elif fields[1] == 'kcal/mol':
                        self.printEnergyUnit = unit.kcalpermol
                        self.printEnergyFlag = 'kcal/mol'
                    elif fields[1] == 'kJ/mol':
                        self.printEnergyUnit = unit.kJpermol
                        self.printEnergyFlag = 'kJ/mol'
                    elif fields[1] == 'hartree':
                        self.printEnergyUnit = unit.Hartree
                        self.printEnergyFlag = 'Hartree'
                    elif fields[1] == 'rydberg':
                        self.printEnergyUnit = unit.Rydberg
                        self.printEnergyFlag = 'Rydberg'
                continue

            if line.find('PRINT_PRESSURE_UNIT') == 0:
                fields = line.split()
                if len(fields) >= 2:
                    if fields[1] == 'GPa':
                        self.printPressureUnit = unit.GPa
                        self.printPressureFlag = 'GPa'
                    elif fields[1] == 'atm':
                        self.printPressureUnit = unit.atm
                        self.printPressureFlag = 'atm'
                    elif fields[1] == 'bar':
                        self.printPressureUnit = unit.bar
                        self.printPressureFlag = 'Bar'
                continue

        if self.printLevel > 0:
            logFile = open(molName+'.log', 'a') 
            if self.task == 'force_check':
                logFile.write('Task type              : Force check (finite difference method)\n')
            #elif self.task == 'rdf':
            #    logFile.write('Task type              : Radial distribution function\n')
            if self.forceEngine is MeeForceEngine:
                logFile.write('Force engine           : MEE (Dreiding Force Field)\n')
            elif self.forceEngine is ReaxForceEngine:
                logFile.write('Force engine           : Reax Force Field\n')

            logFile.close()

        Control.printLevel = self.printLevel    
        Control.printEnergyUnit = self.printEnergyUnit
        Control.printEnergyFlag = self.printEnergyFlag
        Control.printPressureUnit = self.printPressureUnit
        Control.printPressureFlag = self.printPressureFlag

        return

