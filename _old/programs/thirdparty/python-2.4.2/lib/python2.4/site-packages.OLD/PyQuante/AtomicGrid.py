#!/usr/bin/env python
"""\
 AtomicGrid.py Simple atomic grids, based on:
  A.D. Becke, 'A multicenter numerical integration scheme for
   polyatomic molecules.' J. Chem. Phys 88(4) 1988.

 The atomic grids are constructed from atomic grids that use
 Lebedev grids for the angular part, and Legendre grids for
 the radial parts.

 This program is part of the PyQuante quantum chemistry program suite

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

from GridPoint import GridPoint
from Lebedev import Lebedev
from Legendre import Legendre
from math import sin,cos,pi
from Numeric import zeros,Float,array,concatenate

Bragg = [None,
     0.50, 2.00, 1.45, 1.05, 0.85, 0.70, 0.65, 0.60, 0.50,
     2.25, 1.80, 1.50, 1.25, 1.10, 1.00, 1.00, 1.00, 2.50,
     2.20, 1.80, 1.60, 1.40, 1.35, 1.40, 1.40, 1.40, 1.35,
     1.35, 1.35, 1.35, 1.30, 1.25, 1.15, 1.15, 1.15, 2.75,
     2.35, 2.00, 1.80, 1.55, 1.45, 1.45, 1.35, 1.30, 1.35,
     1.40, 1.60, 1.55, 1.55, 1.45, 1.45, 1.40, 1.40, 3.00,
     2.60, 2.15, 1.95, 1.85, 1.85, 1.85, 1.85, 1.85, 1.85,
     1.80, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.55,
     1.45, 1.35, 1.35, 1.30, 1.35, 1.35, 1.35, 1.50, 1.90,
     1.80, 1.60, 1.90, 1.65, 3.25, 2.80, 2.15, 1.95, 1.80,
     1.80, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75,
     1.75, 1.75, 1.75, 1.75, 1.55, 1.55
     ]

# Pople atomic radii (bohr) for the SG-1 grid
PopleRadii = [None,
              1.0000, 0.5882, 3.0769, 2.0513, 1.5385, 1.2308,
              1.0256, 0.8791, 0.7692, 0.6839, 4.0909, 3.1579,
              2.5714, 2.1687, 1.8750, 1.6514, 1.4754, 1.3333]

bohr = 0.52918

tolerance = 1e-10

class AtomicGrid:
    """\
    Put together an atomic grid consisting of a Legendre radial grid
    plus a Lebedev angular grid.

    The grid can be specified using a number of radial shells in [20,24,28,32,36]
    plus a fineness in range(4), or by using a list of angular momenta,
    where the number of radial shells is determined by the length of the list.
    """
    def __init__(self, Z, nrad=32, fineness=1, spingrid=True,
                 gridtype = 'Becke'):
        self.points = []
        self.Z = Z
        Rmax = 0.5*Bragg[Z]/bohr

        if gridtype == 'Pople': # Gill, Johnson, Pople SG-1 Grids
            radial = EulerMaclaurinRadialGrid(nrad,Z)
            angpts = [SG1Angs(r,Z) for r,w in radial]
        else:
            radial = Legendre[nrad]
            angpts = [ang_mesh(float(i+1)/nrad,fineness) for i in range(nrad)]

        for i in range(nrad):
            xrad,wrad = radial[i]
            rrad = BeckeRadMap(xrad,Rmax)
            
            dr = 2*Rmax/pow(1-xrad,2)
            vol = 4*pi*rrad*rrad*dr

            nangpts = angpts[i]

            # Get the standard Leb ang shell, and use one of two
            #  algorithms (random or regular) to rotate each angular shell
            #  with respect to the other shells, so the points are
            #  further apart.
            angshell = Lebedev[nangpts] 

            if spingrid:
                angshell = regular_spin(angshell,i)
                #angshell = random_spin(angshell)

            for (xang,yang,zang,wang) in angshell:
                weight = vol*wrad*wang
                self.points.append(GridPoint(rrad*xang,rrad*yang,
                                             rrad*zang,weight))
        return

    def __len__(self): return len(self.points)
    def __getitem__(self,index): return self.points[index]

    def translate(self,x,y,z):
        "Translate each atom in the grid by some amount"
        for point in self.points: point.translate(x,y,z)
        return

    def prune(self):
        "Remove grid points marked as unnecessary"
        prune_list = []
        for i in range(len(self.points)):
            point = self.points[i]
            if point.weight() == 0: prune_list.append(i)

        # Make sure the list is in order
        prune_list.sort() 
        prune_list.reverse()
        for i in prune_list: del self.points[i]
        return

    def set_bf_amps(self,bfs):
        "Set the basis function amplitude at each grid point"
        for point in self.points: point.set_bf_amps(bfs)
        return

    def setdens(self,D):
        "Set the density at each grid point"
        for point in self.points: point.setdens(D)
        return

    def setdens0_D(self,D):
        "Set the density at each grid point"
        for point in self.points: point.setdens0_D(D)
        return

    def setdens0(self,rho0,do_renorm=1):
        totdens = 0
        for point in self.points:
            point.setdens0(rho0)
            totdens += point.dens()*point.weight()
        scalef = self.Z/totdens
        if do_renorm:
            for point in self.points:
                dens = point.dens()
                dens *= scalef
                point._dens0 = dens
                point._dens = dens
        return
    
    def weights(self):
        "Return a vector of weights of each point in the grid"
        weights = zeros(len(self.points),Float)
        for i in range(len(self.points)):
            weights[i] = self.points[i].weight()
        return weights
    
    def dens(self):
        "Return a vector of the density for each point in the grid"
        dens = zeros(len(self.points),Float)
        for i in range(len(self.points)):
            dens[i] = self.points[i].dens()
        return dens

    def bfs(self,i):
        "Return a vector of the product of two basis functions "
        " over the entire grid"
        bfs = zeros(len(self.points),Float)
        for j in range(len(self.points)):
            bfs[j] = self.points[j].bfs[i]
        return bfs

    def allbfs(self):
        "Construct a matrix with bfs in columns over the entire grid, "
        " so that R[0] is the first basis function, R[1] is the second..."
        bfs = array((),Float)
        for point in self.points:
            bfs = concatenate((bfs,point.bfs))
        return bfs

    def nbf(self):
        return self.points[0].nbf()

    def npts(self): return len(self.points)
        
    
def BeckeRadMap(x,Rmax):
    return Rmax*(1.0+x)/(1.0-x)

def ang_mesh(frac,fineness,alevs = None):
    """\
    Determine the number of points in the angular mesh based on
    the fraction of the total radial grid index frac c (0,1).

    You can optionally pass in the number of points for
    the 5 different regions
    """
    if not alevs:
        ang_levels = [
            [ 6, 14, 26, 26, 14], # Coarse
            [ 50, 50,110, 50, 26], # Medium
            [ 50,110,194,110, 50], # Fine
            [194,194,194,194,194]  # ultrafine
            ]
        alevs = ang_levels[fineness]
    nang = alevs[0]
    if frac > 0.4: nang = alevs[1]
    if frac > 0.5: nang = alevs[2]
    if frac > 0.7: nang = alevs[3]
    if frac > 0.8: nang = alevs[4]
    return nang

def random_spin(angshell):
    "Spin an angular shell by a random amount"
    import random

    x=2*pi*random.random()
    y=2*pi*random.random()
    z=2*pi*random.random()

    ang1=cos(z)
    ang2=sin(z)
    ang3=cos(y)
    ang4=sin(y)
    ang5=cos(x)
    ang6=sin(x)

    npts = len(angshell)
    # Rotations around the z axis affect x and y
    for i in range(npts):
        x,y,z,w = angshell[i]
        xtmp = ang1*x+ang2*y
        ytmp = ang1*y-ang2*x
        x,y = xtmp,ytmp

        xtmp = ang3*x+ang4*z
        ztmp = ang3*z-ang4*x
        x,z = xtmp,ztmp

        ytmp = ang5*y+ang6*z
        ztmp = ang5*z-ang6*y
        y,z = ytmp,ztmp
        angshell[i] = (x,y,z,w)

    return angshell

def regular_spin(angshell,i):
    "Spin an angular shell by a regular amount per shell"

    npts = len(angshell)
    deg_per_shell=5

    imod = i % 4
    if imod == 0:
        return angshell
    elif imod == 1:
        x=2*pi*(deg_per_shell*i)/360.
        ang5=cos(x)
        ang6=sin(x)
        for i in range(npts):
            x,y,z,w = angshell[i]
            ytmp = ang5*y+ang6*z
            ztmp = ang5*z-ang6*y
            y,z = ytmp,ztmp
            angshell[i] = (x,y,z,w)
        return angshell
    elif imod == 2:
        y=2*pi*(deg_per_shell*i)/360.
        ang3=cos(y)
        ang4=sin(y)
        for i in range(npts):
            x,y,z,w = angshell[i]
            xtmp = ang3*x+ang4*z
            ztmp = ang3*z-ang4*x
            x,z = xtmp,ztmp
            angshell[i] = (x,y,z,w)
        return angshell
    elif imod == 3:
        z=2*pi*(deg_per_shell*i)/360.
        ang1=cos(z)
        ang2=sin(z)
        for i in range(npts):
            x,y,z,w = angshell[i]
            xtmp = ang1*x+ang2*y
            ytmp = ang1*y-ang2*x
            x,y = xtmp,ytmp
            angshell[i] = (x,y,z,w)
        return angshell
    return angshell

def EulerMaclaurinRadialGrid(nrad,Z):
    # Radial part of the Gill, Johnson, Pople SG-1 grid
    R = PopleRadii[Z]
    grid = []
    for i in range(1,nrad+1):
        w = 2.*pow(R,3)*(nrad+1.)*pow(i,5)*pow(nrad+1-i,-7)
        r = R*i*i*pow(nrad+1-i,-2)
        grid.append((r,w))
    return grid

def SG1Angs(r,Z):
    # Gill, Johnson, Pople rules for SG-1 angular densities
    R = PopleRadii[Z]
    if Z in range(1,3): # H-He
        alphas = [0.25,0.5,1.0,4.5]
    elif Z in range(3,11): # Li-Ne
        alphas = [0.1667, 0.500, 0.900, 3.5]
    else: # only fit for Na-Ar
        alphas = [0.1,0.4,0.8,2.5]

    if r < alphas[0]*R: return 6
    elif r < alphas[1]*R: return 38
    elif r < alphas[2]*R: return 86
    elif r < alphas[3]*R: return 194
    return 86


    
        
