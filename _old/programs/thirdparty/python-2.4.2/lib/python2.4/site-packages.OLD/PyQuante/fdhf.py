#!/usr/bin/env python
"""\
 fdhf.py: Open shell HF using Fermi-Dirac occupation in the PyQuante framework

 This program is part of the PyQuante quantum chemistry program suite.

 Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 

 PyQuante version 1.2 and later is covered by the modified BSD
 license. Please see the file LICENSE that is part of this
 distribution. 
"""

#  Tested on NO. Seems to work pretty well, although (not surprisingly)
#   it gives a result slightly different from the UHF result. Appears to
#   require averaging, which makes the code converge very slowly. Both zero
#   temperature and finite temperature appear to work

import sys
from Numeric import sum,matrixmultiply,transpose
from math import exp
from hartree_fock import get2JmK,get_energy,getbasis,get1ints,get2ints
from LA2 import GHeigenvectors,mkdens

VERBOSE=0
default_temp = 500.0
boltz=3.166830e-6       # Boltzmann constant
averaging = 0.75 # 0 turns off, D = ave*D + (1-ave)*Dold otherwise

def get_core_open(occs,tol=0.005):
    ncore = nopen = 0
    for occ in occs:
        if occ > (1-tol): ncore += 1
        elif occ > tol: nopen += 1
    return ncore,nopen

def get_dens(orbs,occs):
    n = orbs.shape[0]
    nc,no = get_core_open(occs)
    D = matrixmultiply(transpose(orbs[:nc,:]),orbs[:nc,:])
    if VERBOSE:
        print "nbf = %d " % n
        print "Building a density matrix with %d core and %d open orbs" %\
              (nc,no)
        print occs[:nc+no]
        print D.shape
    for i in range(nc,nc+no):
        for k in range(n):
            for l in range(k+1):
                D[k,l] = D[k,l] + occs[i]*orbs[i,k]*orbs[i,l]
                D[l,k] = D[k,l]
    # Ultimately replace this loop with something like:
    #for i in range(nc,nc+no):
    #    D += occs[i]*matrixmultiply(transpose(orbs[i,:]),orbs[i,:])
    return D
            
def get_fermi_occ(efermi,en,temp=default_temp):
    kT = boltz*temp
    x = (en-efermi)/kT
    if x < -50.: return 1.
    elif x > 50.: return 0
    return 1/(1+exp(x))
    

def get_fermi_occs(efermi,orbe,temp=default_temp):
    occs = []
    for en in orbe:
        occs.append(get_fermi_occ(efermi,en,temp))
    return occs

def get_t0_occs(nel,nbf):
    occs = [0]*nbf
    nc,no = divmod(nel,2)
    for i in range(nc): occs[i] = 1.
    for i in range(nc,nc+no): occs[i] = 0.5
    return occs

def get_efermi(nel,orbe,efermi,temp=default_temp,tol=0.005):
    "Bisection method to get Fermi energy from Fermi-Dirac dist"
    elow,ehigh = -10.0,10.0
    nlow = 2*sum(get_fermi_occs(elow,orbe,temp))
    nhigh = 2*sum(get_fermi_occs(ehigh,orbe,temp))
    if VERBOSE:
        print efermi,elow,ehigh
        print nel,nlow,nhigh
    assert nlow < nel, "elow incorrect %f " % nlow
    assert nhigh > nel, "ehigh incorrect %f" % nhigh
    for i in range(100):
        efermi = (elow+ehigh)/2
        n = 2*sum(get_fermi_occs(efermi,orbe,temp))
        if abs(n-nel) < tol:
            break
        elif n < nel:
            elow = efermi
        else:
            ehigh = efermi
    else:
        print "get_fd_occs: Too many iterations"
    return efermi

def fdscf(atoms,S,h,Ints,charge=0,ConvCriteria=0.0001,MaxIter=20):
    orbe,orbs = GHeigenvectors(h,S)
    nel = atoms.get_nel(charge)
    nbf = S.shape[0]
    efermi = orbe[int(nel/2)]
    enuke = atoms.get_enuke()
    eold = 0.
    for i in range(MaxIter):
        efermi = get_efermi(nel,orbe,efermi)
        occs = get_fermi_occs(efermi,orbe)
        D = get_dens(orbs,occs)
        if averaging:
            if i: # do averaging
                D = averaging*D + (1-averaging)*D0
            D0 = D
        
        G = get2JmK(Ints,D)
        F = h+G
        orbe,orbs = GHeigenvectors(F,S)
        energy = get_energy(h,F,D,enuke)
        #print i,energy
        if abs(energy-eold) < ConvCriteria: break
        eold = energy
    return energy

def fdhf(atoms):
    from basis_631ss import basis
    bfs = getbasis(atoms,basis)
    S,h = get1ints(bfs,atoms)
    Ints = get2ints(bfs)
    energy = fdscf(atoms,S,h,Ints)
    return energy
